[1,["20g1ukYUVPvKWKBRznAKo+@f9941","95EkngnxZFbYuFpsqVTaFr@f9941","54TknWPwVPqJqeCR+Y/Czo@f9941","a9HWa5/S9KhoRWyEk61Vwd@f9941","bcrwvzz+5MWbdFlWrnFBi3@f9941","2ewRRY+FVJeLFN8+1c9pf6","afGeD/wZdPZrp4WUs/j8e8@ae8cb","69ylYO5DhBgbB8Fj+LRTro@f9941","a7Q3J5XtxB/bX3BSf5LEY2@f9941","0cZ5w+l29CaLq3joj2jOKy@c2696","7fLTVR3xtLaZyz0px7kGVG@77d60","80GPjRoWtLUIxSnuxHVLoU@1dd6b","d2r09H4wJHVZdy08NnK+rR@f9941","48XQvP7PxCmJNmXjXfBq84@f9941","ccs9isokhOa6d07vfA4SiQ@f9941","7fbR/1kSpKQrFLapYe7oCC@f9941","c8u0/QMRpKQp3yhGnXiL4B@f9941","20kQRIf1tEGqW70+/Er9/r@f9941","f8CXtpAlhIkK4xF/nly61l@f9941","a08hdNVONA/rcxs5BPvE6r@f9941","b84lEKuW9LprjxfT26C0By@f9941","53WrYhS7NB4KnN3VuvbgL8@f9941","e0Rr0RF9ZIYKdaUwp1xY2y@9292d","80GPjRoWtLUIxSnuxHVLoU@df584","7fLTVR3xtLaZyz0px7kGVG@12b06","74pagElr1OobymmpC61brW","7fLTVR3xtLaZyz0px7kGVG@fa5d9","1bNcHuB59CQYGaLwIhNRr9@f6f3a","32RpYxJKlCNbSJ0LVxwzeh@f9941","4aDWXSC/NH6YecKJZUTNVX@f9941","be/i3iOdBIXrOUei2ulcdQ@f9941","15y7JnTyRAKaV8IyhmhhoI@f9941","b2YJ/LeoVAj7u/1PauuUTZ@f9941","aaj03mnPpMVr/7MyLJqggh@73b7f","1bNcHuB59CQYGaLwIhNRr9@3a45e","afGeD/wZdPZrp4WUs/j8e8@fe2ee","aftjMyzy1Ieptzk1+/1qk8@73b7f","8f+iIjuyFIBJEVTNc7Tppr@f9941","786X04NmZIVYoUYQsBEwY4@f9941","7fLTVR3xtLaZyz0px7kGVG@4bb13","7fLTVR3xtLaZyz0px7kGVG@438fe","1brw/JvvpFnIvdrxpFCgMZ","afGeD/wZdPZrp4WUs/j8e8@73b7f","0dgD+vYNpCGZs3HJjvK+sI@f9941","2fLmfWA/NKsroAhf/6NOYp@f9941","9dPm8YoL1M9aujCOc76XDO@f9941","7ae6DcTARPVarZdrHytYcy@f9941","d7uBccB0JMpKmJTi13/eqg@f9941","5cmGaOV1pGEpRqEVyEXMef","77lFd2l5VNDIefg2xG+njh@f9941","56RhaRVGdN7Jvvv15+T5a1@f9941","93E3KbYKxEworr+tgC+dnl@f9941","461MOA2WVGIYJdPd7gs721@f9941","463xVIc2lLvoo4IkBH/h7O@f9941","61Kt0GUoFJ5IRwe8GLex3D@f9941","bdOiEnnMNKLr3a/MTaQ8Zj@f9941","faptbw5W1OipZ+tR1QhN75@f9941","58X5W8fqdHcpZnALtm5aoM@f9941","a3L+u4eBdO1Lt9DNXEEfx4@f9941","cfA8Ld4jdCMLKTPyKFBrW2@f9941","a3bV3x7UhNJqmdMpNvsOWT@f9941","13jGVI9fFGarBc7SjcgJpO@f9941","f4pPLJX3lHi40b+3SbzhCi@f9941","44RjoGNRVJgaw4zCCgqfZ6@f9941","28wbjdyDdMS7txskNZ5wZe@f9941","e8Uu0XxMxEQ5/yLmMOZf1l","99FiRbnJRBQ5uUDiSUZal/@73b7f","d3x4IMKphEKYvHuEU7yaxB","12Y9dMgWdJKJGmTiZyQR9H@17020","69diohqZJPAILhJwyRQw2e","12Y9dMgWdJKJGmTiZyQR9H@2e76e","e4GBS5/25LroavEjKIQNhZ@f9941","67SNyWoWxLYb0E7vV/xGm7@f9941","55qUnI2stDE6KWycV85Ref@f9941","3cha0s8/FGXbEUFxdzlscy","a7Z5C5w1ZMj5nptlTkARHi","b0ixpMjndDoaSJQwKF1w6D","75zXWnX2ZMCL3xyeCotNiu","0dgD+vYNpCGZs3HJjvK+sI@6c48a","13jGVI9fFGarBc7SjcgJpO@6c48a","15y7JnTyRAKaV8IyhmhhoI@6c48a","1bNcHuB59CQYGaLwIhNRr9@b8ef3","1bNcHuB59CQYGaLwIhNRr9@6e9f2","1bNcHuB59CQYGaLwIhNRr9@438fe","1bNcHuB59CQYGaLwIhNRr9@f0b43","1bNcHuB59CQYGaLwIhNRr9@ba49c","20g1ukYUVPvKWKBRznAKo+@6c48a","20kQRIf1tEGqW70+/Er9/r@6c48a","23mmFfSUREa62JBMx5ZMpn@3b02d","28wbjdyDdMS7txskNZ5wZe@6c48a","2fLmfWA/NKsroAhf/6NOYp@6c48a","32RpYxJKlCNbSJ0LVxwzeh@6c48a","23mmFfSUREa62JBMx5ZMpn@18210","23mmFfSUREa62JBMx5ZMpn@43181","44RjoGNRVJgaw4zCCgqfZ6@6c48a","461MOA2WVGIYJdPd7gs721@6c48a","463xVIc2lLvoo4IkBH/h7O@6c48a","48XQvP7PxCmJNmXjXfBq84@6c48a","4aDWXSC/NH6YecKJZUTNVX@6c48a","4b6eNqicRGSZQIVfox1DPy@89b79","53WrYhS7NB4KnN3VuvbgL8@6c48a","54TknWPwVPqJqeCR+Y/Czo@6c48a","55qUnI2stDE6KWycV85Ref@6c48a","56RhaRVGdN7Jvvv15+T5a1@6c48a","58X5W8fqdHcpZnALtm5aoM@6c48a","61Kt0GUoFJ5IRwe8GLex3D@6c48a","67SNyWoWxLYb0E7vV/xGm7@6c48a","69ylYO5DhBgbB8Fj+LRTro@6c48a","4b6eNqicRGSZQIVfox1DPy@834fd","4b6eNqicRGSZQIVfox1DPy@66609","77lFd2l5VNDIefg2xG+njh@6c48a","786X04NmZIVYoUYQsBEwY4@6c48a","7ae6DcTARPVarZdrHytYcy@6c48a","7fLTVR3xtLaZyz0px7kGVG@f4d2a","7fLTVR3xtLaZyz0px7kGVG@7c993","7fbR/1kSpKQrFLapYe7oCC@6c48a","80GPjRoWtLUIxSnuxHVLoU@0e838","80GPjRoWtLUIxSnuxHVLoU@f0924","80GPjRoWtLUIxSnuxHVLoU@5c986","80GPjRoWtLUIxSnuxHVLoU@ac1d6","80GPjRoWtLUIxSnuxHVLoU@438fe","8f+iIjuyFIBJEVTNc7Tppr@6c48a","93E3KbYKxEworr+tgC+dnl@6c48a","95EkngnxZFbYuFpsqVTaFr@6c48a","9dPm8YoL1M9aujCOc76XDO@6c48a","a08hdNVONA/rcxs5BPvE6r@6c48a","a3L+u4eBdO1Lt9DNXEEfx4@6c48a","a3bV3x7UhNJqmdMpNvsOWT@6c48a","a7Q3J5XtxB/bX3BSf5LEY2@6c48a","e6v62Zsu5HXpnhzK4LNBqp@18210","e6v62Zsu5HXpnhzK4LNBqp@74e9f","a9HWa5/S9KhoRWyEk61Vwd@6c48a","afGeD/wZdPZrp4WUs/j8e8@1e178","afGeD/wZdPZrp4WUs/j8e8@43bd2","afGeD/wZdPZrp4WUs/j8e8@e713a","afGeD/wZdPZrp4WUs/j8e8@65479","afGeD/wZdPZrp4WUs/j8e8@438fe","fdyj2CldxPW4QZfy/xDpTa@f4a1b","fdyj2CldxPW4QZfy/xDpTa@80d75","b2YJ/LeoVAj7u/1PauuUTZ@6c48a","b84lEKuW9LprjxfT26C0By@6c48a","bcrwvzz+5MWbdFlWrnFBi3@6c48a","bdOiEnnMNKLr3a/MTaQ8Zj@6c48a","be/i3iOdBIXrOUei2ulcdQ@6c48a","c8u0/QMRpKQp3yhGnXiL4B@6c48a","ccs9isokhOa6d07vfA4SiQ@6c48a","cfA8Ld4jdCMLKTPyKFBrW2@6c48a","d2r09H4wJHVZdy08NnK+rR@6c48a","d7uBccB0JMpKmJTi13/eqg@6c48a","e4GBS5/25LroavEjKIQNhZ@6c48a","e6v62Zsu5HXpnhzK4LNBqp@3b02d","f4pPLJX3lHi40b+3SbzhCi@6c48a","f8CXtpAlhIkK4xF/nly61l@6c48a","faptbw5W1OipZ+tR1QhN75@6c48a","fdyj2CldxPW4QZfy/xDpTa@575b7"],["node","_parent","_spriteFrame","_textureSource","_normalSprite","targetInfo","_target","_hoverSprite","_pressedSprite","_disabledSprite","root","value","_effectAsset","asset","_mesh","mainTexture","data","_checkMark","target","_skeleton","source","graph","to","from","clip","_cameraComponent","scene","prefabBerries","prefabSteak","prefabTwigs","prefabSeaweed","btnNormalSF","btnSelectSF","_anyState","_exitState","_entryState","_defaultClip","kangarooNode"],["cc.SpriteFrame",["cc.Node",["_name","_layer","_active","_objFlags","_id","__editorExtras__","_parent","_components","_lpos","_prefab","_lrot","_euler","_children","_lscale"],-3,1,9,5,4,5,5,2,5],["cc.Sprite",["_sizeMode","_type","node","_spriteFrame","__prefab","_color"],1,1,6,4,5],["cc.Label",["_string","_actualFontSize","_fontSize","_lineHeight","_isBold","_isSystemFontUsed","_overflow","_enableWrapText","node","_color","__prefab"],-5,1,5,4],["cc.Node",["_name","_layer","_active","_id","_objFlags","_components","_parent","_children","_lpos","_lrot","_euler","_prefab","__editorExtras__"],-2,12,1,2,5,5,5,4,11],["cc.Node",["_name","_layer","_children","_prefab","_lpos","_lrot","_euler","_components","_parent","_lscale"],1,12,4,5,5,5,9,1,5],["cc.Button",["_transition","node","_normalColor","_target","clickEvents","_normalSprite","_hoverSprite","_pressedSprite","_disabledSprite","__prefab"],2,1,5,1,9,6,6,6,6,4],["cc.Node",["_name","_layer","_children","_prefab","_lpos","_lrot","_euler","_parent"],1,9,4,5,5,5,1],["cc.UITransform",["node","_contentSize","__prefab"],3,1,5,4],["cc.Node",["_name","_id","_active","_parent","_components","_lpos","_children","_lrot","_euler"],0,1,2,5,2,5,5],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides","mountedComponents","mountedChildren"],1,9,9,9],["cc.Widget",["_alignFlags","_bottom","_originalWidth","_left","_right","_top","_isAbsBottom","_originalHeight","node","__prefab"],-5,1,4],["cc.TargetOverrideInfo",["propertyPath","target","targetInfo","source","sourceInfo"],2,1,4,1,4],["cc.MeshRenderer",["_name","node","_materials","lightmapSettings","_mesh","__prefab"],2,1,3,4,6,4],["cc.PrefabInfo",["fileId","root","instance","asset","targetOverrides","nestedPrefabInstanceRoots"],2,1,4,6,9,2],["cc.PrefabInfo",["fileId","root","asset","nestedPrefabInstanceRoots"],2,1,1,2],["cc.Toggle",["_isChecked","_interactable","node","_normalColor","_target","_checkMark","_normalSprite","clickEvents","checkEvents"],1,1,5,1,1,6,9,9],["cc.animation.AnimationController",["node","__prefab","graph"],3,1,4,6],["cc.UIMeshRenderer",["node"],3,1],["cc.Camera",["_clearFlags","_visibility","_projection","_priority","_orthoHeight","_far","node","_color"],-3,1,5],["eb8b7+ixMxD2KAScxnIdYKz",["_enabled","node","kangarooNode"],2,1,1],["cc.Prefab",["_name"],2],["cc.SkeletalAnimation",["node","__prefab","_clips","_defaultClip"],3,1,4,3,6],["cc.Material",["_states","_defines","_name","_props"],0,12],["cc.animation.BinaryCondition",["operator","lhs","rhs"],2,4,4],["cc.animation.BindableNumber",["variable"],2],["cc.SceneAsset",["_name"],2],["e1635qo31ZDXY0lR5t4Pnha",["node"],3,1],["cc.PrefabInstance",["fileId","prefabRootNode","mountedComponents","propertyOverrides"],2,1,9,9],["cc.MountedChildrenInfo",["targetInfo","nodes"],3,4,2],["cc.TargetInfo",["localID"],2],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,8],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,1],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,6],["cc.CompPrefabInfo",["fileId"],2],["cc.Canvas",["node","__prefab","_cameraComponent"],3,1,4,1],["cc.Scene",["_name","_children","_prefab","_globals"],2,2,4,4],["cc.SceneGlobals",["ambient","shadows","_skybox","fog","octree"],3,4,4,4,4,4],["cc.AmbientInfo",["_skyIllumLDR","_skyColorHDR","_skyColorLDR"],2,5,5],["cc.ShadowsInfo",["_shadowColor"],3,5],["cc.SkyboxInfo",[],3],["cc.FogInfo",["_fogColor"],3,5],["cc.OctreeInfo",[],3],["cc.ClickEvent",["_componentId","handler","target"],1,1],["cc.ToggleContainer",["node"],3,1],["39f2fM7jelFaZyUGOwsWI38",["node"],3,1],["75348tPWIlDzr3PoY+ONjZ9",["node"],3,1],["cc.ModelLightmapSettings",[],3],["cc.PlaneCollider",["node"],3,1],["cc.MountedComponentsInfo",["targetInfo","components"],3,4,9],["cc.DirectionalLight",["_shadowBias","_shadowNear","_shadowFar","node","_staticSettings"],0,1,4],["cc.StaticLightSettings",[],3],["48028piprRLMaVhc/TgnTtM",["node"],3,1],["b8d4b3RAspMgahjL55H+VVV",["node"],3,1],["da8dfdQT5RBn4slnXwblDiG",["node"],3,1],["d5570+aNMNBpKsWeic7F5lj",["node","registrationPopup","titleLabel","btnMap","btnHabitat","btnPicture","btnFood"],3,1,1,1,1,1,1,1],["e82abKmN3RKEZxtRGra74Dr",["node"],3,1],["2b974OfW8lHy6X91zIaDTZD",["node"],3,1],["38f24x0crREJarqw3t2YPCS",["node"],3,1],["facc9jj535Fnre+IlyJZiWZ",["node","foodUI","characterSelectUI","homeUI","encyclopediaUI","changeAnimalUI","animalLabel"],3,1,1,1,1,1,1,1],["48620PnKRFFB6jQjEJujCIK",["node","mainCamera","sphere","targetNode","kangarooNode"],3,1,1,1,1,1],["48620PnKRFFB6jQjEJujCIK",["mainCamera","sphere","targetNode","node","__prefab","kangarooNode"],0,1,4,1],["cc.Mesh",["_native","_hash","_struct"],1,11],["cc.SkinnedMeshRenderer",["node","__prefab","_materials","lightmapSettings","_skinningRoot","_mesh","_skeleton"],3,1,4,3,4,1,6,6],["cc.Skeleton",["_name","_hash","_joints","_bindposes"],0,12],["cc.Material",["_props","_defines"],1],["cc.EffectAsset",["_name","shaders","techniques"],0],["36bf7HXO8BIo6hgAnIa2Qi5",["node","__prefab"],3,1,4],["cc.animation.AnimationGraph",["_layers","_variables"],3,9,11],["cc.animation.Layer",["_stateMachine"],3,4],["cc.animation.StateMachine",["_states","_transitions","_entryState","_exitState","_anyState"],3,2,9,1,1,1],["cc.animation.Transition",["from","to"],3,1,1],["cc.animation.AnimationTransition",["_exitCondition","from","to","conditions"],2,1,1,9],["cc.animation.PlainVariable",[],3],["cc.animation.Motion",["name","motion"],2,4],["cc.animation.ClipMotion",["clip"],3,6],["cc.animation.State",["name"],2]],[[30,0,2],[15,0,1,2,2],[35,0,1,2,2],[32,0,1,2,3],[34,0,1,2,3],[8,0,1,1],[1,0,6,9,8,10,11,2],[1,0,6,12,9,8,10,11,2],[46,0,1,2,3],[2,0,2,3,2],[2,1,0,2,3,3],[37,0,2],[1,0,1,6,7,8,3],[1,0,1,6,9,8,10,11,3],[7,0,7,2,3,4,5,6,2],[1,0,1,6,12,7,8,3],[1,0,1,6,7,3],[6,0,1,4,2,3,5,6,7,8,2],[8,0,1],[36,0,1,2,2],[1,0,1,6,12,9,8,10,11,3],[6,0,1,2,3,5,6,7,8,2],[52,0,1,1],[14,0,1,2,3,2],[50,1],[23,2,0,1,3,4],[1,0,2,1,6,7,8,4],[7,0,1,7,2,3,4,5,6,3],[65,0,1,2,3],[31,0,1,2,2],[1,3,5,6,9,3],[1,0,6,7,9,10,11,2],[10,0,3,2,2],[2,2,3,1],[1,0,12,9,8,10,11,2],[5,0,2,3,4,5,6,2],[21,0,2],[1,0,2,1,6,12,7,8,4],[1,0,2,1,6,7,4],[5,0,8,2,3,4,5,6,2],[12,0,3,4,1,2,2],[17,0,1],[18,1],[3,0,1,2,6,7,8,9,6],[66,0,1,2,3,4,5,6,1],[1,0,1,6,7,10,11,3],[1,0,3,1,6,7,4],[1,0,6,9,8,2],[1,0,12,7,9,13,2],[4,0,1,7,5,8,3],[4,0,1,6,7,5,8,9,10,3],[4,0,2,1,6,5,8,4],[5,0,2,7,3,2],[8,0,2,1,1],[8,1],[33,0,1,2,2],[12,0,3,1,2,2],[2,2,1],[2,0,2,5,3,2],[2,0,2,2],[16,0,2,7,3,4,8,5,6,2],[6,0,1,4,2,3,2],[13,1,5,2,3,4,1],[3,0,1,2,3,5,4,8,9,7],[21,1],[22,0,1,1],[67,0,1,2,3,4],[70,0,1,1],[1,0,2,1,6,12,7,4],[1,0,6,12,9,10,11,2],[1,0,1,12,9,8,10,11,3],[4,0,2,1,6,7,5,8,4],[4,4,6,11,12,2],[17,0,1,2,1],[79,0,2],[1,3,5,9,3],[1,0,1,6,12,7,3],[1,0,1,6,7,8,10,11,3],[1,0,4,6,7,8,13,3],[1,0,1,7,8,3],[1,0,4,6,7,8,3],[1,0,6,9,8,10,13,11,2],[4,0,2,1,6,7,5,4],[4,0,1,6,5,3],[9,0,1,3,4,5,3],[5,0,1,2,3,4,5,6,3],[7,0,2,3,4,5,6,2],[10,0,1,3,2,3],[28,0,1,2,3,2],[11,0,2,7,8,4],[2,1,0,2,3],[6,0,1,2,3,6,7,8,2],[13,0,1,2,3,4,2],[3,0,1,2,3,5,4,8,7],[69,0,1,2,4],[75,0,1,2,3,2],[25,0,2],[25,1],[77,0,1,2],[78,0,1],[26,0,2],[1,0,2,1,12,7,8,4],[1,0,2,1,12,7,8,13,4],[1,0,3,4,6,7,4],[1,0,6,12,7,2],[1,0,2,1,6,7,8,10,13,11,4],[1,0,3,2,1,6,7,5],[1,0,1,6,9,8,10,13,11,3],[1,0,1,6,7,9,10,11,3],[1,0,1,6,12,9,10,11,3],[1,0,12,9,10,11,2],[1,0,6,7,9,8,10,11,2],[4,0,1,3,7,5,8,4],[4,0,1,6,7,5,8,3],[9,0,2,1,3,6,4,5,7,8,4],[9,0,3,4,5,2],[5,0,1,2,7,3,4,9,3],[5,0,8,2,3,4,2],[5,0,2,7,3,4,5,6,2],[7,0,7,2,3,4,2],[27,0,1],[14,4,5,1],[15,0,1,2,3,2],[10,0,1,4,2,3],[29,0,1,1],[38,0,1,2,1],[11,0,3,4,5,1,2,8,9,7],[11,0,1,6,8,4],[39,0,1,2,3,2],[12,0,1,2,2],[40,0,1,2,3,4,1],[41,0,1,2,2],[42,0,1],[43,1],[44,0,1],[45,1],[2,1,0,2,4,3],[2,0,2,4,3,2],[2,0,2,5,2],[16,1,2,3,4,5,6,2],[47,0,1],[6,0,1,9,4,2,3,2],[6,1,4,5,1],[48,0,1],[49,0,1],[13,1,2,3,4,1],[51,0,1],[18,0,1],[19,0,1,3],[19,2,3,4,5,0,1,6,7,7],[3,0,1,2,4,8,10,9,5],[3,0,1,2,3,8,9,5],[3,0,1,2,3,5,8,9,6],[3,0,1,2,3,6,8,6],[3,0,1,2,3,8,5],[3,0,1,4,8,9,4],[3,0,1,2,8,9,4],[53,0,1,2,3,4,4],[54,1],[55,0,1],[56,0,1],[57,0,1],[58,0,1,2,3,4,5,6,1],[59,0,1],[60,0,1],[20,0,1,2,2],[20,1,1],[61,0,1],[62,0,1,2,3,4,5,6,1],[63,0,1,2,3,4,1],[64,0,1,2,3,4,5,4],[22,0,1,2,3,1],[23,0,1,3,3],[68,0,1,3],[71,0,1,1],[72,0,1],[73,0,1,2,3,4,1],[74,0,1,1],[24,0,1,2,2],[24,1,2,1],[76,1]],[[[[100,"main"],[101,"UnlockScreen",false,33554432,[-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15],[[18,-1],[120,-2]],[1,0,-5.627,0]],[75,0,{},[23,"53vKouf8tIqrJE9sorGNMt",-25,[123,"80xhohs6VOb42xHJ40Sxv0",null,[[124,[0,["53vKouf8tIqrJE9sorGNMt"]],[-22,-23,-24]]],[[29,["_lpos"],[0,["53vKouf8tIqrJE9sorGNMt"]],[1,0,0,0]],[3,"Animal",["_name"],[0,["53vKouf8tIqrJE9sorGNMt"]]],[29,["_lrot"],[0,["53vKouf8tIqrJE9sorGNMt"]],[3,0,1,0,6.123233995736766e-17]],[29,["_euler"],[0,["53vKouf8tIqrJE9sorGNMt"]],[1,0,180,0]],[55,["sphere"],[0,["f0+X1ZhodFgJJg4GPQVMFV"]],-16],[55,["mainCamera"],[0,["f0+X1ZhodFgJJg4GPQVMFV"]],-17],[55,["targetNode"],[0,["f0+X1ZhodFgJJg4GPQVMFV"]],-18],[55,["feedPosition"],[0,["f0+X1ZhodFgJJg4GPQVMFV"]],-19],[4,true,["_active"],-20],[3,true,["_active"],[0,["53vKouf8tIqrJE9sorGNMt"]]],[3,"VD302_Kangaroo_Toy",["_name"],[0,["1dRKqITCJJR6zNWur3+Cgc","5fl0cfxJ5Rs5ovU2QsXaQ9"]]],[2,["_lpos"],-21,[1,0,0,0]]]],146]],[112,"Canvas",33554432,"a21pQl119Bb7AG+mipSq+H",[-31,-32,-33,-34,-35,-36,-37,1,-38,-39],[[[53,-26,[11,"0dngp/9gNO34wUQjZfN/CX"],[5,1080,1920]],[125,-28,[11,"3f2oTdCepERZdpmIfLsrhd"],-27],[126,45,-5.684341886080802e-14,-5.684341886080802e-14,1.1368683772161603e-13,1.1368683772161603e-13,960,-29,[11,"e8a+bU/8dPDbbJguUzLdoF"]],-30],4,4,4,1],[1,540,960.0000000000001,0]],[113,"NatoonsEncyclopedia",33554432,3,[-42,-43,-44,-45,-46,-47],[[[18,-40],-41],4,1],[1,2.967,-40.682,0]],[82,"SelectLockAnimal",false,33554432,3,[-50,-51,-52,-53,-54,-55,-56],[[[18,-48],-49],4,1]],[71,"ChangeAnimal",false,33554432,3,[-60,-61,-62,-63,-64],[[[18,-57],-58,-59],4,1,1],[1,0,-523.271,0]],[128,"main",[-75,-76,-77,3,-78,-79,-80,2,-81,-82],[121,[[40,["_target"],4,[0,["4ewwOt9QZJsY2F+NqU3YyG"]],4,[0,["fcKw7GaxtECYcSJZlMX6nO"]]],[40,["_target"],1,[0,["ebxyx+i/dHUpt9pbi5K/z8"]],1,[0,["f8RgWEl+dFdqmEC9XtUBBl"]]],[40,["_target"],1,[0,["8d4BE+5iJN0Idh6DyimFDd"]],1,[0,["ffvBmgoHVBSo4YQj3mMC7U"]]],[56,["encyclopediaUI"],-71,4,[0,["afXaHe/AtAta5arjNx60zH"]]],[40,["kangarooNode"],2,[0,["f0+X1ZhodFgJJg4GPQVMFV"]],2,[0,["1dRKqITCJJR6zNWur3+Cgc","8fJHyWPHhT77T0qzBIqM/Z"]]],[40,["feedPosition"],2,[0,["f0+X1ZhodFgJJg4GPQVMFV"]],2,[0,["b1ejwKP8BBD6UH4x6Zi3XS"]]],[56,["kangaroo"],-72,2,[0,["f0+X1ZhodFgJJg4GPQVMFV"]]],[56,["kangarooNode"],-73,2,[0,["1dRKqITCJJR6zNWur3+Cgc","8fJHyWPHhT77T0qzBIqM/Z"]]],[129,["animalModel"],2,[0,["1dRKqITCJJR6zNWur3+Cgc","8fJHyWPHhT77T0qzBIqM/Z"]]],[56,["feedPosition"],-74,2,[0,["b1ejwKP8BBD6UH4x6Zi3XS"]]]],[-65,-66,-67,-68,-69,-70,2]],[130,[131,0.78125,[2,0.2,0.5019607843137255,0.8,0.520833125],[2,0.2,0.5019607843137255,0.8,0.520833125]],[132,[4,4283190348]],[133],[134,[4,4292993505]],[135]]],[71,"Home",false,33554432,3,[-85,-86,-87,-88,-89,-90],[[[18,-83],-84],4,1],[1,0,-609.826,0]],[71,"Food",false,33554432,3,[-93,-94,-95,-96,-97,-98],[[[18,-91],-92],4,1],[1,0,-418.796,0]],[82,"RegistrationPopup",false,33554432,4,[-101,-102,-103,-104,-105,-106],[[[18,-99],-100],4,1]],[49,"Kangaroo",33554432,[-113,-114,-115],[[[5,-107,[5,142,146]],[9,0,-108,179],[60,false,-112,[[8,"c8d65aN9XJPtacH/s2uxMQ5","unlock",-111]],[4,4292269782],-110,[[8,"eb8b7+ixMxD2KAScxnIdYKz","changeAnimal",6],[8,"48620PnKRFFB6jQjEJujCIK","init",2]],-109,180],null],4,4,4,0],[1,-349.242,2.083,0]],[49,"Lion",33554432,[-122,-123,-124],[[[5,-116,[5,142,146]],[9,0,-117,164],[60,false,-121,[[8,"c8d65aN9XJPtacH/s2uxMQ5","unlock",-120]],[4,4292269782],-119,[[8,"eb8b7+ixMxD2KAScxnIdYKz","changeAnimal",6],[8,"48620PnKRFFB6jQjEJujCIK","init",2]],-118,165],null],4,4,4,0],[1,-182.20550000000003,2.0825000000000387,0]],[49,"Flamingo",33554432,[-131,-132,-133],[[[5,-125,[5,142,146]],[9,0,-126,168],[60,false,-130,[[8,"c8d65aN9XJPtacH/s2uxMQ5","unlock",-129]],[4,4292269782],-128,[[8,"eb8b7+ixMxD2KAScxnIdYKz","changeAnimal",6],[8,"48620PnKRFFB6jQjEJujCIK","init",2]],-127,169],null],4,4,4,0],[1,-13.517,2.083,0]],[49,"Giraffe",33554432,[-140,-141,-142],[[[5,-134,[5,142,146]],[9,0,-135,172],[60,false,-139,[[8,"c8d65aN9XJPtacH/s2uxMQ5","unlock",-138]],[4,4292269782],-137,[[8,"eb8b7+ixMxD2KAScxnIdYKz","changeAnimal",6],[8,"48620PnKRFFB6jQjEJujCIK","init",2]],-136,173],null],4,4,4,0],[1,156.827,2.083,0]],[76,"Content",33554432,4,[-144,-145,-146,-147,-148,-149],[[18,-143]]],[15,"Content",33554432,6,[12,11,13,14,-152],[[5,-150,[5,857.5889999999999,162.163]],[140,-151]],[1,111.2055,-18.9185,0]],[102,"Access",false,33554432,[-159],[[53,-153,[11,"98TYGMtwRBTYZZn4EZmhzJ"],[5,461.28875,96]],[136,1,0,-154,[11,"77BcV1zfNHo4LI4KRqZupe"]],[141,2,-157,[11,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"75348tPWIlDzr3PoY+ONjZ9","Playing",-156]],[4,4292269782],-155],[127,20,0.09850047320089966,false,-158]],[1,0,-732.4790914542726,0],[1,0.8,0.8,1]],[84,"FoodManager","bfk1ODq4dLBbD7LBDFa8L3",7,[-160],[1,0,6,0]],[76,"BG",33554432,5,[-163,-164,-165,-166],[[5,-161,[5,1080,1920]],[33,-162,134]]],[0,["bcbBLaSAhbuZMFUUZNLvRX"]],[0,["4cq3CaMM9QFplY9tFHtlLH"]],[0,["a5Ur2McGJUfKEIm/lueZtm"]],[0,["08p3MFuydXL4oM9CbjboO3"]],[15,"IconDefault",33554432,16,[-172,-173],[[5,-167,[5,128,128]],[9,0,-168,175],[139,false,-171,[4,4292269782],-170,-169,176]],[1,-527.714,1.49,0]],[0,["8fJHyWPHhT77T0qzBIqM/Z"]],[0,["08p3MFuydXL4oM9CbjboO3"]],[0,["35MaNWaVpaXITwGugCw+yp"]],[0,["49pWBJK15R+45zZnNOgfJN"]],[68,"CameraPermissionPopup",false,33554432,1,[-176,-177,-178,-179],[[18,-174],[143,-175]]],[103,"AppManager",512,"32tT6WWCBDoLWGv39PtYAD",7,[[144,-180]]],[15,"KangarooTitle",33554432,3,[-182,-183,-184],[[18,-181]],[1,0,820.068,0]],[15,"Steak",33554432,9,[-189],[[5,-185,[5,140,140]],[10,1,0,-186,9],[17,2,-188,[[8,"48028piprRLMaVhc/TgnTtM","spawnSteak",18]],[4,4292269782],-187,10,11,12,13]],[1,-80.147,0,0]],[15,"Twig",33554432,9,[-194],[[5,-190,[5,140,140]],[10,1,0,-191,15],[17,2,-193,[[8,"48028piprRLMaVhc/TgnTtM","spawnTwigs",18]],[4,4292269782],-192,16,17,18,19]],[1,71.176,0,0]],[15,"Berries",33554432,9,[-199],[[5,-195,[5,140,140]],[10,1,0,-196,26],[17,2,-198,[[8,"48028piprRLMaVhc/TgnTtM","spawnBerries",18]],[4,4292269782],-197,27,28,29,30]],[1,-229.542,0,0]],[15,"Seaweed",33554432,9,[-204],[[5,-200,[5,140,140]],[10,1,0,-201,32],[17,2,-203,[[8,"48028piprRLMaVhc/TgnTtM","spawnSeaweed",18]],[4,4292269782],-202,33,34,35,36]],[1,225.47,0,0]],[15,"KangarooTitle",33554432,4,[-206,-207,-208,-209],[[18,-205]],[1,-37.342,860.75,0]],[50,"LocationBtn",33554432,15,[-213],[[[5,-210,[5,200,200]],[10,1,0,-211,75],-212],4,4,1],[1,-275,-740,3.1554436208840472e-30],[3,-6.123233995736766e-17,-6.123233995736766e-17,1,-3.749399456654644e-33],[1,180,180,0]],[50,"HabitatBtn",33554432,15,[-217],[[[5,-214,[5,200,200]],[10,1,0,-215,77],-216],4,4,1],[1,-85,-740,0],[3,1,6.123233995736766e-17,6.123233995736766e-17,3.749399456654644e-33],[1,180,-7.016709298534876e-15,7.016709298534876e-15]],[50,"PictureBtn",33554432,15,[-221],[[[5,-218,[5,200,200]],[10,1,0,-219,79],-220],4,4,1],[1,105,-740,0],[3,0,0,1,6.123233995736766e-17],[1,180,180,7.016709298534876e-15]],[50,"FoodBtn",33554432,15,[-225],[[[5,-222,[5,200,200]],[10,1,0,-223,81],-224],4,4,1],[1,300,-740,0],[3,1,6.123233995736766e-17,6.123233995736766e-17,6.123233995736766e-17],[1,180,-7.016709298534876e-15,7.016709298534876e-15]],[15,"Food",33554432,8,[-230],[[5,-226,[5,140,140]],[10,1,0,-227,87],[17,2,-229,[[8,"facc9jj535Fnre+IlyJZiWZ","gotoFeedAnimal",3]],[4,4292269782],-228,88,89,90,91]],[1,-147.596,0,0]],[15,"Encyclopedia",33554432,8,[-235],[[5,-231,[5,140,140]],[10,1,0,-232,93],[17,2,-234,[[8,"facc9jj535Fnre+IlyJZiWZ","gotoEncyclopedia",3]],[4,4292269782],-233,94,95,96,97]],[1,4.599,0,0]],[15,"AnimalSelect",33554432,8,[-240],[[5,-236,[5,140,140]],[10,1,0,-237,104],[17,2,-239,[[8,"facc9jj535Fnre+IlyJZiWZ","gotoChangeAnimalUI",3],[8,"75348tPWIlDzr3PoY+ONjZ9","activeAnimal",30]],[4,4292269782],-238,105,106,107,108]],[1,163.767,0,0]],[15,"Kangaroo",33554432,5,[-245],[[5,-241,[5,257.94,140]],[10,1,0,-242,135],[17,2,-244,[[8,"38f24x0crREJarqw3t2YPCS","hide",5],[8,"e1635qo31ZDXY0lR5t4Pnha","show",1],[8,"c8d65aN9XJPtacH/s2uxMQ5","unlock",11]],[4,4292269782],-243,181,182,183,184]],[1,-247.646,-630.782,0]],[37,"Kangaroo",false,33554432,6,[-250],[[5,-246,[5,140,140]],[10,1,0,-247,138],[21,2,-249,[4,4292269782],-248,139,140,141,142]],[1,-247.589,-21.071,0]],[15,"Flamingo",33554432,5,[-255],[[5,-251,[5,257.94,140]],[10,1,0,-252,185],[17,2,-254,[[8,"38f24x0crREJarqw3t2YPCS","hide",5],[8,"e1635qo31ZDXY0lR5t4Pnha","show",1],[8,"c8d65aN9XJPtacH/s2uxMQ5","unlock",13]],[4,4292269782],-253,186,187,188,189]],[1,248.987,-630.782,0]],[15,"Giraffe",33554432,5,[-260],[[5,-256,[5,257.94,140]],[10,1,0,-257,190],[17,2,-259,[[8,"38f24x0crREJarqw3t2YPCS","hide",5],[8,"e1635qo31ZDXY0lR5t4Pnha","show",1],[8,"c8d65aN9XJPtacH/s2uxMQ5","unlock",14]],[4,4292269782],-258,191,192,193,194]],[1,248.987,54.445,0]],[15,"Lion",33554432,5,[-265],[[5,-261,[5,257.94,140]],[10,1,0,-262,195],[17,2,-264,[[8,"38f24x0crREJarqw3t2YPCS","hide",5],[8,"e1635qo31ZDXY0lR5t4Pnha","show",1],[8,"c8d65aN9XJPtacH/s2uxMQ5","unlock",12]],[4,4292269782],-263,196,197,198,199]],[1,-241.359,54.445,0]],[68,"Comfirm",false,33554432,5,[-268,-269,-270],[[5,-266,[5,600,400]],[9,0,-267,210]]],[15,"Yes",33554432,49,[-275],[[5,-271,[5,150,50]],[10,1,0,-272,200],[21,2,-274,[4,4292269782],-273,201,202,203,204]],[1,-140,-75.506,0]],[15,"No",33554432,49,[-280],[[5,-276,[5,150,50]],[10,1,0,-277,205],[21,2,-279,[4,4292269782],-278,206,207,208,209]],[1,140,-75.506,0]],[15,"Camera",33554432,1,[-285],[[5,-281,[5,128,128]],[10,1,0,-282,215],[17,2,-284,[[8,"facc9jj535Fnre+IlyJZiWZ","gotoHome",3],[8,"e1635qo31ZDXY0lR5t4Pnha","hide",1],[8,"75348tPWIlDzr3PoY+ONjZ9","Playing",30],[8,"75348tPWIlDzr3PoY+ONjZ9","activeAnimal",30]],[4,4292269782],-283,216,217,218,219]],[1,0,-692.825,0]],[0,["bcbBLaSAhbuZMFUUZNLvRX"]],[0,["a5Ur2McGJUfKEIm/lueZtm"]],[15,"Allow",33554432,29,[-290],[[5,-286,[5,100,40]],[10,1,0,-287,243],[21,2,-289,[4,4292269782],-288,244,245,246,247]],[1,-100,-55.339,0]],[15,"Deny",33554432,29,[-295],[[5,-291,[5,100,40]],[10,1,0,-292,248],[21,2,-294,[4,4292269782],-293,249,250,251,252]],[1,100,-55.339,0]],[0,["bcbBLaSAhbuZMFUUZNLvRX"]],[104,"Camera",3,[-298,17],[[5,-296,[5,1080,1920]],[89,45,100,100,-297]]],[77,"SoundButton",33554432,31,[[5,-299,[5,145,150]],[9,0,-300,2],[21,2,-302,[4,4292269782],-301,3,4,5,6]],[1,-182.646,0,0],[3,0,0,0.04212850313926799,0.9991122005176619],[1,0,0,4.829]],[12,"Close",33554432,9,[[5,-303,[5,128,128]],[10,1,0,-304,20],[17,2,-306,[[8,"b8d4b3RAspMgahjL55H+VVV","hide",9]],[4,4292269782],-305,21,22,23,24]],[1,396.049,0.871,0]],[26,"RotateL",false,33554432,4,[[5,-307,[5,128,128]],[10,1,0,-308,37],[21,2,-310,[4,4292269782],-309,38,39,40,41]],[1,-278.669,211.448,0]],[26,"RotateR",false,33554432,4,[[5,-311,[5,128,128]],[10,1,0,-312,42],[21,2,-314,[4,4292269782],-313,43,44,45,46]],[1,289.286,211.448,0]],[77,"SoundButton",33554432,36,[[5,-315,[5,145,150]],[9,0,-316,49],[21,2,-318,[4,4292269782],-317,50,51,52,53]],[1,-182.646,0,0],[3,0,0,0.04212850313926799,0.9991122005176619],[1,0,0,4.829]],[0,["5fl0cfxJ5Rs5ovU2QsXaQ9"]],[0,["61SpoqJn9XKIWNc6m3Gvr3"]],[0,["f3CmudYmJTjK7M6nViAmg5"]],[0,["f4npe4uvhfYIaPYyEku12n"]],[0,["24QV1ABdRedL8PrNu+86Nq"]],[0,["124ooP3KBc1Lk0UF5SkG6P"]],[0,["1aOCmC7G1QLYh3hQ/RIfCW"]],[0,["abAw8bUFFfbJbDdcCTemu+"]],[0,["82O4d8FFlZfbWoM1gQ5T0P"]],[0,["42dhuQU8NX0rXxQG7SW2YE"]],[0,["dbtmT0gRdSBIMmHDpIZtZm"]],[0,["54Lh51XGBYv7YuKOF5iKJs"]],[0,["b98OsIwtddvaimim2Y6TQy"]],[0,["bfrFfxzL1T1KmmYCwEZLjk"]],[0,["36Y+vy/Y5QJ7jAvyy3x9XZ"]],[0,["80Sxap8RleT7LfBkzDAi93"]],[0,["27lKXEzcFQsZTcP6tappE1"]],[0,["a0sQDO/bdTOryUmf6KpZ23"]],[0,["32EOimsNxW6auKvQxSU90n"]],[0,["2d7+KWFQJVFrgz3wx2r7Yn"]],[0,["a5xYRu1R9c+4gSl9Nkoyrr"]],[0,["bbzAt+/A5Za6JtvBJFLV6Q"]],[0,["8bMDwNbY5Up6fKdikNpIQL"]],[0,["c2tjMLgltSz7/DvasIQO6O"]],[0,["6bI877qbhcC6ioHfi85K1R"]],[0,["ed/f9Db/pZuZRZD4YWAqds"]],[0,["e9ki9vW3ha/oTYOTJfAkl8"]],[0,["20BgvTdsleXrtRxNyWlh//"]],[0,["7cMoqyptdaSbxJ3NJe5s4D"]],[0,["34N3Tf3Vhf6p2OCEtjbUr5"]],[0,["d7tLOit5hTsbOMYxHRvFOp"]],[0,["3dlgK1+6ZS+pIxXuBluE25"]],[0,["68RNEaQ79QPq60RxDOrbld"]],[0,["a5O6YJyIlZ0K3DMvMImW/M"]],[0,["ccJkUI+3RXpZAAZAVToHx+"]],[0,["beBTxB4F9YIazSRhrqCQYQ"]],[0,["84hrPyzk1d1ruBlx05r4WZ"]],[0,["57Le13NptWs5X3lanB4PyH"]],[0,["94nYA+SUZazqUalPScGfCg"]],[0,["0ej8X8mtRS8IOXZwhuA0cA"]],[0,["46OYGFnqVWX54eydGHqJue"]],[0,["054HrpVJ9YdrFA31Ec+dkY"]],[0,["dfbHKl6RxVqLvXw6Lt14xK"]],[0,["bex7q5czhZfLRNzKYoBLyx"]],[0,["39NhMc+jhSCqKPANQHLh8+"]],[0,["0516pAzllTEINtCBbXwvaI"]],[0,["04ZamzRGFcKJpv5KTVe1wf"]],[0,["40GhtM2Y1bgZOrgy9wQpjf"]],[0,["efGIrw9kZbM5dp1NBwHMRu"]],[0,["a3opXY1K1bs63KtREsU6Cj"]],[0,["cdSHSn+iNTHKbOD/PLegz3"]],[0,["47JEn10QFZeY7XBihtHdxT"]],[0,["53/rmZzdJZL463F9C5r7qA"]],[0,["9fgNNDboxcjIG+O1o8GHRt"]],[0,["a6aeXwf6BZdI+Q2cVg8FCt"]],[0,["82YHmJYpNUwIRpMz6/x7rh"]],[0,["56GP/33ipbt5RscKxkRlan"]],[0,["84l6lm3SBYBZ8FSo3q+7NM"]],[0,["e57STHoJpa0p56K4UDKx2N"]],[0,["6cklssd71bQpgcGHdZO8+Q"]],[12,"CRM",33554432,10,[[5,-319,[5,300,160]],[10,1,0,-320,58],[21,2,-322,[4,4292269782],-321,59,60,61,62]],[1,-200,0,0]],[12,"Skip",33554432,10,[[5,-323,[5,300,160]],[10,1,0,-324,63],[17,2,-326,[[8,"facc9jj535Fnre+IlyJZiWZ","gotoAnimalSelect",3],[8,"d5570+aNMNBpKsWeic7F5lj","hide",4],[8,"d5570+aNMNBpKsWeic7F5lj","init",4]],[4,4292269782],-325,64,65,66,67]],[1,200,0,0]],[12,"TestBtn",33554432,10,[[5,-327,[5,300,160]],[10,1,0,-328,69],[17,2,-330,[[8,"da8dfdQT5RBn4slnXwblDiG","testRedirect",10]],[4,4292269782],-329,70,71,72,73]],[1,-10.178,289.4,0]],[12,"Close",33554432,3,[[5,-331,[5,128,128]],[10,1,0,-332,84],[17,2,-334,[[8,"d5570+aNMNBpKsWeic7F5lj","hide",4],[8,"e82abKmN3RKEZxtRGra74Dr","show",8]],[4,4292269782],-333,114,115,116,117]],[1,457.403,25.755999999999972,0]],[12,"Photo",33554432,8,[[5,-335,[5,128,128]],[10,1,0,-336,98],[21,2,-338,[4,4292269782],-337,99,100,101,102]],[1,0,-219.156,0]],[12,"BtnBack",33554432,8,[[5,-339,[5,128,128]],[10,1,0,-340,109],[17,2,-342,[[8,"facc9jj535Fnre+IlyJZiWZ","gotoAnimalSelect",3],[8,"e82abKmN3RKEZxtRGra74Dr","hide",8]],[4,4292269782],-341,110,111,112,113]],[1,-400.199,1423.745,0]],[26,"RotateR",false,33554432,1,[[5,-343,[5,128,128]],[10,1,0,-344,119],[21,2,-346,[4,4292269782],-345,120,121,122,123]],[1,289.286,-296.087,0]],[26,"RotateL",false,33554432,1,[[5,-347,[5,128,128]],[10,1,0,-348,124],[21,2,-350,[4,4292269782],-349,125,126,127,128]],[1,-278.669,-296.087,0]],[26,"BtnBack",false,33554432,1,[[5,-351,[5,128,128]],[10,1,0,-352,129],[17,2,-354,[[8,"e1635qo31ZDXY0lR5t4Pnha","hide",1],[8,"38f24x0crREJarqw3t2YPCS","show",5]],[4,4292269782],-353,211,212,213,214]],[1,-443.086,863.329,0]],[0,["35MaNWaVpaXITwGugCw+yp"]],[0,["49pWBJK15R+45zZnNOgfJN"]],[78,"Plane","fdlFjhfv5EQLWAOsKIysWY",7,[[92,"Plane<ModelComponent>",-355,[155],[24],156],[146,-356]],[1,0,0,-0.01],[1,2,2,2]],[79,"BtnEdit",33554432,[[5,-357,[5,128,128]],[90,1,0,-358],[91,2,-360,[4,4292269782],-359,220,221,222]],[1,165.15,592.124,0]],[79,"BtnTick",33554432,[[5,-361,[5,128,128]],[90,1,0,-362],[91,2,-364,[4,4292269782],-363,223,224,225]],[1,318.216,592.124,0]],[37,"Kangaroo",false,33554432,1,[-366,-367,-368],[[18,-365]],[1,0,-500,0]],[37,"Flamingo",false,33554432,1,[-370,-371,-372],[[18,-369]],[1,0,-500,0]],[37,"Lion",false,33554432,1,[-374,-375,-376],[[18,-373]],[1,0,-500,0]],[37,"Giraffe",false,33554432,1,[-378,-379,-380],[[18,-377]],[1,0,-500,0]],[75,0,null,[23,"35MaNWaVpaXITwGugCw+yp",-387,[32,"bda88GGCtB44rI/IRkAuEc",[[22,[0,["35MaNWaVpaXITwGugCw+yp"]],[[41,-386]]]],[[2,["_lpos"],-381,[1,0,0,0]],[4,"VD289_Lion_Rig",["_name"],-382],[2,["_lrot"],-383,[3,0,1,0,6.123233995736766e-17]],[2,["_euler"],-384,[1,0,180,0]],[2,["_lscale"],-385,[1,1,1,1]],[4,2,["_clips","length"],57],[4,null,["_clips","0"],57],[4,null,["_clips","1"],57],[4,null,["_defaultClip"],57],[4,false,["playOnLoad"],57],[4,false,["_useBakedAnimation"],57]]],253]],[0,["35MaNWaVpaXITwGugCw+yp"]],[38,"Background",false,33554432,58,[[53,-388,[11,"f7NISe7HdAD68SLfhnddy8"],[5,1200,1920]],[137,0,-389,[11,"e71ctEmpxFC4KlSYRZNz/a"],0],[89,21,1002,1334,-390]]],[0,["8fJHyWPHhT77T0qzBIqM/Z"]],[0,["08p3MFuydXL4oM9CbjboO3"]],[15,"TitilePanel",33554432,15,[-393],[[5,-391,[5,800,128]],[9,0,-392,83]],[1,0,77.83600000000001,0]],[12,"BtnClose",33554432,6,[[5,-394,[5,128,128]],[9,0,-395,144],[142,-396,[[8,"2b974OfW8lHy6X91zIaDTZD","hide",6],[8,"facc9jj535Fnre+IlyJZiWZ","gotoHome",3]],145]],[1,0,-281.328,0]],[78,"Sphere","40R1fuXgNGEbnuRcOCvlTi",7,[[92,"Sphere<ModelComponent>",-397,[153],[24],154]],[1,0,0,1.189],[1,0.3,0.3,0.3]],[0,["8fJHyWPHhT77T0qzBIqM/Z"]],[68,"CaptureImage",false,33554432,1,[136,137],[[18,-398]]],[105,"Node",false,33554432,1,[[18,-399],[145,-400,[226],[24],227],[147,-401]],[1,-67.86,0,252.195],[3,-0.7071067811865475,0,0,0.7071067811865476],[1,100,100,100],[1,-90,0,0]],[30,0,{},138,[23,"8fJHyWPHhT77T0qzBIqM/Z",-412,[32,"02HUn7mqBPfJm2E49t7Y/m",[[22,[0,["8fJHyWPHhT77T0qzBIqM/Z"]],[[73,-411,[11,"71SN8zFoFC/5gBHzxRLc1H"],230]]],[22,[0,["5fl0cfxJ5Rs5ovU2QsXaQ9"]],[[42]]]],[[2,["_lpos"],25,[1,0,256.581,100]],[4,"VD302_Kangaroo_Rig-001",["_name"],25],[2,["_lrot"],25,[3,0,-1.2246467991473532e-16,0,1]],[2,["_euler"],25,[1,0,-1.4033418597069752e-14,0]],[4,2,["_clips","length"],26],[19,["_clips","0"],26,231],[19,["_defaultClip"],26,232],[4,false,["playOnLoad"],26],[19,["_clips","1"],26,233],[4,false,["_useBakedAnimation"],26],[2,["_lrot"],-402,[3,0,0,0,1]],[2,["_euler"],-403,[1,0,0,0]],[2,["_lrot"],-404,[3,-0.5,-0.5,-0.4999999999999999,0.5000000000000001]],[2,["_euler"],-405,[1,-90,-90,0]],[2,["_lrot"],-406,[3,0,0,-6.698506168543417e-16,1]],[2,["_euler"],-407,[1,0,0,-7.67592264999771e-14]],[4,true,["_enabled"],26],[2,["_lscale"],25,[1,200,200,200]],[4,true,["_active"],25],[4,524288,["_layer"],25],[4,524288,["_layer"],-408],[4,524288,["_layer"],-409],[4,524288,["_layer"],-410],[3,524288,["_layer"],[0,["f4npe4uvhfYIaPYyEku12n"]]],[3,524288,["_layer"],[0,["24QV1ABdRedL8PrNu+86Nq"]]],[3,524288,["_layer"],[0,["124ooP3KBc1Lk0UF5SkG6P"]]],[3,524288,["_layer"],[0,["1aOCmC7G1QLYh3hQ/RIfCW"]]],[3,524288,["_layer"],[0,["abAw8bUFFfbJbDdcCTemu+"]]],[3,524288,["_layer"],[0,["82O4d8FFlZfbWoM1gQ5T0P"]]],[3,524288,["_layer"],[0,["42dhuQU8NX0rXxQG7SW2YE"]]],[3,524288,["_layer"],[0,["dbtmT0gRdSBIMmHDpIZtZm"]]],[3,524288,["_layer"],[0,["54Lh51XGBYv7YuKOF5iKJs"]]],[3,524288,["_layer"],[0,["b98OsIwtddvaimim2Y6TQy"]]],[3,524288,["_layer"],[0,["bfrFfxzL1T1KmmYCwEZLjk"]]],[3,524288,["_layer"],[0,["36Y+vy/Y5QJ7jAvyy3x9XZ"]]],[3,524288,["_layer"],[0,["80Sxap8RleT7LfBkzDAi93"]]],[3,524288,["_layer"],[0,["27lKXEzcFQsZTcP6tappE1"]]],[3,524288,["_layer"],[0,["a0sQDO/bdTOryUmf6KpZ23"]]],[3,524288,["_layer"],[0,["32EOimsNxW6auKvQxSU90n"]]],[3,524288,["_layer"],[0,["2d7+KWFQJVFrgz3wx2r7Yn"]]],[3,524288,["_layer"],[0,["a5xYRu1R9c+4gSl9Nkoyrr"]]],[3,524288,["_layer"],[0,["bbzAt+/A5Za6JtvBJFLV6Q"]]],[3,524288,["_layer"],[0,["8bMDwNbY5Up6fKdikNpIQL"]]],[3,524288,["_layer"],[0,["c2tjMLgltSz7/DvasIQO6O"]]],[3,524288,["_layer"],[0,["6bI877qbhcC6ioHfi85K1R"]]],[3,524288,["_layer"],[0,["ed/f9Db/pZuZRZD4YWAqds"]]],[3,524288,["_layer"],[0,["e9ki9vW3ha/oTYOTJfAkl8"]]],[3,524288,["_layer"],[0,["20BgvTdsleXrtRxNyWlh//"]]],[3,524288,["_layer"],[0,["7cMoqyptdaSbxJ3NJe5s4D"]]],[3,524288,["_layer"],[0,["34N3Tf3Vhf6p2OCEtjbUr5"]]],[3,524288,["_layer"],[0,["d7tLOit5hTsbOMYxHRvFOp"]]],[3,524288,["_layer"],[0,["3dlgK1+6ZS+pIxXuBluE25"]]],[3,524288,["_layer"],[0,["68RNEaQ79QPq60RxDOrbld"]]],[3,524288,["_layer"],[0,["a5O6YJyIlZ0K3DMvMImW/M"]]],[3,524288,["_layer"],[0,["ccJkUI+3RXpZAAZAVToHx+"]]],[3,524288,["_layer"],[0,["beBTxB4F9YIazSRhrqCQYQ"]]],[3,524288,["_layer"],[0,["84hrPyzk1d1ruBlx05r4WZ"]]],[3,524288,["_layer"],[0,["57Le13NptWs5X3lanB4PyH"]]],[3,524288,["_layer"],[0,["94nYA+SUZazqUalPScGfCg"]]],[3,524288,["_layer"],[0,["0ej8X8mtRS8IOXZwhuA0cA"]]],[3,524288,["_layer"],[0,["46OYGFnqVWX54eydGHqJue"]]],[3,524288,["_layer"],[0,["054HrpVJ9YdrFA31Ec+dkY"]]],[3,524288,["_layer"],[0,["dfbHKl6RxVqLvXw6Lt14xK"]]],[3,524288,["_layer"],[0,["bex7q5czhZfLRNzKYoBLyx"]]],[3,524288,["_layer"],[0,["39NhMc+jhSCqKPANQHLh8+"]]],[3,524288,["_layer"],[0,["0516pAzllTEINtCBbXwvaI"]]],[3,524288,["_layer"],[0,["04ZamzRGFcKJpv5KTVe1wf"]]],[3,524288,["_layer"],[0,["40GhtM2Y1bgZOrgy9wQpjf"]]],[3,524288,["_layer"],[0,["efGIrw9kZbM5dp1NBwHMRu"]]],[3,524288,["_layer"],[0,["a3opXY1K1bs63KtREsU6Cj"]]],[3,524288,["_layer"],[0,["cdSHSn+iNTHKbOD/PLegz3"]]],[3,524288,["_layer"],[0,["47JEn10QFZeY7XBihtHdxT"]]],[3,524288,["_layer"],[0,["53/rmZzdJZL463F9C5r7qA"]]],[3,524288,["_layer"],[0,["9fgNNDboxcjIG+O1o8GHRt"]]],[3,524288,["_layer"],[0,["a6aeXwf6BZdI+Q2cVg8FCt"]]],[3,524288,["_layer"],[0,["82YHmJYpNUwIRpMz6/x7rh"]]],[3,524288,["_layer"],[0,["56GP/33ipbt5RscKxkRlan"]]],[3,524288,["_layer"],[0,["84l6lm3SBYBZ8FSo3q+7NM"]]],[3,524288,["_layer"],[0,["e57STHoJpa0p56K4UDKx2N"]]],[3,524288,["_layer"],[0,["6cklssd71bQpgcGHdZO8+Q"]]]]],229]],[0,["00epe3MM5V+6cyzbwFVcci"]],[30,0,{},140,[23,"35MaNWaVpaXITwGugCw+yp",-414,[32,"51ZVybBA9Dt6xK+AlpUF2i",[[22,[0,["35MaNWaVpaXITwGugCw+yp"]],[[41,-413]]],[22,[0,["66SXxyl+ZSLIlCH9Xjfuro"]],[[42],[54]]]],[[2,["_lpos"],27,[1,0,500,100]],[4,"VD289_Lion_Rig-001",["_name"],27],[2,["_lrot"],27,[3,0,0,0,1]],[2,["_euler"],27,[1,0,0,0]],[4,3,["_clips","length"],53],[4,null,["_clips","0"],53],[4,null,["_clips","1"],53],[19,["_clips","2"],53,238],[4,null,["_defaultClip"],53],[4,true,["playOnLoad"],53],[4,true,["_active"],27],[2,["_lscale"],27,[1,200,200,200]],[4,524288,["_layer"],27],[3,524288,["_layer"],[0,["66SXxyl+ZSLIlCH9Xjfuro"]]],[3,524288,["_layer"],[0,["20FZ6FqZZT946EF29Au3vS"]]],[3,524288,["_layer"],[0,["35i6tXF4pRNZMhldb3mDjL"]]],[3,524288,["_layer"],[0,["05UVohVuNVcY7xAefdYL4R"]]],[3,524288,["_layer"],[0,["99aYTJuXxXjKlBCnMZKwSb"]]],[3,524288,["_layer"],[0,["04ogjBxslRvqZNn/28a2mW"]]],[3,524288,["_layer"],[0,["b0yaVeE+lf24sDuhbAjfnr"]]],[3,524288,["_layer"],[0,["e7TXJyk2pTmZxxh/3c0m7+"]]],[3,524288,["_layer"],[0,["4dRXphVyNfYYs4uOckZrgr"]]],[3,524288,["_layer"],[0,["62SLmOvJVd65B7L2G1Y1bi"]]],[3,524288,["_layer"],[0,["c5EksbV85eBLHQJ5DOQ0Il"]]],[3,524288,["_layer"],[0,["bcLaJ+TvdQl78qlF+twDsy"]]],[3,524288,["_layer"],[0,["acBVRsOHRXTZXhAUP5FR5A"]]],[3,524288,["_layer"],[0,["90JC9J3EBcF59u1d/TDnac"]]],[3,524288,["_layer"],[0,["9166HB4c9fCpJ+ndmbNclR"]]],[3,524288,["_layer"],[0,["e4/QZ1rH1f3K65N7Vtf7PY"]]],[3,524288,["_layer"],[0,["daokDkTqNZyptqI6QBb1I/"]]],[3,524288,["_layer"],[0,["24wLW8b+9UI6wK3JzbMbUF"]]],[3,524288,["_layer"],[0,["8aDq0WbNRYM4NJvJ2o74Lv"]]],[3,524288,["_layer"],[0,["42aDpB00ZY24pjtaMIy0pw"]]],[3,524288,["_layer"],[0,["9edFaLq9JUMqw4ukRK7eJe"]]],[3,524288,["_layer"],[0,["21BAg+uiNcLJ1pMuhtF2u5"]]],[3,524288,["_layer"],[0,["48il1/WABdRr0dL7mUyTUY"]]],[3,524288,["_layer"],[0,["46yLe9/LNSU4wsF36Y4EdF"]]],[3,524288,["_layer"],[0,["c67HP74fZQareDO7QzeXWD"]]],[3,524288,["_layer"],[0,["9bdMh8SI5VApTWliW7zitf"]]],[3,524288,["_layer"],[0,["11uo16DZlTM61GJXA7u+dI"]]],[3,524288,["_layer"],[0,["16nrjCCw1awrIbbFmrrLkt"]]],[3,524288,["_layer"],[0,["0c+/2xnDxak6fzczZpa12t"]]],[3,524288,["_layer"],[0,["426MOEsD5fQ52qyRgpaw43"]]],[3,524288,["_layer"],[0,["aaIJFC4GRcjrd2uk0jbYIV"]]],[3,524288,["_layer"],[0,["8b3EQn0vVbXY+9L26wjUHK"]]],[3,524288,["_layer"],[0,["78gcp2bbxVXLlxVrakCFv+"]]],[3,524288,["_layer"],[0,["b5e5H9odFf6al2+RZikwCR"]]],[3,524288,["_layer"],[0,["4fY6GcR1hSC5fYnbBbwcE3"]]],[3,524288,["_layer"],[0,["da5hRlZv9Yer2n/hky54Qh"]]],[3,524288,["_layer"],[0,["f1rzkOtcJUoouALNH9EqMW"]]],[3,524288,["_layer"],[0,["74Wy3E+Ole54e8k1nw+aEG"]]],[3,524288,["_layer"],[0,["a8dpwKFOlaFJYRtwefRwED"]]],[3,524288,["_layer"],[0,["07NdQ2IsRR84s8cj1lRGj3"]]],[3,524288,["_layer"],[0,["6ax1un7LxbuodvxEmJ7fy/"]]],[3,524288,["_layer"],[0,["bfPdLlgZtTPLDNzkErLei1"]]],[3,524288,["_layer"],[0,["75WizrvY9f4bbuYTiAsdi4"]]],[3,524288,["_layer"],[0,["55LTavoExT56Qt1yhbvz/X"]]],[3,524288,["_layer"],[0,["09TAs1TbJfg5Fft1EAp/iz"]]],[3,524288,["_layer"],[0,["9fCz99XCRUdpOH1TnEDrkD"]]],[3,524288,["_layer"],[0,["7dpmNx611fh4xXzZzkGAmI"]]],[3,524288,["_layer"],[0,["07XOU8MOJdXYdeZTz15z4c"]]],[3,524288,["_layer"],[0,["25rnbqlTNR1pQdN14WG5HL"]]],[3,524288,["_layer"],[0,["30nvpNQ2tWc6LIPcuur2vi"]]],[3,524288,["_layer"],[0,["40GD3ZPKlVUKfO5lep3+oO"]]],[3,524288,["_layer"],[0,["5cJRpZcMxdlIdscpoxZ25t"]]],[3,524288,["_layer"],[0,["3evKiZvo5TaLUHoURAeo/X"]]],[3,524288,["_layer"],[0,["b8A7ZBYvlbYJe+OTRAWqzr"]]],[3,524288,["_layer"],[0,["feQFOqHlxSwbMcaPmuycQQ"]]],[3,524288,["_layer"],[0,["c1cWylJQtd6rol0y6sh+h7"]]],[3,524288,["_layer"],[0,["b4NkXDiC1Ugpi6y1EryYfH"]]],[3,524288,["_layer"],[0,["008tQUqzhbV6wCEbIfA14v"]]]]],237]],[148,6,1083179008],[16,"Label",33554432,17,[[53,-415,[11,"c68UOAlNhN171Umca6yVvF"],[5,441.7,50.4]],[150,"ACCESS CAMERA",50,50,true,-416,[11,"2frm37uaJHQr0AEEaYyM82"],[4,4278767337]]]],[12,"NameTag",33554432,31,[[5,-417,[5,448.14599999999996,150]],[9,0,-418,1]],[1,113.927,0,0]],[12,"Label",33554432,31,[[5,-419,[5,160,100.8]],[151,"袋鼠",80,80,80,-420,[4,4279637536]]],[1,113.92700000000002,0,0]],[12,"Panel",33554432,9,[[5,-421,[5,800,200]],[9,0,-422,7]],[1,-9.796,0,0]],[16,"Sprite",33554432,32,[[5,-423,[5,128,128]],[9,0,-424,8]]],[16,"Sprite",33554432,33,[[5,-425,[5,128,128]],[9,0,-426,14]]],[16,"Sprite",33554432,34,[[5,-427,[5,128,128]],[9,0,-428,25]]],[16,"Sprite",33554432,35,[[5,-429,[5,128,128]],[9,0,-430,31]]],[12,"BG",33554432,36,[[5,-431,[5,1118.683,2048]],[9,0,-432,47]],[1,34.376499999999965,-825.695,0]],[12,"NameTag",33554432,36,[[5,-433,[5,448.14599999999996,150]],[9,0,-434,48]],[1,113.927,0,0]],[12,"Label",33554432,36,[[5,-435,[5,260.21,100.8]],[152,"Kangaroo",60,60,80,false,-436,[4,4279637536]]],[1,113.92700000000002,0,0]],[30,0,{},4,[23,"8fJHyWPHhT77T0qzBIqM/Z",-437,[32,"5aKqa9J/BDHpyCnGodu/O/",[[22,[0,["5fl0cfxJ5Rs5ovU2QsXaQ9"]],[[42],[54]]]],[[4,"VD302_Kangaroo_Rig-001",["_name"],145],[2,["_lpos"],145,[1,-0.17,369.802,223.307]],[2,["_lrot"],145,[3,0,0,0,1]],[2,["_euler"],145,[1,0,0,0]],[4,1,["_clips","length"],146],[19,["_clips","0"],146,55],[19,["_defaultClip"],146,56],[4,true,["playOnLoad"],146],[4,"VD302_Kangaroo_Toy",["_name"],64],[2,["_lpos"],64,[1,-5.960464477539063e-8,0,0]],[2,["_lrot"],64,[3,-0.7071067811865476,0,0,0.7071067811865476]],[2,["_lscale"],64,[1,1,1,1]],[2,["_euler"],64,[1,-90.00000000000003,0,0]],[4,"Bip001",["_name"],65],[2,["_lpos"],65,[1,-3.732301578907027e-9,1.5775775909423828,0.4474337100982666]],[2,["_lrot"],65,[3,-0.5000003576277408,-0.49999964237200345,-0.49999964237200345,0.5000003576277408]],[2,["_lscale"],65,[1,1,1,1]],[2,["_euler"],65,[1,-90,-89.99991803772996,0]],[4,"Bn_FoodSpawn",["_name"],66],[2,["_lpos"],66,[1,-5.4358654466568623e-8,0.009165484458208084,0.8870136737823486]],[2,["_lrot"],66,[3,1.545431187269876e-8,-0.707106721581899,1.5454308319985022e-8,0.7071068407911907]],[2,["_lscale"],66,[1,1,1,1]],[2,["_euler"],66,[1,0.0000025044781562438738,-89.99999034065368,-7.67592264999771e-14]],[4,"Bip001 Pelvis",["_name"],67],[2,["_lpos"],67,[1,0,0,0]],[2,["_lrot"],67,[3,-0.678948057080087,-0.19755655885105733,-0.1975572294033232,0.6789492491730041]],[2,["_lscale"],67,[1,1,1,1]],[2,["_euler"],67,[1,-89.99992243324212,-32.44732100165269,-0.00007915718266001345]],[4,"Bip001 Spine",["_name"],68],[2,["_lpos"],68,[1,0.3542376756668091,0.3531496524810791,-0.0000013134826986060943]],[2,["_lrot"],68,[3,-0.0000018851790819067795,-0.0000011795759439423908,0.06960712936962687,0.9975744821996876]],[2,["_lscale"],68,[1,1,1,1]],[2,["_euler"],68,[1,-0.00020810952367528602,-0.00012097697166633093,7.982844695585415]],[4,"Bip001 Spine1",["_name"],69],[2,["_lpos"],69,[1,0.4582993984222412,-0.00035309791564941406,-9.790710464585572e-10]],[2,["_lrot"],69,[3,2.446313346659477e-13,-1.8054307341607132e-7,0.06509341476946535,0.9978791747268894]],[2,["_lscale"],69,[1,1,1,1]],[2,["_euler"],69,[1,0.0000013582370161722287,-0.000020821282842442467,7.46443354701361]],[4,"Bip001 L Thigh",["_name"],70],[2,["_lpos"],70,[1,-0.39984893798828125,-0.30053311586380005,0.3836286962032318]],[2,["_lrot"],70,[3,0.7178273552306246,0.680038369359236,0.1348885996845741,0.06384958854192135]],[2,["_lscale"],70,[1,1,1,1]],[2,["_euler"],70,[1,-126.10226971349779,-70.08105235291427,83.47655542639572]],[4,"Bip001 R Thigh",["_name"],71],[2,["_lpos"],71,[1,-0.399849534034729,-0.3005313277244568,-0.3836267292499542]],[2,["_lrot"],71,[3,0.7178270792704299,0.6800386286793662,-0.134887694859659,-0.06385184057972494]],[2,["_lscale"],71,[1,1,1,1]],[2,["_euler"],71,[1,126.10304314074824,70.08038736689647,83.47680202680553]],[4,"Bip001 Xtra_Tail",["_name"],72],[2,["_lpos"],72,[1,-0.9858397245407104,-0.43601518869400024,0.000001985863264053478]],[2,["_lrot"],72,[3,9.877768196883434e-7,-0.0000026041092780163377,0.9789544108644718,-0.20407905684130798]],[2,["_lscale"],72,[1,1,1,1]],[2,["_euler"],72,[1,179.999706525755,-179.99994555523935,-23.551186460093533]],[4,"Bip001 Neck",["_name"],73],[2,["_lpos"],73,[1,0.5762070417404175,-0.12533974647521973,9.96238668449223e-7]],[2,["_lrot"],73,[3,1.2697269418175673e-13,8.642778814821149e-7,-0.31160864818281975,0.9502105295022409]],[2,["_lscale"],73,[1,1,1,1]],[2,["_euler"],73,[1,0.000038299085695490824,0.00011678809352825268,-36.312403738338894]],[4,"Bip001 L Calf",["_name"],74],[2,["_lpos"],74,[1,0.743604302406311,-1.1920928955078125e-7,-2.7755575615628914e-17]],[2,["_lrot"],74,[3,0,0,-0.41653967720321833,0.909117537678951]],[2,["_lscale"],74,[1,1,1,1]],[2,["_euler"],74,[1,0,0,-49.23262954822765]],[4,"Bip001 R Calf",["_name"],75],[2,["_lpos"],75,[1,0.7436041831970215,0,5.551115123125783e-17]],[2,["_lrot"],75,[3,-5.0466161121084984e-17,2.312259701504717e-17,-0.41653967720321833,0.909117537678951]],[2,["_lscale"],75,[1,1,1,1]],[2,["_euler"],75,[1,-6.361109362927037e-15,0,-49.23262954822765]],[4,"Bip001 Xtra_Tail1",["_name"],76],[2,["_lpos"],76,[1,0.7776881456375122,-0.0007715225219726562,-2.1395862859208137e-9]],[2,["_lrot"],76,[3,1.7354177343170095e-13,2.4402726421175402e-8,-0.008798220935442457,0.9999612949051431]],[2,["_lscale"],76,[1,1,1,1]],[2,["_euler"],76,[1,2.4626572286066044e-8,0.000002796671380546391,-1.0082148613665045]],[4,"Bip001 Head",["_name"],77],[2,["_lpos"],77,[1,0.271028995513916,0.1483471393585205,-1.397716005158145e-7]],[2,["_lrot"],77,[3,-4.7459346984729076e-7,0.0000010302596964508388,-0.31471839988255196,0.9491850866791363]],[2,["_lscale"],77,[1,1,1,1]],[2,["_euler"],77,[1,-0.000018038935986709043,0.0001183982779817365,-36.6876293880894]],[4,"Bip001 L Clavicle",["_name"],78],[2,["_lpos"],78,[1,-0.290891170501709,0.11437880992889404,0.056595951318740845]],[2,["_lrot"],78,[3,0.7404151484820694,0.19713777106521088,0.5926956475105046,-0.24826191117410562]],[2,["_lscale"],78,[1,1,1,1]],[2,["_euler"],78,[1,-143.0354460567296,-77.30871903103836,-0.13521382911142363]],[4,"Bip001 R Clavicle",["_name"],79],[2,["_lpos"],79,[1,-0.2908914089202881,0.1143791675567627,-0.056598000228405]],[2,["_lrot"],79,[3,0.7404158188458404,0.19713941411025176,-0.5926951228460576,0.24825985974701364]],[2,["_lscale"],79,[1,1,1,1]],[2,["_euler"],79,[1,143.03551574473522,77.30872223520217,-0.1349050251337831]],[4,"Bip001 L Foot",["_name"],80],[2,["_lpos"],80,[1,0.8391543626785278,2.9802322387695312e-8,0]],[2,["_lrot"],80,[3,0.09368384456679991,0.04668617534947475,0.18506039337690455,0.9771368323329169]],[2,["_lscale"],80,[1,1,1,1]],[2,["_euler"],80,[1,10.282468224363756,3.491167402013983,21.740666790231035]],[4,"Bip001 R Foot",["_name"],81],[2,["_lpos"],81,[1,0.8391544222831726,-5.551115123125783e-17,1.4901161193847656e-8]],[2,["_lrot"],81,[3,-0.0936838530691832,-0.04668609764253182,0.1850603507511224,0.9771368433033805]],[2,["_lscale"],81,[1,1,1,1]],[2,["_euler"],81,[1,-10.282471032387543,-3.4911582401498076,21.740661053193115]],[4,"Bip001 Xtra_Tail2",["_name"],82],[2,["_lpos"],82,[1,0.9689803123474121,-0.0008437633514404297,-2.9117472877260298e-9]],[2,["_lrot"],82,[3,3.4403779720176436e-7,5.077550272064185e-7,-0.010108478258240874,0.9999489080282684]],[2,["_lscale"],82,[1,1,1,1]],[2,["_euler"],82,[1,0.00004001814766795572,0.00005859195632515687,-1.1583660107752876]],[4,"Bip001 Xtra_Eyelid_up_L",["_name"],83],[2,["_lpos"],83,[1,0.3271970748901367,0.4205749034881592,-0.18183529376983643]],[2,["_lrot"],83,[3,-0.24522146530069025,-0.4163162103317173,0.8753637652717497,0.016897467860142394]],[2,["_lscale"],83,[1,1,1,1]],[2,["_euler"],83,[1,132.17461490430898,154.7176502037449,13.518670197215748]],[4,"Bip001 Xtra_Eyelid_up_R",["_name"],84],[2,["_lpos"],84,[1,0.3271970748901367,0.4205739498138428,0.18183764815330505]],[2,["_lrot"],84,[3,0.24522088155166882,0.4163115567490713,0.8753661401629665,0.016897562675627805]],[2,["_lscale"],84,[1,1,1,1]],[2,["_euler"],84,[1,-132.17519821674765,-154.71765267277706,13.518521573560058]],[4,"Bip001 Xtra_Eyelid_Low_L",["_name"],85],[2,["_lpos"],85,[1,0.21905755996704102,0.41451358795166016,-0.20157299935817719]],[2,["_lrot"],85,[3,0.4409942824246951,-0.040964274662843414,0.025457053795126677,0.8962130937908391]],[2,["_lscale"],85,[1,1,1,1]],[2,["_euler"],85,[1,52.42644045172507,-5.502120724866701,0.5443105331507334]],[4,"Bip001 Xtra_Eyelid_Low_R",["_name"],86],[2,["_lpos"],86,[1,0.21905755996704102,0.41451263427734375,0.20157529413700104]],[2,["_lrot"],86,[3,-0.4409942824517709,0.040964133104330384,0.025457279176747588,0.896213093845864]],[2,["_lscale"],86,[1,1,1,1]],[2,["_euler"],86,[1,-52.426441892868866,5.502117589864751,0.5443408344453377]],[4,"Bip001 Xtra_Eye_R",["_name"],87],[2,["_lpos"],87,[1,0.2641632556915283,0.35110998153686523,-0.14128649234771729]],[2,["_lrot"],87,[3,-0.27964436716809643,0.1581443084705726,0.682003014140958,0.6570093563353323]],[2,["_lscale"],87,[1,1,1,1]],[2,["_euler"],87,[1,-98.45224704751105,88.08277038553146,53.873413080213766]],[4,"Bip001 Xtra_Eye_L",["_name"],88],[2,["_lpos"],88,[1,0.2641632556915283,0.35110926628112793,0.1412884145975113]],[2,["_lrot"],88,[3,0.27964439645134875,-0.15814812287424745,0.6820021188053784,0.657009355115806]],[2,["_lscale"],88,[1,1,1,1]],[2,["_euler"],88,[1,98.4519445966391,-88.08278231192374,53.87309036235816]],[4,"Bip001 Xtra_Mouth_Cor_R",["_name"],89],[2,["_lpos"],89,[1,-0.03132891654968262,0.5618903636932373,-0.11657057702541351]],[2,["_lrot"],89,[3,0.04929766191040832,-0.0604126283325885,0.7993534421572859,0.5957802693774057]],[2,["_lscale"],89,[1,1,1,1]],[2,["_euler"],89,[1,151.22228257200177,-152.1352089628443,71.17731919294856]],[4,"Bip001 Xtra_Mouth_Cor_L",["_name"],90],[2,["_lpos"],90,[1,-0.03132891654968262,0.5618896484375,0.11657369136810303]],[2,["_lrot"],90,[3,-0.04929762034087917,0.06040812745717985,0.7993537901967565,0.595780262230903]],[2,["_lscale"],90,[1,1,1,1]],[2,["_euler"],90,[1,-151.22349829367852,152.13605821250368,71.17747050798812]],[4,"Bip001 Xtra_Mouth_Up_R",["_name"],91],[2,["_lpos"],91,[1,-0.04088473320007324,0.6360740661621094,-0.06928008049726486]],[2,["_lrot"],91,[3,-0.0038198481848174207,0.0019246733316340729,0.7995733037055219,0.6005532752336371]],[2,["_lscale"],91,[1,1,1,1]],[2,["_euler"],91,[1,-178.42422555767092,178.26911750409243,73.81321923996768]],[4,"Bip001 Xtra_Mouth_Up_L",["_name"],92],[2,["_lpos"],92,[1,-0.04088473320007324,0.6360738277435303,0.0692836120724678]],[2,["_lrot"],92,[3,0.003819830457478615,-0.0019290845247500956,0.7995732969633009,0.6005532701696075]],[2,["_lscale"],92,[1,1,1,1]],[2,["_euler"],92,[1,178.42278052602967,-178.26803494978196,73.813208998766]],[4,"Bip001 Xtra_Teath_Up",["_name"],93],[2,["_lpos"],93,[1,0.002314329147338867,0.554196834564209,0.000004309463747631526]],[2,["_lrot"],93,[3,9.336697845026691e-7,1.9915808695504157e-7,0.8147948658617054,0.5797493652989147]],[2,["_lscale"],93,[1,1,1,1]],[2,["_euler"],93,[1,179.9998674950161,-179.99977440903933,70.86583252141891]],[4,"Bip001 Xtra_Jaw",["_name"],94],[2,["_lpos"],94,[1,-0.020290136337280273,0.3777594566345215,-9.088580554816872e-9]],[2,["_lrot"],94,[3,-9.235465789091367e-8,-0.0000020748226942927456,0.7911309946054532,0.611646752112911]],[2,["_lscale"],94,[1,1,1,1]],[2,["_euler"],94,[1,179.9992786301882,-179.9994556648126,75.41733868808973]],[4,"Bip001 Xtra_EarL",["_name"],95],[2,["_lpos"],95,[1,0.6298751831054688,-0.04161977767944336,0.21326301991939545]],[2,["_lrot"],95,[3,0.17229719240550637,-0.3286434668165523,0.041136212122997444,0.9276933551880974]],[2,["_lscale"],95,[1,1,1,1]],[2,["_euler"],95,[1,20.3010491465256,-38.635362133307176,-2.1161341392427624]],[4,"Bip001 Xtra_EarR",["_name"],96],[2,["_lpos"],96,[1,0.6298751831054688,-0.04161834716796875,-0.21326324343681335]],[2,["_lrot"],96,[3,-0.17229802753627552,0.32864299124926405,0.04113777690385765,0.9276932991680245]],[2,["_lscale"],96,[1,1,1,1]],[2,["_euler"],96,[1,-20.30120120360858,38.635335030936766,-2.1159900209997105]],[4,"Bip001 Xtra_eyebrownR",["_name"],97],[2,["_lpos"],97,[1,0.3929600715637207,0.4532432556152344,-0.1358882188796997]],[2,["_lrot"],97,[3,-0.23773379651555063,0.542546868955643,-0.31570294536135707,0.7412537941021924]],[2,["_lscale"],97,[1,1,1,1]],[2,["_euler"],97,[1,-0.8227543143827625,72.04920289475375,-46.5517219786071]],[4,"Bip001 Xtra_eyebrownL",["_name"],98],[2,["_lpos"],98,[1,0.3929600715637207,0.45324230194091797,0.13589075207710266]],[2,["_lrot"],98,[3,0.23773374855793258,-0.542545073389861,-0.3157059510744924,0.7412538435604459]],[2,["_lscale"],98,[1,1,1,1]],[2,["_euler"],98,[1,0.8225775813222904,-72.04909199221025,-46.55202036838682]],[4,"Bip001 Xtra11_Nose",["_name"],99],[2,["_lpos"],99,[1,0.15001845359802246,0.7634279727935791,0.0000010193798516411334]],[2,["_lrot"],99,[3,1.9258151975219854e-12,-0.0000027674523216948566,0.9977835439810513,0.06654321417661394]],[2,["_lscale"],99,[1,1,1,1]],[2,["_euler"],99,[1,179.99968074891942,-179.99997870859482,7.630929361688651]],[4,"Bn_Mouth",["_name"],100],[2,["_lpos"],100,[1,-0.07195711135864258,0.5386135578155518,0.008439688943326473]],[2,["_lrot"],100,[3,-0.46549811987707945,-0.5231723192550453,-0.44354066279808146,0.559351325376851]],[2,["_lscale"],100,[1,1,1,1]],[2,["_euler"],100,[1,-80.02761183493475,-86.61028004033459,-0.5224675849989031]],[4,"Bip001 L UpperArm",["_name"],101],[2,["_lpos"],101,[1,0.2798118591308594,1.1920928955078125e-7,2.384185791015625e-7]],[2,["_lrot"],101,[3,-0.24198095521163535,0.5819774871081226,-0.35439729720859986,0.6907604342646003]],[2,["_lscale"],101,[1,1,1,1]],[2,["_euler"],101,[1,7.057027719358092,83.55855063844022,-50.46736884718895]],[4,"Bip001 R UpperArm",["_name"],102],[2,["_lpos"],102,[1,0.2798118591308594,4.440892098500626e-16,0]],[2,["_lrot"],102,[3,0.24198129715613026,-0.5819780812733067,-0.35439678942351904,0.6907600744038257]],[2,["_lscale"],102,[1,1,1,1]],[2,["_euler"],102,[1,-7.056981598696757,-83.5586140647127,-50.46734445139137]],[4,"Bip001 L Toe0",["_name"],103],[2,["_lpos"],103,[1,0.0993526503443718,0.3203730583190918,0.015012085437774658]],[2,["_lrot"],103,[3,-0.012606775107827504,-0.004188367072502582,0.7176545698822673,0.6962725365327463]],[2,["_lscale"],103,[1,1,1,1]],[2,["_euler"],103,[1,-159.190288938885,157.82919259324692,88.13791814938088]],[4,"Bip001 R Toe0",["_name"],104],[2,["_lpos"],104,[1,0.09935265779495239,0.320372998714447,-0.01501205563545227]],[2,["_lrot"],104,[3,0.012606777493592694,0.004188363055347829,0.7176545996614502,0.6962725058200326]],[2,["_lscale"],104,[1,1,1,1]],[2,["_euler"],104,[1,159.19032927263092,-157.8292330582914,88.13791339787937]],[4,"Bip001 Xtra_Teath_Low",["_name"],105],[2,["_lpos"],105,[1,0.13749122619628906,-0.031085491180419922,0.0000035714842852030415]],[2,["_lrot"],105,[3,0.000004232222292237529,-0.0000038132740061028115,0.03182718986028513,0.9994933866480282]],[2,["_lscale"],105,[1,1.0000009536743164,1,1]],[2,["_euler"],105,[1,0.0004996510135593257,-0.000453101048055823,3.647743322877986]],[4,"Bip001 Xtra_Tongue",["_name"],106],[2,["_lpos"],106,[1,0.08936405181884766,-0.028061389923095703,0.000004445225840754574]],[2,["_lrot"],106,[3,-3.0594311178264103e-7,3.817032550457581e-7,-0.048731250106838264,0.9988119268725146]],[2,["_lscale"],106,[1,1,0.9999989867210388,1]],[2,["_euler"],106,[1,-0.00003304227590328229,0.000042179892466667365,-5.586402449871046]],[4,"Bip001 L Forearm",["_name"],107],[2,["_lpos"],107,[1,0.5204557180404663,1.1920928955078125e-7,-1.1920928955078125e-7]],[2,["_lrot"],107,[3,-8.996704747186443e-18,-2.969889326223742e-17,-0.6873185419958124,0.7263561260351223]],[2,["_lscale"],107,[1,1,1,1]],[2,["_euler"],107,[1,-5.595479079571909e-14,-5.763289687687109e-14,-86.83644251224672]],[4,"Bip001 R Forearm",["_name"],108],[2,["_lpos"],108,[1,0.5204557180404663,1.1920928955078125e-7,0]],[2,["_lrot"],108,[3,4.9317570815256714e-17,-8.45495145977068e-18,-0.6873185717527179,0.7263560978774832]],[2,["_lscale"],108,[1,1,1,1]],[2,["_euler"],108,[1,6.231598940146356e-14,5.763298592223944e-14,-86.83644720676268]],[4,"Bip001 L Hand",["_name"],109],[2,["_lpos"],109,[1,0.5944492220878601,0,-2.220446049250313e-16]],[2,["_lrot"],109,[3,-0.2617311703737297,0.029688528854133044,0.3459904396792379,0.9005031934201249]],[2,["_lscale"],109,[1,1,1,1]],[2,["_euler"],109,[1,-38.26907185297872,17.178544816200937,37.415459422889654]],[4,"Bip001 R Hand",["_name"],110],[2,["_lpos"],110,[1,0.5944493412971497,-1.1920928955078125e-7,0]],[2,["_lrot"],110,[3,0.2617312122116491,-0.029688526494057035,0.345990455589461,0.9005031752247349]],[2,["_lscale"],110,[1,1,1,1]],[2,["_euler"],110,[1,38.26907848292041,-17.178547481263575,37.41546049159831]],[4,"Bip001 L Finger0",["_name"],111],[2,["_lpos"],111,[1,0.08157700300216675,0.006247282028198242,-0.12238441407680511]],[2,["_lrot"],111,[3,0.9290023395148231,0.3079701645178377,-0.06974732092525232,0.19298793269681716]],[2,["_lscale"],111,[1,1,1.0000009536743164,1]],[2,["_euler"],111,[1,151.3789632812749,17.241735558793838,33.044430410905846]],[4,"Bip001 L Finger1",["_name"],112],[2,["_lpos"],112,[1,0.2140156626701355,0.02871990203857422,-0.07965849339962006]],[2,["_lrot"],112,[3,0.14175589132700384,0.05487470977109217,0.29237341365277086,0.9441460800589339]],[2,["_lscale"],112,[1,1,1,1]],[2,["_euler"],112,[1,16.628244260928607,1.4427303831348735,34.58610116822202]],[4,"Bip001 L Finger2",["_name"],113],[2,["_lpos"],113,[1,0.20017272233963013,0.027018070220947266,0.010468840599060059]],[2,["_lrot"],113,[3,0.016227573424614575,-0.07892323415809137,0.25775862166212676,0.9628438512706079]],[2,["_lscale"],113,[1,1.0000009536743164,1,1]],[2,["_euler"],113,[1,4.745212621468258,-10.625984962258268,29.590727366189885]],[4,"Bn_Hand",["_name"],114],[2,["_lpos"],114,[1,0.16577750444412231,0.06132864952087402,-0.046974703669548035]],[2,["_lrot"],114,[3,-0.3996487816964595,0.9162200003981678,-0.011799826171741228,-0.02612520356348691]],[2,["_lscale"],114,[1,1,1,1]],[2,["_euler"],114,[1,3.5752087539781954,-175.1773245504443,-47.03043486089243]],[4,"Bip001 R Finger0",["_name"],115],[2,["_lpos"],115,[1,0.0954056978225708,0.005409955978393555,0.10597886145114899]],[2,["_lrot"],115,[3,0.9290023316959993,0.30797019172817003,0.06974726818416987,-0.19298794597372107]],[2,["_lscale"],115,[1,1,1,1]],[2,["_euler"],115,[1,-151.37896227054966,-17.241730691025925,33.044434802218554]],[4,"Bip001 R Finger1",["_name"],116],[2,["_lpos"],116,[1,0.2140156626701355,0.02871990203857422,0.07965849339962006]],[2,["_lrot"],116,[3,-0.14175589118211213,-0.0548747283414547,0.2923734133539298,0.9441460790939021]],[2,["_lscale"],116,[1,1,1,1]],[2,["_euler"],116,[1,-16.628243493903444,-1.4427328337497123,34.58610145498249]],[4,"Bip001 R Finger2",["_name"],117],[2,["_lpos"],117,[1,0.20017272233963013,0.027018070220947266,-0.010468810796737671]],[2,["_lrot"],117,[3,-0.016227580863691093,0.07892324155272112,0.2577586214793942,0.9628438505880201]],[2,["_lscale"],117,[1,1.0000009536743164,1,1]],[2,["_euler"],117,[1,-4.745213810691006,10.625986151481015,29.59072722663627]],[4,"Bip001 L Finger01",["_name"],118],[2,["_lpos"],118,[1,0.1283271312713623,-2.220446049250313e-16,-5.960464477539063e-8]],[2,["_lrot"],118,[3,-0.0005510463967082443,0.04632963244924116,0.01187961922320866,0.9988554130363908]],[2,["_lscale"],118,[1,1,1,1]],[2,["_euler"],118,[1,-0.1261771947815869,5.312755955821363,1.356947306578145]],[4,"Bip001 L Finger11",["_name"],119],[2,["_lpos"],119,[1,0.0953603982925415,-2.384185791015625e-7,5.960464477539063e-8]],[2,["_lrot"],119,[3,1.0302478230703421e-8,-1.3092540701434747e-8,0.2016598630980403,0.9794556139076848]],[2,["_lscale"],119,[1,1,1,1]],[2,["_euler"],119,[1,0.0000015880320747349408,-0.0000018587233107113073,23.268080227659283]],[4,"Bip001 L Finger21",["_name"],120],[2,["_lpos"],120,[1,0.07172501087188721,1.1920928955078125e-7,5.960464477539063e-8]],[2,["_lrot"],120,[3,-1.0171859984491851e-17,-1.4991040769140968e-17,0.13798254917676323,0.9904346601985827]],[2,["_lscale"],120,[1,1,1,1]],[2,["_euler"],120,[1,-9.53743987823341e-16,-1.601566231679269e-15,15.862243670868283]],[4,"Bip001 R Finger01",["_name"],121],[2,["_lpos"],121,[1,0.11112487316131592,2.220446049250313e-16,-1.1920928955078125e-7]],[2,["_lrot"],121,[3,0.0005510246851597509,-0.046329632441594146,0.011879634122409057,0.9988554128715231]],[2,["_lscale"],121,[1,1,1,1]],[2,["_euler"],121,[1,0.12617478816212,-5.3127559293270386,1.356949127499545]],[4,"Bip001 R Finger11",["_name"],122],[2,["_lpos"],122,[1,0.09536051750183105,1.1920928955078125e-7,5.960464477539063e-8]],[2,["_lrot"],122,[3,-1.0302478230703421e-8,1.3092540701434747e-8,0.2016598630980403,0.9794556139076848]],[2,["_lscale"],122,[1,1,1,1]],[2,["_euler"],122,[1,-0.0000015880320747349408,0.0000018587233107113073,23.268080227659283]],[4,"Bip001 R Finger21",["_name"],123],[2,["_lpos"],123,[1,0.07172489166259766,0,0]],[2,["_lrot"],123,[3,4.893729611197911e-18,-3.696921671140056e-18,0.13798254917676323,0.9904346601985827]],[2,["_lscale"],123,[1,1,1,1]],[2,["_euler"],123,[1,6.381709387020008e-16,-5.16634253009268e-16,15.862243670868283]]]],54]],[16,"BG",33554432,10,[[5,-438,[5,1080,1920]],[33,-439,57]]],[12,"Label",33554432,10,[[5,-440,[5,1280,400]],[153,"是否注册健达会员,\n解锁会员福利？",80,80,120,1,-441]],[1,0,640.62,0]],[12,"test",33554432,10,[[5,-442,[5,720,720]],[9,0,-443,68]],[1,0,-497.893,0]],[45,"Sprite",33554432,37,[[5,-444,[5,128,128]],[9,0,-445,74]],[3,0,0,-1,6.123233995736766e-17],[1,0,0,-180]],[45,"Sprite",33554432,38,[[5,-446,[5,128,128]],[9,0,-447,76]],[3,-1,6.123233995736766e-17,-6.123233995736766e-17,3.749399456654644e-33],[1,0,180,-180]],[45,"Sprite",33554432,39,[[5,-448,[5,128,128]],[9,0,-449,78]],[3,0,0,-1,6.123233995736766e-17],[1,0,0,-180]],[45,"Sprite",33554432,40,[[5,-450,[5,128,128]],[9,0,-451,80]],[3,0,0,-1,6.123233995736766e-17],[1,0,0,-180]],[12,"Board",33554432,15,[[5,-452,[5,1000,800]],[9,0,-453,82]],[1,0,-279.1640000000001,6.310887241768095e-30]],[83,"Title",33554432,147,[[[5,-454,[5,332.94,70.56]],-455],4,1]],[16,"Panel",33554432,8,[[5,-456,[5,600,200]],[9,0,-457,85]]],[16,"Sprite",33554432,41,[[5,-458,[5,128,128]],[9,0,-459,86]]],[16,"Sprite",33554432,42,[[5,-460,[5,128,128]],[9,0,-461,92]]],[16,"Sprite",33554432,43,[[5,-462,[5,128,128]],[9,0,-463,103]]],[12,"BG",33554432,1,[[5,-464,[5,1118.683,2048]],[9,0,-465,118]],[1,0.0014999999999645297,0,0]],[12,"Kangaroo-2",33554432,19,[[5,-466,[5,280,398]],[33,-467,130]],[1,-289.862,-335.27,0]],[12,"Flomingo-2",33554432,19,[[5,-468,[5,392,383]],[33,-469,131]],[1,208,-335.588,0]],[12,"Lion-2",33554432,19,[[5,-470,[5,308,385]],[33,-471,132]],[1,-245.296,348.799,0]],[12,"Giraffe-2",33554432,19,[[5,-472,[5,351,586]],[33,-473,133]],[1,276.021,447.434,0]],[26,"Kangaroo-1",false,33554432,44,[[5,-474,[5,280,398]],[57,-475]],[1,-41.259,294.416,0]],[16,"Panel",33554432,6,[[5,-476,[5,1080,200]],[9,0,-477,136]]],[12,"Sprite",33554432,45,[[5,-478,[5,100,128]],[9,0,-479,137]],[1,0,2,0]],[26,"Pin",false,33554432,6,[[5,-480,[5,50,50]],[9,0,-481,143]],[1,-318.314,37.163,0]],[30,0,null,2,[23,"8fJHyWPHhT77T0qzBIqM/Z",-489,[88,"1dRKqITCJJR6zNWur3+Cgc",2,[[22,[0,["8fJHyWPHhT77T0qzBIqM/Z"]],[[73,-488,[11,"71SN8zFoFC/5gBHzxRLc1H"],158]]]],[[2,["_lpos"],150,[1,0,0,0]],[4,"VD302_Kangaroo_Rig",["_name"],150],[2,["_lrot"],150,[3,0,1,0,6.123233995736766e-17]],[2,["_euler"],150,[1,0,180,0]],[4,2,["_clips","length"],23],[19,["_clips","0"],23,159],[19,["_defaultClip"],23,160],[4,false,["playOnLoad"],23],[19,["_clips","1"],23,161],[4,false,["_useBakedAnimation"],23],[2,["_lrot"],-482,[3,0,0,0,1]],[2,["_euler"],-483,[1,0,0,0]],[2,["_lrot"],-484,[3,-0.5,-0.5,-0.4999999999999999,0.5000000000000001]],[2,["_euler"],-485,[1,-90,-90,0]],[2,["_lrot"],-486,[3,0,0,-6.698506168543417e-16,1]],[2,["_euler"],-487,[1,0,0,-7.67592264999771e-14]],[4,true,["_enabled"],23]]],157]],[72,0,2,[23,"35MaNWaVpaXITwGugCw+yp",-491,[32,"08rkLw8pROl6x37xzaFxdh",[[22,[0,["35MaNWaVpaXITwGugCw+yp"]],[[41,-490]]]],[[2,["_lpos"],133,[1,0,0,0]],[4,"VD289_Lion_Rig",["_name"],133],[2,["_lrot"],133,[3,0,1,0,-6.123233995736766e-17]],[2,["_euler"],133,[1,0,-180,0]],[4,3,["_clips","length"],20],[4,null,["_clips","0"],20],[4,null,["_clips","1"],20],[19,["_clips","2"],20,148],[4,null,["_defaultClip"],20],[4,false,["playOnLoad"],20],[4,false,["_active"],133],[4,false,["_useBakedAnimation"],20]]],147],[{},"mountedRoot",1,2]],[72,0,2,[23,"5dXI/ybWZaFrEKPI46LgaD",-496,[87,"3aWwplyaJLEbF51kOAbVwH",null,[[22,[0,["5dXI/ybWZaFrEKPI46LgaD"]],[[41,-495]]]],[[29,["_lpos"],[0,["5dXI/ybWZaFrEKPI46LgaD"]],[1,0,0,0]],[3,"VD295_Flamingo_Rig",["_name"],[0,["5dXI/ybWZaFrEKPI46LgaD"]]],[29,["_lrot"],[0,["5dXI/ybWZaFrEKPI46LgaD"]],[3,0,1,0,-6.123233995736766e-17]],[2,["_euler"],-492,[1,0,-180,0]],[2,["_lscale"],-493,[1,2,2,2]],[4,3,["_clips","length"],21],[4,null,["_clips","0"],21],[4,null,["_defaultClip"],21],[4,null,["_clips","1"],21],[19,["_clips","2"],21,150],[4,false,["playOnLoad"],21],[4,false,["_active"],-494],[4,false,["_useBakedAnimation"],21]]],149],[{},"mountedRoot",1,2]],[0,["5dXI/ybWZaFrEKPI46LgaD"]],[72,0,2,[23,"49pWBJK15R+45zZnNOgfJN",-498,[32,"3545LzehBPjaiAqCDEZPvW",[[22,[0,["49pWBJK15R+45zZnNOgfJN"]],[[41,-497]]]],[[2,["_lpos"],134,[1,0,0,0]],[4,"VD297_Giraffe_Rig",["_name"],134],[2,["_lrot"],134,[3,0,1,0,-6.123233995736766e-17]],[2,["_euler"],134,[1,0,-180,0]],[4,3,["_clips","length"],22],[4,null,["_clips","1"],22],[4,null,["_defaultClip"],22],[19,["_clips","2"],22,152],[4,null,["_clips","0"],22],[4,false,["playOnLoad"],22],[4,false,["_active"],134],[4,false,["_useBakedAnimation"],22]]],151],[{},"mountedRoot",1,2]],[51,"Checkmark",false,33554432,12,[[[5,-499,[5,40,40]],-500],4,1],[1,-70.416,62.667,0]],[12,"Sprite",33554432,12,[[5,-501,[5,117.45,132.86]],[9,0,-502,162]],[1,0.264,-0.49,0]],[38,"Lock",false,33554432,12,[[5,-503,[5,136.16,143.8]],[58,0,-504,[4,2315255808],163]]],[51,"Checkmark",false,33554432,13,[[[5,-505,[5,40,40]],-506],4,1],[1,-70.416,62.667,0]],[12,"Sprite",33554432,13,[[5,-507,[5,117.45,132.86]],[9,0,-508,166]],[1,-3.01,1.693,0]],[38,"Lock",false,33554432,13,[[5,-509,[5,136.16,143.8]],[58,0,-510,[4,2315255808],167]]],[51,"Checkmark",false,33554432,14,[[[5,-511,[5,40,40]],-512],4,1],[1,-70.416,62.667,0]],[12,"Sprite",33554432,14,[[5,-513,[5,117.45,132.86]],[9,0,-514,170]],[1,-3.009,0.602,0]],[38,"Lock",false,33554432,14,[[5,-515,[5,136.16,143.8]],[58,0,-516,[4,2315255808],171]]],[26,"Icon",false,33554432,24,[[5,-517,[5,128,128]],[9,0,-518,174]],[1,57.723,-48.029,0]],[83,"Checkmark",33554432,24,[[[5,-519,[5,26,26]],-520],4,1]],[51,"Checkmark",false,33554432,11,[[[5,-521,[5,40,40]],-522],4,1],[1,-70.416,62.667,0]],[12,"Sprite",33554432,11,[[5,-523,[5,117.45,132.86]],[9,0,-524,177]],[1,-3.01,1.693,0]],[38,"Lock",false,33554432,11,[[5,-525,[5,136.16,143.8]],[58,0,-526,[4,2315255808],178]]],[26,"Flomingo-1",false,33554432,46,[[5,-527,[5,392,382]],[57,-528]],[1,-39.744,297.341,0]],[26,"Giraffe-1",false,33554432,47,[[5,-529,[5,351,587]],[57,-530]],[1,26.496,391.548,0]],[26,"Lion-1",false,33554432,48,[[5,-531,[5,308,385]],[57,-532]],[1,-2.991,297.36,0]],[12,"Title",33554432,5,[[5,-533,[5,900,180.8]],[154,"你可以从下方四个动物角色种选择一个。\n请点击并解锁你最喜欢的动物：",50,50,80,-534]],[1,0,850,0]],[12,"Label",33554432,49,[[5,-535,[5,440,50.4]],[155,"你想要解锁这个动物吗？",40,true,-536,[4,4278190080]]],[1,0,103.8,0]],[46,"Label",512,33554432,50,[[5,-537,[5,100,40]],[43,"是",20,20,1,false,-538,[4,4279488003]]]],[46,"Label",512,33554432,51,[[5,-539,[5,100,40]],[43,"否",20,20,1,false,-540,[4,4278190080]]]],[12,"Title",33554432,1,[[5,-541,[5,480,100.8]],[93,"新动物解锁！",80,80,80,false,true,-542]],[1,44.406,736.504,0]],[106,"Label",512,false,33554432,52,[[5,-543,[5,100,40]],[43,"button",20,20,1,false,-544,[4,4278190080]]]],[16,"NameTag",33554432,138,[[5,-545,[5,448.14599999999996,150]],[9,0,-546,228]]],[16,"Label",33554432,138,[[5,-547,[5,296,100.8]],[63,"KANGAROO",50,50,80,false,true,-548,[4,4279637536]]]],[0,["5fl0cfxJ5Rs5ovU2QsXaQ9"]],[0,["61SpoqJn9XKIWNc6m3Gvr3"]],[0,["f3CmudYmJTjK7M6nViAmg5"]],[16,"NameTag",33554432,139,[[5,-549,[5,448.14599999999996,150]],[9,0,-550,234]]],[16,"Label",33554432,139,[[5,-551,[5,285.95,100.8]],[63,"FLAMINGO",50,50,80,false,true,-552,[4,4279637536]]]],[30,0,{},139,[23,"5dXI/ybWZaFrEKPI46LgaD",-555,[87,"fegi+T25tGoZae7dFFosxU",null,[[22,[0,["00epe3MM5V+6cyzbwFVcci"]],[[42],[54]]]],[[29,["_lpos"],[0,["5dXI/ybWZaFrEKPI46LgaD"]],[1,0,500,100]],[3,"VD295_Flamingo_Rig-001",["_name"],[0,["5dXI/ybWZaFrEKPI46LgaD"]]],[29,["_lrot"],[0,["5dXI/ybWZaFrEKPI46LgaD"]],[3,0,0,0,1]],[29,["_euler"],[0,["5dXI/ybWZaFrEKPI46LgaD"]],[1,0,0,0]],[29,["_lscale"],[0,["5dXI/ybWZaFrEKPI46LgaD"]],[1,200,200,200]],[3,2,["_clips","length"],[0,["4cq3CaMM9QFplY9tFHtlLH"]]],[3,null,["_clips","0"],[0,["4cq3CaMM9QFplY9tFHtlLH"]]],[3,null,["_defaultClip"],[0,["4cq3CaMM9QFplY9tFHtlLH"]]],[3,null,["_clips","1"],[0,["4cq3CaMM9QFplY9tFHtlLH"]]],[3,null,["_clips","2"],[0,["4cq3CaMM9QFplY9tFHtlLH"]]],[3,true,["playOnLoad"],[0,["4cq3CaMM9QFplY9tFHtlLH"]]],[4,true,["_active"],-553],[4,"VD295_Flamingo_Toy",["_name"],154],[2,["_lrot"],154,[3,-0.7071067811865477,0,0,0.7071067811865474]],[2,["_euler"],154,[1,-90.00000000000003,0,0]],[4,524288,["_layer"],-554],[4,524288,["_layer"],154],[3,524288,["_layer"],[0,["c3T8xhbBlaNp7/Bly9AFlQ"]]],[3,524288,["_layer"],[0,["c4MNbS8yRXIaS6qgPgPrqT"]]],[3,524288,["_layer"],[0,["63UN7XUWBWyZZ/qkFfOZhT"]]],[3,524288,["_layer"],[0,["28HoLqRkpcfoL7nQmIgrpu"]]],[3,524288,["_layer"],[0,["74qcjuzehSf5BUatpViYMH"]]],[3,524288,["_layer"],[0,["cfwWn+4r9UDZPd2/A7BPsK"]]],[3,524288,["_layer"],[0,["11e4xaYaxdEodwfLk3pWmV"]]],[3,524288,["_layer"],[0,["b5g+r/vqNfaail1orcNRvu"]]],[3,524288,["_layer"],[0,["98ubztsaReB4SM5j0C+9XQ"]]],[3,524288,["_layer"],[0,["45seyRJhVZ2YulhZHAVFr0"]]],[3,524288,["_layer"],[0,["e1NdgXAPpT3pWeZaVw/WW/"]]],[3,524288,["_layer"],[0,["91wcoKnUdZt649Xs1K9QTt"]]],[3,524288,["_layer"],[0,["daFSmgldhVHZr6ed1FMbc2"]]],[3,524288,["_layer"],[0,["afjViuGxNakYmIONA9A7ZA"]]],[3,524288,["_layer"],[0,["23P11ouaBeNaOziPbu7lTO"]]],[3,524288,["_layer"],[0,["badzM6Hqlb27spngOq5m5/"]]],[3,524288,["_layer"],[0,["4aHFl3fHlbuaL6RN8JRXeO"]]],[3,524288,["_layer"],[0,["9eM/tvRn9fvLFlTT7ESNOv"]]],[3,524288,["_layer"],[0,["67sWnaBDZcZIOZiwUDQXR8"]]],[3,524288,["_layer"],[0,["98Sz/NQqJWj6c2DtnFVTQ6"]]],[3,524288,["_layer"],[0,["79MDogfrxY4pizj38cH188"]]],[3,524288,["_layer"],[0,["1exRZapZNcwIBXxb/0W5eY"]]],[3,524288,["_layer"],[0,["d2NS0Sd+lc/qOaGqu0ryVu"]]],[3,524288,["_layer"],[0,["46CRa2+nVSU7GAYxzrvj3h"]]],[3,524288,["_layer"],[0,["62LM705PxVL7yWO1SbD16v"]]],[3,524288,["_layer"],[0,["b72NXmqyBRSqNZecSkl4t2"]]],[3,524288,["_layer"],[0,["783hrjEJBTA6iOjJ8o6PCH"]]],[3,524288,["_layer"],[0,["cfy2dsSI5clai71SmRD+gt"]]],[3,524288,["_layer"],[0,["8df/WULSJXH4ndqHq46j6Q"]]],[3,524288,["_layer"],[0,["15bHkaVhxULoQNZ95K+rGl"]]],[3,524288,["_layer"],[0,["baXanNgPZQoZV6vIjIoTfA"]]],[3,524288,["_layer"],[0,["1eYfzhDh5bIo6wE6rROPOs"]]],[3,524288,["_layer"],[0,["30RfEJQ/xTabZjlnUgSgWc"]]],[3,524288,["_layer"],[0,["34Ruzm2H1XYYt2kEBRWij0"]]],[3,524288,["_layer"],[0,["eeJG5qN81dm4bIT7UcnztQ"]]],[3,524288,["_layer"],[0,["81v2Uyj+Vez6nrS7hhhoNT"]]],[3,524288,["_layer"],[0,["b51/1/kdFRobUfwsEeT3uH"]]],[3,524288,["_layer"],[0,["33lPB7VnpemLW23UhXTmaQ"]]],[3,524288,["_layer"],[0,["f1JuzE2exYNpMLArES2Q9R"]]],[3,524288,["_layer"],[0,["a0kNa6alVRtb1xwMgM02q9"]]],[3,524288,["_layer"],[0,["33XcvF5phc+IlA2P543Z0E"]]],[3,524288,["_layer"],[0,["d8KrAf/ApRq4ueboGh7Kiw"]]],[3,524288,["_layer"],[0,["d0xrCNmzhYj5mJfGfYioBX"]]],[3,524288,["_layer"],[0,["c5UNlN9WpelrcAagNMgB3X"]]],[3,524288,["_layer"],[0,["ec0i50qEBURauM08B13c/7"]]]]],235]],[16,"NameTag",33554432,140,[[5,-556,[5,448.14599999999996,150]],[9,0,-557,236]]],[16,"Label",33554432,140,[[5,-558,[5,130.55,100.8]],[63,"LION",50,50,80,false,true,-559,[4,4279637536]]]],[16,"NameTag",33554432,141,[[5,-560,[5,448.14599999999996,150]],[9,0,-561,239]]],[16,"Label",33554432,141,[[5,-562,[5,255.4,100.8]],[63,"GIRAFFE",50,50,80,false,true,-563,[4,4279637536]]]],[30,0,{},141,[23,"49pWBJK15R+45zZnNOgfJN",-566,[32,"8fMnZVdF5LZp31FR0YZpHH",[[22,[0,["e3FAH3cZhSZLsUbfJUC80S"]],[[42],[54]]]],[[2,["_lpos"],28,[1,0,200,100]],[4,"VD297_Giraffe_Rig-001",["_name"],28],[2,["_lrot"],28,[3,0,0,0,1]],[2,["_euler"],28,[1,0,0,0]],[4,3,["_clips","length"],54],[4,null,["_clips","1"],54],[4,null,["_defaultClip"],54],[19,["_clips","2"],54,241],[4,null,["_clips","0"],54],[4,true,["playOnLoad"],54],[4,true,["_active"],28],[2,["_lscale"],28,[1,150,150,150]],[2,["_lpos"],-564,[1,0,0,0]],[4,524288,["_layer"],28],[4,524288,["_layer"],-565],[3,524288,["_layer"],[0,["27goImrUhSiLj/q8l+pR3q"]]],[3,524288,["_layer"],[0,["edXyveHQlamqk5Klmem7yW"]]],[3,524288,["_layer"],[0,["0bz+t64LpWRoPHsBCKwTl/"]]],[3,524288,["_layer"],[0,["f2uk/fraBW44RrsLTmM1qH"]]],[3,524288,["_layer"],[0,["76JitRG4Bb6IWeWws2pnXN"]]],[3,524288,["_layer"],[0,["11BAfAQWVSDq0Huwsgvaqy"]]],[3,524288,["_layer"],[0,["80xBgp43xZAaNnhTprLbP3"]]],[3,524288,["_layer"],[0,["cf54cUQTFQdaEFKgi0tXhy"]]],[3,524288,["_layer"],[0,["dayS5tevFSZqR9L49DlLE1"]]],[3,524288,["_layer"],[0,["35suY1tUlZY6a8OdTLav2m"]]],[3,524288,["_layer"],[0,["56D6KHIFhfjJguAA9oJ5nd"]]],[3,524288,["_layer"],[0,["e8IZExt/9Zj4U6ZKChzAp8"]]],[3,524288,["_layer"],[0,["7c+r1SaXFbJIz1+lTaGNL8"]]],[3,524288,["_layer"],[0,["05vzGOWtNStKzQvyWde+Ao"]]],[3,524288,["_layer"],[0,["4eZ9lbh79WQ7KnvB+7+zxC"]]],[3,524288,["_layer"],[0,["a8Hm0zESxYv6gYOiTo0hxR"]]],[3,524288,["_layer"],[0,["4eUfYIsfZUlrwpmZtd7TvP"]]],[3,524288,["_layer"],[0,["14Ad035ANcloqi0mJImlLj"]]],[3,524288,["_layer"],[0,["d4y+2xk59a2r6WSeI/vdA+"]]],[3,524288,["_layer"],[0,["27MQcNugdU3YnRBSyPx/OP"]]],[3,524288,["_layer"],[0,["27d7tBW79d3Krcc+XS9kjS"]]],[3,524288,["_layer"],[0,["c4UT6iM6ZavIrWG+TU0Tk4"]]],[3,524288,["_layer"],[0,["a84YD19Gdc1L3jl37FEJEs"]]],[3,524288,["_layer"],[0,["14c21KloFeW4TnZpqdpSeQ"]]],[3,524288,["_layer"],[0,["feam7ruXVQvZy90w4OSN1y"]]],[3,524288,["_layer"],[0,["1aix5QZVtffaZlYVrLXuzk"]]],[3,524288,["_layer"],[0,["9eXV3vCA5TaIZGzjUDTB7g"]]],[3,524288,["_layer"],[0,["49XHXwZQJSX7a3Ea2snvla"]]],[3,524288,["_layer"],[0,["d2RYeAmwZVVbYhAqdc4wDo"]]],[3,524288,["_layer"],[0,["35776kuEBeLZHUS0fLbjDm"]]],[3,524288,["_layer"],[0,["99+llp6yNf0pX1/DQ9+tgW"]]],[3,524288,["_layer"],[0,["2eX9kiozNTCYTR1C6h7sEi"]]],[3,524288,["_layer"],[0,["72SZVCrg1a2LbK96LcowhX"]]],[3,524288,["_layer"],[0,["35HbIUuotdQaMkFrCYzRIQ"]]],[3,524288,["_layer"],[0,["17RB3ykLBUm6je9HRIuOn/"]]],[3,524288,["_layer"],[0,["df+haHFsFdPpoeUvr0OVYf"]]],[3,524288,["_layer"],[0,["dexMSBu/Vc6oaq6wAV+avX"]]],[3,524288,["_layer"],[0,["51H6UXMFxVxreAZ4YjFABg"]]],[3,524288,["_layer"],[0,["2evjecQFZRbpov5tGjlFBH"]]],[3,524288,["_layer"],[0,["07HB7bVs5fSK0GCLwvrUvV"]]],[3,524288,["_layer"],[0,["5bcRdelBNcnqSCWgDkZn2m"]]],[3,524288,["_layer"],[0,["04PkZ8dHRVzZYNqb8TRcv7"]]],[3,524288,["_layer"],[0,["fd1KRbHfVdb5Q/fJ5w91SW"]]],[3,524288,["_layer"],[0,["e7FwbyyURWBqR0qzpv6MFQ"]]],[3,524288,["_layer"],[0,["7ft6QxtctagqdyecDLAhlN"]]],[3,524288,["_layer"],[0,["754t+mjF9VIpOTs7KdhAPA"]]],[3,524288,["_layer"],[0,["bcMI6QptlSGKEmSrWoPjmO"]]],[3,524288,["_layer"],[0,["89CoNx03Fe95p6c3PgddFh"]]],[3,524288,["_layer"],[0,["1arjDVWixWE6C/bv+TdkwO"]]],[3,524288,["_layer"],[0,["65Hr4qA4tY9J8Jvd+K0x5F"]]],[3,524288,["_layer"],[0,["7c7vkHe8taurwV9/b63dyq"]]],[3,524288,["_layer"],[0,["c6PyF6E9Fejpf+FhJZKAVH"]]],[3,524288,["_layer"],[0,["57n9xYdK5ZWIvmtHeYAceX"]]],[3,524288,["_layer"],[0,["1cIIaKZ1pcGLS4H52SXjPZ"]]],[3,524288,["_layer"],[0,["5fP7MY0KRScq+eqbAl68XC"]]],[3,524288,["_layer"],[0,["d42HOx4B5W6oKyikGCD94J"]]],[3,524288,["_layer"],[0,["4bY2R+ZuhfRbqPseCyF6kY"]]],[3,524288,["_layer"],[0,["16zFfly2pUNYXtnr5x4XBX"]]],[3,524288,["_layer"],[0,["3byxQ4HQJX6rqKO+WPtPaP"]]],[3,524288,["_layer"],[0,["528DScHiFfopPcfjRBeca+"]]],[3,524288,["_layer"],[0,["d4iQC7nKxUyoITQdTj5HN0"]]],[3,524288,["_layer"],[0,["55lY+R+5VfcL3MRr4OPaf/"]]],[3,524288,["_layer"],[0,["14ITHPHChYjbDoBqTnlyOE"]]],[3,524288,["_layer"],[0,["37bpu2CtdYWYgYXX1+Fi7a"]]],[3,524288,["_layer"],[0,["d9Du9LEYtYd6fEY+RDtLSd"]]]]],240]],[16,"BG",33554432,29,[[5,-567,[5,504,284]],[33,-568,242]]],[12,"Label",33554432,29,[[5,-569,[5,293.47,50.4]],[156,"Allow app to access your camera",20,20,-570,[4,4278190080]]],[1,0,51.523,0]],[46,"Label",512,33554432,55,[[5,-571,[5,100,40]],[43,"Allow",20,20,1,false,-572,[4,4278190080]]]],[46,"Label",512,33554432,56,[[5,-573,[5,100,40]],[43,"Deny",20,20,1,false,-574,[4,4278190080]]]],[114,"Node",false,"1eWau2YgFDX7oWGuPXEtU2",7,[142],[-575],[1,-4.006,0.052,-4],[3,0,1,0,6.123233995736766e-17],[1,0,180,0]],[80,"Main Light","c0y6F5f+pAvI805TdmxIjx",7,[[157,0.1,1,30,-576,[158]]],[1,0,0,220.15]],[84,"Main Camera","c9DMICJLFO5IeO07EPon7U",7,[156],[1,0,2.911,12.371]],[115,"Camera",3,[-577],[1,0,0,1000]],[149,0,1073741824,960,2000,6,42467328,239,[4,4278190080]],[159,18],[160,9],[161,10],[61,2,37,[[8,"d5570+aNMNBpKsWeic7F5lj","gotoMap",4]],[4,4292269782],37],[61,2,38,[[8,"d5570+aNMNBpKsWeic7F5lj","gotoHabitat",4]],[4,4292269782],38],[61,2,39,[[8,"d5570+aNMNBpKsWeic7F5lj","gotoPicture",4]],[4,4292269782],39],[61,2,40,[[8,"d5570+aNMNBpKsWeic7F5lj","gotoFood",4]],[4,4292269782],40],[93,"HERBIVORE",56,56,56,false,true,177],[162,4,243,248,244,245,246,247],[163,8],[164,6],[165,false,6,191],[0,["1dRKqITCJJR6zNWur3+Cgc","8fJHyWPHhT77T0qzBIqM/Z"]],[0,["5fl0cfxJ5Rs5ovU2QsXaQ9"]],[0,["61SpoqJn9XKIWNc6m3Gvr3"]],[0,["f3CmudYmJTjK7M6nViAmg5"]],[59,0,196],[59,0,199],[59,0,202],[138,0,206,[4,16777215]],[59,0,207],[167,5],[0,["5dXI/ybWZaFrEKPI46LgaD"]],[0,["e3FAH3cZhSZLsUbfJUC80S"]],[168,3,242,262,250,249,251,31],[169,236,156,149,135,142],[80,"AnimalManager","10e3SzIH1MJpT3NfydXRY8",7,[[166,-578]],[1,0,6,0]]],0,[0,0,1,0,0,1,0,-1,182,0,-2,130,0,-3,131,0,-4,132,0,-5,217,0,-6,52,0,-7,151,0,-8,152,0,-9,138,0,-10,139,0,-11,140,0,-12,141,0,-13,29,0,11,149,0,11,156,0,11,135,0,11,18,0,5,253,0,5,253,0,-1,192,0,-2,193,0,-3,195,0,10,2,0,0,3,0,25,240,0,0,3,0,0,3,0,-4,265,0,-1,239,0,-2,58,0,-3,31,0,-4,9,0,-5,4,0,-6,127,0,-7,8,0,-9,5,0,-10,6,0,0,4,0,-2,249,0,-1,61,0,-2,62,0,-3,36,0,-4,168,0,-5,10,0,-6,15,0,0,5,0,-2,262,0,-1,19,0,-2,44,0,-3,46,0,-4,47,0,-5,48,0,-6,213,0,-7,49,0,0,6,0,-2,251,0,-3,252,0,-1,188,0,-2,45,0,-3,190,0,-4,148,0,-5,16,0,-1,168,0,-2,153,0,-3,226,0,-4,155,0,-5,231,0,-6,142,0,20,265,0,20,241,0,20,252,0,20,266,0,-1,237,0,-2,238,0,-3,30,0,-5,236,0,-6,135,0,-7,149,0,-9,267,0,-10,18,0,0,8,0,-2,250,0,-1,178,0,-2,41,0,-3,42,0,-4,128,0,-5,43,0,-6,129,0,0,9,0,-2,242,0,-1,160,0,-2,32,0,-3,33,0,-4,60,0,-5,34,0,-6,35,0,0,10,0,-2,243,0,-1,169,0,-2,124,0,-3,125,0,-4,170,0,-5,171,0,-6,126,0,0,11,0,0,11,0,17,261,0,6,11,0,18,11,0,0,11,0,-1,207,0,-2,208,0,-3,209,0,0,12,0,0,12,0,17,257,0,6,12,0,18,12,0,0,12,0,-1,196,0,-2,197,0,-3,198,0,0,13,0,0,13,0,17,258,0,6,13,0,18,13,0,0,13,0,-1,199,0,-2,200,0,-3,201,0,0,14,0,0,14,0,17,259,0,6,14,0,18,14,0,0,14,0,-1,202,0,-2,203,0,-3,204,0,0,15,0,-1,37,0,-2,38,0,-3,39,0,-4,40,0,-5,176,0,-6,147,0,0,16,0,0,16,0,-5,24,0,0,17,0,0,17,0,6,17,0,18,30,0,0,17,0,0,17,0,-1,157,0,-1,241,0,0,19,0,0,19,0,-1,183,0,-2,184,0,-3,185,0,-4,186,0,0,24,0,0,24,0,17,260,0,6,24,0,0,24,0,-1,205,0,-2,206,0,0,29,0,0,29,0,-1,232,0,-2,233,0,-3,55,0,-4,56,0,0,30,0,0,31,0,-1,158,0,-2,159,0,-3,59,0,0,32,0,0,32,0,6,32,0,0,32,0,-1,161,0,0,33,0,0,33,0,6,33,0,0,33,0,-1,162,0,0,34,0,0,34,0,6,34,0,0,34,0,-1,163,0,0,35,0,0,35,0,6,35,0,0,35,0,-1,164,0,0,36,0,-1,165,0,-2,166,0,-3,167,0,-4,63,0,0,37,0,0,37,0,-3,244,0,-1,172,0,0,38,0,0,38,0,-3,245,0,-1,173,0,0,39,0,0,39,0,-3,246,0,-1,174,0,0,40,0,0,40,0,-3,247,0,-1,175,0,0,41,0,0,41,0,6,41,0,0,41,0,-1,179,0,0,42,0,0,42,0,6,42,0,0,42,0,-1,180,0,0,43,0,0,43,0,6,43,0,0,43,0,-1,181,0,0,44,0,0,44,0,6,44,0,0,44,0,-1,187,0,0,45,0,0,45,0,6,45,0,0,45,0,-1,189,0,0,46,0,0,46,0,6,46,0,0,46,0,-1,210,0,0,47,0,0,47,0,6,47,0,0,47,0,-1,211,0,0,48,0,0,48,0,6,48,0,0,48,0,-1,212,0,0,49,0,0,49,0,-1,214,0,-2,50,0,-3,51,0,0,50,0,0,50,0,6,50,0,0,50,0,-1,215,0,0,51,0,0,51,0,6,51,0,0,51,0,-1,216,0,0,52,0,0,52,0,6,52,0,0,52,0,-1,218,0,0,55,0,0,55,0,6,55,0,0,55,0,-1,234,0,0,56,0,0,56,0,6,56,0,0,56,0,-1,235,0,0,58,0,0,58,0,-1,144,0,0,59,0,0,59,0,6,59,0,0,59,0,0,60,0,0,60,0,6,60,0,0,60,0,0,61,0,0,61,0,6,61,0,0,61,0,0,62,0,0,62,0,6,62,0,0,62,0,0,63,0,0,63,0,6,63,0,0,63,0,0,124,0,0,124,0,6,124,0,0,124,0,0,125,0,0,125,0,6,125,0,0,125,0,0,126,0,0,126,0,6,126,0,0,126,0,0,127,0,0,127,0,6,127,0,0,127,0,0,128,0,0,128,0,6,128,0,0,128,0,0,129,0,0,129,0,6,129,0,0,129,0,0,130,0,0,130,0,6,130,0,0,130,0,0,131,0,0,131,0,6,131,0,0,131,0,0,132,0,0,132,0,6,132,0,0,132,0,0,135,0,0,135,0,0,136,0,0,136,0,6,136,0,0,136,0,0,137,0,0,137,0,6,137,0,0,137,0,0,138,0,-1,219,0,-2,220,0,-3,153,0,0,139,0,-1,224,0,-2,225,0,-3,226,0,0,140,0,-1,227,0,-2,228,0,-3,155,0,0,141,0,-1,229,0,-2,230,0,-3,231,0,5,143,0,5,143,0,5,143,0,5,143,0,5,143,0,0,142,0,10,142,0,0,144,0,0,144,0,0,144,0,0,147,0,0,147,0,-1,177,0,0,148,0,0,148,0,0,148,0,0,149,0,0,151,0,0,152,0,0,152,0,0,152,0,5,221,0,5,221,0,5,222,0,5,222,0,5,223,0,5,223,0,5,221,0,5,222,0,5,223,0,0,153,0,10,153,0,0,155,0,10,155,0,0,157,0,0,157,0,0,158,0,0,158,0,0,159,0,0,159,0,0,160,0,0,160,0,0,161,0,0,161,0,0,162,0,0,162,0,0,163,0,0,163,0,0,164,0,0,164,0,0,165,0,0,165,0,0,166,0,0,166,0,0,167,0,0,167,0,10,168,0,0,169,0,0,169,0,0,170,0,0,170,0,0,171,0,0,171,0,0,172,0,0,172,0,0,173,0,0,173,0,0,174,0,0,174,0,0,175,0,0,175,0,0,176,0,0,176,0,0,177,0,-2,248,0,0,178,0,0,178,0,0,179,0,0,179,0,0,180,0,0,180,0,0,181,0,0,181,0,0,182,0,0,182,0,0,183,0,0,183,0,0,184,0,0,184,0,0,185,0,0,185,0,0,186,0,0,186,0,0,187,0,0,187,0,0,188,0,0,188,0,0,189,0,0,189,0,0,190,0,0,190,0,5,254,0,5,254,0,5,255,0,5,255,0,5,256,0,5,256,0,0,191,0,10,191,0,0,192,0,10,192,0,5,194,0,5,194,0,5,194,0,0,193,0,10,193,0,0,195,0,10,195,0,0,196,0,-2,257,0,0,197,0,0,197,0,0,198,0,0,198,0,0,199,0,-2,258,0,0,200,0,0,200,0,0,201,0,0,201,0,0,202,0,-2,259,0,0,203,0,0,203,0,0,204,0,0,204,0,0,205,0,0,205,0,0,206,0,-2,260,0,0,207,0,-2,261,0,0,208,0,0,208,0,0,209,0,0,209,0,0,210,0,0,210,0,0,211,0,0,211,0,0,212,0,0,212,0,0,213,0,0,213,0,0,214,0,0,214,0,0,215,0,0,215,0,0,216,0,0,216,0,0,217,0,0,217,0,0,218,0,0,218,0,0,219,0,0,219,0,0,220,0,0,220,0,0,224,0,0,224,0,0,225,0,0,225,0,5,263,0,5,263,0,10,226,0,0,227,0,0,227,0,0,228,0,0,228,0,0,229,0,0,229,0,0,230,0,0,230,0,5,264,0,5,264,0,10,231,0,0,232,0,0,232,0,0,233,0,0,233,0,0,234,0,0,234,0,0,235,0,0,235,0,-1,266,0,0,237,0,-1,240,0,0,267,0,26,7,1,1,3,2,1,7,3,1,7,11,1,16,12,1,16,13,1,16,14,1,16,17,1,58,136,1,151,137,1,151,142,1,236,156,0,238,578],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,241,241,241,241,244,244,244,244,245,245,245,245,246,246,246,246,247,247,247,247,249,249,257,258,259,260,261],[2,2,2,4,7,8,9,2,2,2,4,7,8,9,2,2,4,7,8,9,2,4,7,8,9,2,2,4,7,8,9,2,2,4,7,8,9,2,4,7,8,9,2,4,7,8,9,2,2,2,4,7,8,9,13,11,11,2,2,4,7,8,9,2,4,7,8,9,2,2,4,7,8,9,2,2,2,2,2,2,2,2,2,2,2,2,2,2,4,7,8,9,2,2,4,7,8,9,2,4,7,8,9,2,2,4,7,8,9,2,4,7,8,9,4,7,8,9,2,2,4,7,8,9,2,4,7,8,9,2,2,2,2,2,2,2,2,2,2,4,7,8,9,2,2,4,13,13,11,13,11,13,11,-1,14,-1,14,13,21,11,11,11,2,2,2,4,2,2,2,4,2,2,2,4,2,2,4,2,2,2,4,4,7,8,9,2,4,7,8,9,2,4,7,8,9,2,4,7,8,9,2,4,7,8,9,2,4,7,8,9,2,4,7,8,9,2,4,7,8,9,7,8,9,7,8,9,-1,14,2,13,21,11,11,11,2,13,2,13,11,2,13,11,2,2,4,7,8,9,2,4,7,8,9,13,27,28,29,30,4,7,8,9,4,7,8,9,4,7,8,9,4,7,8,9,31,32,2,2,2,2,2],[43,13,16,16,0,2,1,28,44,3,3,0,2,1,45,3,3,0,2,1,14,14,0,2,1,46,3,3,0,2,1,47,3,3,0,2,1,17,17,0,2,1,18,18,0,2,1,29,13,16,16,0,2,1,48,9,9,49,19,19,0,2,1,30,30,0,2,1,50,19,19,0,2,1,51,12,52,7,53,12,54,12,55,56,14,28,57,3,3,0,2,1,58,3,3,0,2,1,31,31,0,2,1,20,3,3,0,2,1,21,21,0,2,1,14,0,2,1,29,18,18,0,2,1,17,17,0,2,1,21,59,60,61,62,63,8,64,32,4,4,0,2,1,15,14,14,65,23,33,34,66,35,36,67,68,69,70,24,25,9,9,22,71,4,4,4,72,4,4,4,73,4,4,4,20,20,20,32,4,4,4,8,8,8,8,8,8,0,2,1,8,8,0,2,1,8,8,0,2,1,0,0,0,2,1,0,0,0,2,1,37,21,0,2,1,38,38,0,2,1,0,2,1,0,2,1,10,26,13,24,25,9,9,22,13,34,13,23,33,13,35,36,37,0,0,0,2,1,0,0,0,2,1,23,74,75,76,77,12,7,7,1,7,7,7,1,12,7,7,1,12,7,7,1,12,7,15,15,15,15,15]],[[{"name":"loading_bg","rect":{"x":0,"y":0,"width":1002,"height":1334},"offset":{"x":0,"y":0},"originalSize":{"width":1002,"height":1334},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[78]],[[[28,".bin",3429205708,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":72464,"length":28560,"count":7140,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":72464,"count":1294,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.49748557806015015,-0.5,-0.4989933371543884],"maxPosition",8,[1,0.49949654936790466,0.5,0.49899348616600037]]],-1],0,0,[],[],[]],[[[28,".bin",3219909449,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":6776,"length":2400,"count":600,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":6776,"count":121,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-5,0,-5],"maxPosition",8,[1,5,0,5]]],-1],0,0,[],[],[]],[[{"name":"Lion-2","rect":{"x":1,"y":1,"width":308,"height":385},"offset":{"x":0,"y":0},"originalSize":{"width":310,"height":387},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[79]],[[{"name":"UI_Camera_take_photo","rect":{"x":0,"y":0,"width":346,"height":362},"offset":{"x":0,"y":0},"originalSize":{"width":346,"height":362},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[80]],[[[64],[52,"VD295_Flamingo_Rig",[[-3,-4,[47,"Bn_FoodSpawn",-6,[1,"c4MNbS8yRXIaS6qgPgPrqT",-5,0],[1,-0.020412404090166092,0,1.4832285642623901]]],1,1,4],[[65,-2,[11,"4cq3CaMM9QFplY9tFHtlLH"]]],[1,"5dXI/ybWZaFrEKPI46LgaD",-1,0]],[86,"Bip001 Head",[[6,"Bip001 Mouth",-7,[1,"15bHkaVhxULoQNZ95K+rGl",1,0],[1,0.1853790134191513,0.02393317222595215,2.3913526092655957e-7],[3,3.6327741156443087e-13,-3.631222933645755e-7,0.13092161595638818,0.9913927226257192],[1,0.000005641172556479641,-0.0000427169780191864,15.045704420963872]],[6,"Bip001 eye_L",-8,[1,"baXanNgPZQoZV6vIjIoTfA",1,0],[1,0.10343153774738312,-0.04911351203918457,0.05298836901783943],[3,-0.00024194813402205606,-0.6087613167009532,0.0003147253914729629,0.7933533271484717],[1,-0.00004099095042321951,-74.9999906904734,0.04549022969239943]],[6,"Bip001 eye_R",-9,[1,"1eYfzhDh5bIo6wE6rROPOs",1,0],[1,0.10257671773433685,-0.04911303520202637,-0.04994485154747963],[3,0.00024194823562694417,0.6087613160504972,0.00031810219219961393,0.7933533263007808],[1,-0.00019456181980478671,74.99999078450371,0.045797227167488165]],[6,"Bip001 eyelid_L_up",-10,[1,"30RfEJQ/xTabZjlnUgSgWc",1,0],[1,0.10343153774738312,-0.04911351203918457,0.05298838019371033],[3,0.14415553349210042,-0.5914464649160642,-0.18848307609929205,0.7706389500447322],[1,-0.04981721459010648,-75.02287479330846,-27.453291992450442]],[6,"Bip001 eyelid_L_down",-11,[1,"34Ruzm2H1XYYt2kEBRWij0",1,0],[1,0.10343150794506073,-0.04911351203918457,0.05298838019371033],[3,-0.14445081285955402,-0.5913755270136265,0.18763612123418558,0.7708447539691502],[1,-0.04978601366354341,-74.97715566447208,27.395237742743113]],[6,"Bip001 eyelid_R_down",-12,[1,"eeJG5qN81dm4bIT7UcnztQ",1,0],[1,0.10257671773433685,-0.04911303520202637,-0.049944858998060226],[3,0.14445078097891403,0.5913745052261379,0.18763941169109033,0.7708447428784502],[1,0.049556368854709015,74.97711667339797,27.39554335799152]],[6,"Bip001 eyelid_R_up",-13,[1,"81v2Uyj+Vez6nrS7hhhoNT",1,0],[1,0.10257671773433685,-0.04911303520202637,-0.04994484782218933],[3,-0.1441554573227101,0.5914475309742541,-0.1884798254710249,0.7706389411514001],[1,0.04960249879584121,75.02292260137546,-27.452982316206292]],[6,"Bip001 L_lips_point",-14,[1,"b51/1/kdFRobUfwsEeT3uH",1,0],[1,0.2125636488199234,0.0004966259002685547,0.06602133065462112],[3,-0.0002447514480468828,-0.6158146653236611,0.00031252725290150497,0.7878909444813742],[1,-0.000043382534688888074,-76.0222854335002,0.045488146695362]],[6,"Bip001 L_lips_pointOpp",-15,[1,"33lPB7VnpemLW23UhXTmaQ",1,0],[1,0.2125636488199234,0.0004971027374267578,-0.06602133065462112],[3,0.0002447515641994772,0.6158146646626275,0.0003159431690293676,0.7878909436356288],[1,-0.00019765856372147501,76.02228552971563,0.045796563154277055]],[6,"Bn_Mouth",-16,[1,"f1JuzE2exYNpMLArES2Q9R",1,0],[1,0.35302335023880005,0.03254532814025879,0.000400304765207693],[3,-0.17419363444136365,0.6794313743888158,0.17440272753386546,0.691095705271695],[1,-28.539391285878086,89.08818266132725,0.24939276046124864]]],[1,"783hrjEJBTA6iOjJ8o6PCH",1,0],[1,0.34503018856048584,0.05807298421859741,-3.204622771590948e-7],[3,0.000007283078974909878,-0.000002044906528056778,0.7926253695146028,0.6097089662655573],[1,179.99729216877995,-179.99686413223276,75.13692459404484]],[39,"Bip001",1,[[[6,"Bip001 Footsteps",-17,[1,"63UN7XUWBWyZZ/qkFfOZhT",1,0],[1,0,0,-1.2544288635253906],[3,-6.9210348904225676e-34,6.921044533149829e-34,0.7071063043492204,0.7071072580235531],[1,0,-1.1216009582263197e-31,90]],-18,-19],4,1,1],[1,"c3T8xhbBlaNp7/Bly9AFlQ",1,0],[1,0,1.2599310874938965,-0.03170289844274521],[3,-0.5000003576277408,-0.49999964237200345,-0.49999964237200345,0.5000003576277408],[1,-90,-89.99991803772996,0]],[34,"Bip001 Spine",[-20,-21,-22],[1,"cfwWn+4r9UDZPd2/A7BPsK",1,0],[1,0.006523013114929199,0.007367122918367386,-2.466515525156865e-8],[3,-0.000003644542704351234,-0.0000032234625650382653,0.7079508448334461,0.706261708770861],[1,-179.98599514327807,179.9854386389328,89.8631318550418]],[7,"Bip001 Neck",4,[-23,-24,-25],[1,"45seyRJhVZ2YulhZHAVFr0",1,0],[1,0.31526342034339905,-0.00016570091247558594,8.220013114623725e-9],[3,-2.557486891979508e-7,0.0000019258948303804823,-0.1736482836955129,0.9848077343145861],[1,0.000010068460395121748,0.00022587115662259883,-20.000012337433215]],[31,"VD295_Flamingo_Toy",1,[[44,-26,[11,"ea68U0IKpXTa0akVc+P+6u"],[0,1,2,3],[24],1,4,5]],[1,"00epe3MM5V+6cyzbwFVcci",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[69,"Bip001 Pelvis",3,[4],[1,"28HoLqRkpcfoL7nQmIgrpu",1,0],[3,-0.49999999254917427,-0.49999999254917427,-0.49999930709576956,0.5000007078049009],[1,-89.99991974527727,-89.99991974527727,-0.0000017074910602964197]],[7,"Bip001 L Thigh",4,[-27],[1,"b5g+r/vqNfaail1orcNRvu",1,0],[1,-0.007351363077759743,0.006539463996887207,0.13554731011390686],[3,-0.025361888339490553,-0.04286933728992652,0.7657588789419875,0.6411960182827777],[1,169.22300015928454,-174.77584462709845,79.79416966078732]],[7,"Bip001 L Calf",8,[-28],[1,"91wcoKnUdZt649Xs1K9QTt",1,0],[1,0.6679134964942932,0,1.4901161193847656e-8],[3,7.532819370050671e-18,5.867785891590635e-18,-0.09536687107671847,0.9954421931488723],[1,9.404950962710234e-16,7.65580174507929e-16,-10.944871697898266]],[14,"Bip001 L Foot",9,[[6,"Bip001 L Toe0",-29,[1,"1exRZapZNcwIBXxb/0W5eY",1,0],[1,0.13152936100959778,0.11558839678764343,-1.4901161193847656e-8],[3,-0.008638708737303427,0.00863873947094798,0.7070540095677645,0.7070540095677645],[1,-89.99999875475658,90.0000012452424,88.60000000522456]]],[1,"4aHFl3fHlbuaL6RN8JRXeO",1,0],[1,0.4661397933959961,1.4901161193847656e-8,2.7755575615628914e-17],[3,0.9987407161553962,0.006006529921066466,-0.01697614202145063,-0.046826425165511394],[1,-174.64423896868865,1.9111731418192246,0.7785473263659639]],[7,"Bip001 R Thigh",4,[-30],[1,"98ubztsaReB4SM5j0C+9XQ",1,0],[1,-0.007351571694016457,0.006541728973388672,-0.13554713129997253],[3,0.02536777561468011,0.042863532364716884,0.7657592200826986,0.6411957660589462],[1,-169.22830858380843,174.78115939262284,79.79425420282486]],[7,"Bip001 R Calf",11,[-31],[1,"daFSmgldhVHZr6ed1FMbc2",1,0],[1,0.667913556098938,-2.7755575615628914e-17,2.9802322387695312e-8],[3,-2.779450550826024e-17,9.201456661039556e-19,-0.09536687845953706,0.995442192441572],[1,-3.2189959742186506e-15,-2.0246747923220863e-16,-10.944872547780557]],[14,"Bip001 R Foot",12,[[6,"Bip001 R Toe0",-32,[1,"d2NS0Sd+lc/qOaGqu0ryVu",1,0],[1,0.13152936100959778,0.11558838188648224,-1.4901161193847656e-8],[3,0.008638708737303427,-0.00863873947094798,0.7070540095677645,0.7070540095677645],[1,89.99999875475658,-90.0000012452424,88.60000000522456]]],[1,"9eM/tvRn9fvLFlTT7ESNOv",1,0],[1,0.4661397933959961,0,-2.9802322387695312e-8],[3,0.9987407144373609,0.006006534567346813,0.016976231399213774,0.04682642881025074],[1,174.64423862852755,-1.9111833471561586,0.7785483437149364]],[7,"Bip001 Neck1",5,[-33],[1,"afjViuGxNakYmIONA9A7ZA",1,0],[1,0.22764748334884644,0,1.8435457604937255e-9],[3,-0.0000026654889098749952,0.000004630969749150401,-0.7071069003857348,0.7071066619671517],[1,0,0.00043196104092464374,-90]],[7,"Bip001 Neck2",14,[-34],[1,"67sWnaBDZcZIOZiwUDQXR8",1,0],[1,0.3070821762084961,-0.00020182132720947266,-4.199591785436496e-10],[3,-4.569298452752026e-7,-0.0000010582180974791515,-0.08715570552516055,0.9961947013476246],[1,-0.00006369751454585079,-0.0001272988736324793,-9.999995718259875]],[7,"Bip001 Neck3",15,[2],[1,"46CRa2+nVSU7GAYxzrvj3h",1,0],[1,0.2573540210723877,-0.0001957416534423828,-1.0545591067057103e-9],[3,0.0000015830806458502071,-0.0000026928886834355856,0.1305262113000271,0.9914448588569629],[1,0.00022789927277829786,-0.0003412485708389339,15.000002204688592]],[7,"Bip001 L Clavicle",5,[-35],[1,"23P11ouaBeNaOziPbu7lTO",1,0],[1,-0.11201411485671997,-0.08999741077423096,0.10659269988536835],[3,0.5995536471749696,0.10547037466949456,0.7813563379675971,-0.1374543463995759],[1,-160.67440442491954,-104.13681493443396,-5.06761835750432]],[7,"Bip001 L UpperArm",17,[-36],[1,"98Sz/NQqJWj6c2DtnFVTQ6",1,0],[1,0.148685485124588,2.220446049250313e-16,2.7755575615628914e-17],[3,0.6768576592153223,-0.05294709722558723,0.07699565691071343,0.7301588750907755],[1,85.8751213326478,-10.468842676701874,2.336185274871858]],[7,"Bip001 L Forearm",18,[-37],[1,"62LM705PxVL7yWO1SbD16v",1,0],[1,0.20733222365379333,0,-1.1920928955078125e-7],[3,-3.4350338633823554e-18,9.825177174135079e-18,0.3300270242447469,0.9439714843511731],[1,-9.501113700203277e-16,1.52488165384648e-15,38.54083152151289]],[7,"Bip001 L Hand",19,[-38],[1,"cfy2dsSI5clai71SmRD+gt",1,0],[1,0.22722017765045166,1.4901161193847656e-8,1.1920928955078125e-7],[3,0.005361270470880891,-0.003487623196326396,-0.11797415870719775,0.9929960680388957],[1,0.5790368821413306,-0.3336672155888319,-13.55231738015595]],[7,"Bip001 L Finger0",20,[-39],[1,"a0kNa6alVRtb1xwMgM02q9",1,0],[1,0.34348487854003906,-1.1175870895385742e-8,0],[3,-0.0003921142787962037,-0.00006913842677759943,-0.1736481789614351,0.9848076722942647],[1,-0.048554295186474965,-0.016606331514334754,-19.999995140234756]],[14,"Bip001 L Finger01",21,[[6,"Bip001 L Finger02",-40,[1,"c5UNlN9WpelrcAagNMgB3X",1,0],[1,0.3262892961502075,-4.470348358154297e-8,2.220446049250313e-16],[3,-9.249915348858104e-10,-1.0840800562367162e-10,0.11640220969456343,0.993202157457495],[1,-1.0672169928760527e-7,-7.610714278330366e-16,13.369017926888654]]],[1,"d8KrAf/ApRq4ueboGh7Kiw",1,0],[1,0.23077142238616943,0,0],[3,3.916782039768282e-9,-1.4163511582992378e-9,0.11640220969456343,0.993202157457495],[1,4.776142253299043e-7,-2.193886077792847e-7,13.369017926888654]],[7,"Bip001 R Clavicle",5,[-41],[1,"badzM6Hqlb27spngOq5m5/",1,0],[1,-0.11201351881027222,-0.08999669551849365,-0.10659399628639221],[3,-0.5995562764385542,-0.10547293884070662,0.7813543200880798,-0.13745238097295803],[1,160.67429869662922,104.13649568648655,-5.067201018483602]],[7,"Bip001 R UpperArm",23,[-42],[1,"79MDogfrxY4pizj38cH188",1,0],[1,0.14868545532226562,2.220446049250313e-16,1.4901161193847656e-8],[3,-0.6768584984316969,0.052950271544657895,0.07699113494868529,0.7301583437744505],[1,-85.87517376343968,10.468755495047693,2.3355504078641744]],[7,"Bip001 R Forearm",24,[-43],[1,"b72NXmqyBRSqNZecSkl4t2",1,0],[1,0.20733219385147095,-2.7755575615628914e-17,1.1920928955078125e-7],[3,-7.695128976785288e-18,9.850361528872603e-19,0.3300270773573828,0.943971465782173],[1,-1.1118424875021456e-15,5.082939182817443e-16,38.54083796901678]],[7,"Bip001 R Hand",25,[-44],[1,"8df/WULSJXH4ndqHq46j6Q",1,0],[1,0.22722017765045166,2.7755575615628914e-17,-1.1920928955078125e-7],[3,-0.00536126909286529,0.00348761901771416,-0.1179741293222698,0.9929960715521252],[1,-0.5790367849833785,0.33366676089575653,-13.55231398635651]],[7,"Bip001 R Finger0",26,[-45],[1,"33XcvF5phc+IlA2P543Z0E",1,0],[1,0.3434847593307495,3.725290298461914e-9,1.1920928955078125e-7],[3,0.0003921099734592463,0.000069135407613098,-0.17364815005809198,0.9848076773926302],[1,0.04855371317484482,0.01660587607116881,-19.999991777283306]],[14,"Bip001 R Finger01",27,[[6,"Bip001 R Finger02",-46,[1,"ec0i50qEBURauM08B13c/7",1,0],[1,0.32628965377807617,7.450580596923828e-8,-1.1920928955078125e-7],[3,3.243936652636153e-18,2.126782492110894e-18,0.11640221704419262,0.9932021565961265],[1,3.503257335078032e-16,2.0432157548678967e-16,13.369018774858489]]],[1,"d0xrCNmzhYj5mJfGfYioBX",1,0],[1,0.23077142238616943,-2.9802322387695312e-8,1.1920928955078125e-7],[3,-3.6999665836324554e-9,-4.336320502502623e-10,0.11640220969456343,0.993202157457495],[1,-4.268868487206369e-7,-2.0263625574909182e-16,13.369017926888654]],[7,"Bip001 Tail",3,[-47],[1,"74qcjuzehSf5BUatpViYMH",1,0],[1,-0.13302025198936462,1.881728195485266e-7,0.055188775062561035],[3,0.00028152588657601635,0.7071057416663604,0.7071077086195986,-0.00028152510077260974],[1,-90.00015937922115,-179.9543768396282,2.176542928445588e-10]],[119,"Bip001 Tail02",29,[[47,"Bip001 Tail03",-48,[1,"e1NdgXAPpT3pWeZaVw/WW/",1,0],[1,0.19411420822143555,-0.00015807151794433594,-4.388311936054379e-10]]],[1,"11e4xaYaxdEodwfLk3pWmV",1,0],[1,0.16504977643489838,-0.00015473365783691406,-4.2882675188593566e-10]]],0,[0,10,1,0,0,1,0,-1,6,0,-2,3,0,10,1,0,1,1,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,3,0,-2,7,0,-3,29,0,-1,8,0,-2,11,0,-3,5,0,-1,14,0,-2,17,0,-3,23,0,0,6,0,-1,9,0,-1,10,0,1,10,0,-1,12,0,-1,13,0,1,13,0,-1,15,0,-1,16,0,-1,18,0,-1,19,0,-1,20,0,-1,21,0,-1,22,0,1,22,0,-1,24,0,-1,25,0,-1,26,0,-1,27,0,-1,28,0,1,28,0,-1,30,0,1,30,0,16,1,2,1,16,4,1,7,48],[0,0,0,0,0,0],[-1,-2,-3,-4,14,19],[27,27,27,81,82,83]],[[[66,"Skin-0",1239566898,["Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Neck3/Bip001 Head","Bip001/Bip001 Pelvis/Bip001 Spine","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Neck3/Bip001 Head/Bip001 Mouth","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Neck1","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Neck1/Bip001 Neck2","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Neck3","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 L Clavicle","Bip001/Bip001 Pelvis","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Neck3/Bip001 Head/Bip001 L_lips_point","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Neck3/Bip001 Head/Bip001 eyelid_L_up","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Neck3/Bip001 Head/Bip001 eyelid_L_down","Bip001/Bip001 Tail","Bip001/Bip001 Tail/Bip001 Tail02","Bip001/Bip001 Tail/Bip001 Tail02/Bip001 Tail03","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L Foot","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L Foot/Bip001 L Toe0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Neck3/Bip001 Head/Bip001 eye_L","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger0/Bip001 L Finger01","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger0/Bip001 L Finger01/Bip001 L Finger02","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 R Clavicle","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Neck3/Bip001 Head/Bip001 L_lips_pointOpp","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Neck3/Bip001 Head/Bip001 eyelid_R_up","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Neck3/Bip001 Head/Bip001 eyelid_R_down","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R Foot","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R Foot/Bip001 R Toe0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Neck3/Bip001 Head/Bip001 eye_R","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger0/Bip001 R Finger01","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger0/Bip001 R Finger01/Bip001 R Finger02"],[[[7,0.0000030424041597143514,-0.000004132580670557218,1,0,-1,-1.2573040698848903e-11,0.0000030424041597143514,0,6.123234262925839e-17,-1,-0.000004132580670557218,0,-0.2398141473531723,2.2034265995025635,0.0000015171889344856027,1],[7,0.000001930401822392014,-0.00000832868227007566,1,0,-0.9999971389770508,0.0023888333234936,0.0000019502922441461124,0,-0.0023888335563242435,-0.999997079372406,-0.000008324048394570127,0,0.027361053973436356,1.2663922309875488,0.000010507958904781844,1],[7,0.000002283533603986143,-0.000004794641426997259,1,0,-0.96571946144104,0.25958818197250366,0.0000034498850709496764,0,-0.25958818197250366,-0.96571946144104,-0.000004037500275444472,0,0.15515349805355072,2.2151544094085693,0.0000013020177220823825,1],[7,0.000005444416274258401,-0.000008405558219237719,1,0,0.3397749066352844,-0.9405069351196289,-0.000009755360224517062,0,0.9405068755149841,0.3397749364376068,-0.0000022645131139142904,0,-1.0917065143585205,-0.9313760995864868,-0.000002709541149670258,1],[7,0.00000900934355740901,-0.000008058368621277623,1,0,0.4979301691055298,-0.8672171831130981,-0.000011474379789433442,0,0.8672171831130981,0.4979301691055298,-0.000003800553031396703,0,-1.215841293334961,-1.1599246263504028,-8.908377253646904e-7,1],[7,9.581116273693624e-7,-0.000008338747647940181,1,0,-0.9405069947242737,-0.33977460861206055,-0.0000019321842046338134,0,0.33977463841438293,-0.9405069351196289,-0.000008168191925506108,0,-0.7037283778190613,1.09170663356781,0.000009172928002953995,1],[7,0.000012369667274469975,-0.000007679476766497828,1,0,0.2565113306045532,-0.9665413498878479,-0.000010595489584375173,0,0.9665412902832031,0.2565113604068756,-0.000009985920769395307,0,-1.7231574058532715,-0.7389211654663086,0.000010823569937201682,1],[7,0.9960461258888245,0.07587630301713943,0.04620738327503204,0,0.07887280732393265,-0.9946370124816895,-0.06690642982721329,0,0.04088296368718147,0.07028640061616898,-0.996688723564148,0,-0.29369306564331055,-0.22712749242782593,1.2888065576553345,1],[7,0.9659253358840942,0.0000055422333389287814,0.2588210105895996,0,0.25882068276405334,-0.0015925184125080705,-0.965924084186554,0,0.00040682387771084905,0.9999986886978149,-0.0015396883245557547,0,-0.06337890774011612,-1.3126951456069946,-0.17528468370437622,1],[7,0.0000013868000223737909,0.0000027577070795814507,1,0,6.123234262925839e-17,-1,0.0000027577070795814507,0,1,-3.8243271396898315e-12,-0.0000013868001360606286,0,-1.2599310874938965,0.03170290216803551,0.0000016598452248217654,1],[7,0.9703902006149292,-0.0007747258641757071,0.24154186248779297,0,-0.241541787981987,0.0001896858011605218,0.9703904986381531,0,-0.0007976036868058145,-0.9999996423721313,-0.0000030594369491154794,0,-0.17158611118793488,2.203066110610962,0.42304059863090515,1],[7,0.8572441935539246,0.4451356828212738,0.2588178515434265,0,-0.22932744026184082,-0.11998414993286133,0.965925931930542,0,0.46102210879325867,-0.887388288974762,-0.0007738911081105471,0,-1.1626179218292236,1.9341028928756714,0.3195762634277344,1],[7,0.8575078248977661,-0.44462910294532776,0.2588152289390564,0,-0.23013357818126678,0.1184248998761177,0.9659265875816345,0,-0.4601292610168457,-0.8878515958786011,-0.0007738028652966022,0,0.9120217561721802,2.064134120941162,0.3195764422416687,1],[7,-0.0000013709064887734712,-0.000002772508651105454,1,0,0.9999997019767761,-0.0007962742820382118,0.0000013686983493244043,0,0.0007962743402458727,0.9999996423721313,0.000002773599590000231,0,-0.16577030718326569,-1.3149882555007935,-0.000003878886673192028,1],[7,-0.0000013709064887734712,-0.000002772508651105454,1,0,0.9999997019767761,-0.0007962742820382118,0.0000013686983493244043,0,0.0007962743402458727,0.9999996423721313,0.000002773599590000231,0,-0.33082008361816406,-1.314833641052246,-0.000003878457846440142,1],[7,-0.0000013709064887734712,-0.000002772508651105454,1,0,0.9999997019767761,-0.0007962742820382118,0.0000013686983493244043,0,0.0007962743402458727,0.9999996423721313,0.000002773599590000231,0,-0.5249342322349548,-1.3146754503250122,-0.000003878019015246537,1],[7,0.016124535351991653,-0.0981796458363533,0.9950380325317383,0,0.17879940569400787,0.9794098138809204,0.09374018013477325,0,-0.9837534427642822,0.17640069127082825,0.033346988260746,0,1.231607437133789,-0.23999500274658203,-0.179861381649971,1],[7,0.03447207435965538,-0.09333253651857376,0.9950380325317383,0,-0.010407977737486362,0.9955422878265381,0.09374039620161057,0,-0.9993515014648438,-0.013587758876383305,0.033347003161907196,0,0.5990071296691895,-0.12860408425331116,-0.1798614263534546,1],[7,4.371138828673793e-8,0.000001370906943520822,-1,0,-6.123234262925839e-17,-1,-0.000001370906943520822,0,-1,5.998547741425247e-14,-4.371139183945161e-8,0,0.13703155517578125,0.14627376198768616,0.16238602995872498,1],[7,0.024433551356196404,-4.3711402497592644e-8,-0.9997015595436096,0,-0.9997015595436096,-4.371144868287047e-8,-0.024433551356196404,0,-4.263037922669355e-8,1,-4.476638082451245e-8,0,0.026708750054240227,-0.005502187181264162,0.16308726370334625,1],[7,0.9659262895584106,-0.000771219318266958,0.25881654024124146,0,-0.2588164508342743,0.00020345357188489288,0.9659265875816345,0,-0.0007975983899086714,-0.9999996423721313,-0.000003083108140344848,0,-0.13823232054710388,2.252650022506714,0.3178403079509735,1],[7,0.8263481855392456,-0.5612609386444092,0.04620740935206413,0,-0.5580392479896545,-0.8271130323410034,-0.0669063925743103,0,0.07577069848775864,0.029502427205443382,-0.996688723564148,0,-0.5334008932113647,0.13452394306659698,1.2888065576553345,1],[7,0.9351096749305725,-0.35149654746055603,0.04494882747530937,0,-0.34905096888542175,-0.9355349540710449,-0.05420380085706711,0,0.06110365316271782,0.03499706834554672,-0.9975176453590393,0,-0.7636570930480957,-0.03262715041637421,1.293609857559204,1],[7,0.9989467859268188,-0.010505893267691135,0.04466891288757324,0,-0.008043651469051838,-0.9984568953514099,-0.05494876950979233,0,0.04517727345228195,0.05453159660100937,-0.9974894523620605,0,-1.02886164188385,-0.4102923274040222,1.293583631515503,1],[7,0.9694471955299377,-0.24119950830936432,0.04466891288757324,0,-0.23869074881076813,-0.9695398807525635,-0.05494876578450203,0,0.0565619133412838,0.0426078699529171,-0.9974894523620605,0,-1.3203669786453247,-0.1079191043972969,1.2935835123062134,1],[7,0.8874055743217468,-0.458820641040802,0.044668909162282944,0,-0.4564013183116913,-0.8880758881568909,-0.05494876950979233,0,0.06488101929426193,0.028374895453453064,-0.9974894523620605,0,-1.6269869804382324,0.27574828267097473,1.2935835123062134,1],[7,-0.01612519659101963,0.0981769934296608,0.9950383305549622,0,0.17879937589168549,0.9794101119041443,-0.09373744577169418,0,-0.9837534427642822,0.17640069127082825,-0.03334716334939003,0,1.231607437133789,-0.23999500274658203,0.17986151576042175,1],[7,-0.9960463643074036,-0.07587357610464096,0.04620720073580742,0,0.07887007296085358,-0.9946371912956238,0.06690655648708344,0,0.040882959961891174,0.07028639316558838,0.996688723564148,0,-0.2936924397945404,-0.22712792456150055,-1.2888092994689941,1],[7,-0.9659263491630554,0.000005564841558225453,0.25881728529930115,0,0.2588169574737549,-0.0015925185289233923,0.9659250974655151,0,0.000417546572862193,0.9999986886978149,0.0015368153108283877,0,-0.06339242309331894,-1.3126952648162842,0.17528831958770752,1],[7,-0.8263466358184814,0.5612632036209106,0.04620722681283951,0,-0.558041512966156,-0.827111542224884,0.06690651923418045,0,0.07577069848775864,0.029502427205443382,0.996688723564148,0,-0.5334007143974304,0.13452324271202087,-1.2888092994689941,1],[7,-0.9703888297080994,0.0007706669275648892,0.24154716730117798,0,-0.24154707789421082,0.0001950729638338089,-0.970389187335968,0,-0.0007949661812745035,-0.9999996423721313,-0.000003144270976918051,0,-0.17157705128192902,2.203068494796753,-0.4230306148529053,1],[7,-0.857241690158844,-0.4451388716697693,0.25882065296173096,0,-0.2293321192264557,-0.11998122185468674,-0.9659251570701599,0,0.4610244333744049,-0.8873870968818665,0.000768264988437295,0,-1.1598045825958252,1.9355660676956177,-0.31953006982803345,1],[7,-0.8575078248977661,0.4446246027946472,0.2588229775428772,0,-0.23013824224472046,0.11843268573284149,-0.9659245610237122,0,-0.4601269066333771,-0.8878527879714966,0.0007681744173169136,0,0.9148365259170532,2.0626771450042725,-0.31952956318855286,1],[7,-0.03447222337126732,0.09332985430955887,0.9950382709503174,0,-0.010408071801066399,0.9955425262451172,-0.09373772144317627,0,-0.9993515014648438,-0.013587778434157372,-0.03334718197584152,0,0.5990070700645447,-0.12860406935214996,0.17986156046390533,1],[7,4.371138828673793e-8,0.000001370906943520822,-1,0,-6.123234262925839e-17,-1,-0.000001370906943520822,0,-1,5.998547741425247e-14,-4.371139183945161e-8,0,0.13703155517578125,0.14627376198768616,-0.16238611936569214,1],[7,-0.024430807679891586,4.3711395392165286e-8,-0.9997015595436096,0,-0.9997015595436096,-4.371132789060539e-8,0.024430807679891586,0,-4.263037922669355e-8,1,4.4766252926820016e-8,0,0.026708759367465973,-0.005502187181264162,-0.16308735311031342,1],[7,-0.9659249186515808,0.0007670645136386156,0.2588218152523041,0,-0.2588217258453369,0.0002088159235427156,-0.9659252166748047,0,-0.0007949730497784913,-0.9999996423721313,-0.000003167551994920359,0,-0.13506197929382324,2.2526490688323975,-0.3177923560142517,1],[7,-0.9351087212562561,0.35149917006492615,0.044948678463697433,0,-0.34905359148979187,-0.9355340003967285,0.054203931242227554,0,0.06110365688800812,0.03499707207083702,0.9975176453590393,0,-0.7636567950248718,-0.03262774273753166,-1.2936127185821533,1],[7,-0.9989467859268188,0.010508663952350616,0.044668760150671005,0,-0.008046424016356468,-0.9984568953514099,0.054948896169662476,0,0.04517727717757225,0.05453159660100937,0.9974894523620605,0,-1.0288610458374023,-0.41029274463653564,-1.2935863733291626,1],[7,-0.9694465398788452,0.2412022203207016,0.044668760150671005,0,-0.2386934608221054,-0.969539225101471,0.054948896169662476,0,0.056561920791864395,0.0426078736782074,0.9974894523620605,0,-1.3203665018081665,-0.10791964828968048,-1.2935863733291626,1],[7,-0.8874043226242065,0.45882314443588257,0.044668760150671005,0,-0.45640379190444946,-0.8880746364593506,0.054948896169662476,0,0.06488101929426193,0.028374899178743362,0.9974894523620605,0,-1.6269866228103638,0.2757476270198822,-1.2935863733291626,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[28,".bin",2022797851,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":137984,"length":13896,"count":6948,"stride":2}},{"primitiveMode":7,"jointMapIndex":1,"vertexBundelIndices":[1],"indexView":{"offset":290040,"length":14184,"count":7092,"stride":2}},{"primitiveMode":7,"jointMapIndex":2,"vertexBundelIndices":[2],"indexView":{"offset":431032,"length":12276,"count":6138,"stride":2}},{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[3],"indexView":{"offset":462844,"length":4800,"count":1200,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":137984,"count":1568,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":151880,"length":138160,"count":1570,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":304224,"length":126808,"count":1441,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":443308,"length":19536,"count":222,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,26,28,36],[0,1,2,3,4,5,6,7,8,9,13,14,15,16,19,21,22,23,24,25,26,27,28,30,31,32,33,34],[0,1,2,9,13,14,15,27,28,29,30,31,32,33,34,35,37,38,39,40]]},"minPosition",8,[1,-2.100203037261963,-0.7660994529724121,-1.1920928955078125e-7],"maxPosition",8,[1,2.100203037261963,0.7660994529724121,2.3443918228149414]]],-1],0,0,[],[],[]],[[[25,"VD295_Flamingo_Eye",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"albedoScale":1,"metallic":0,"roughness":0,"emissiveScale":1,"alphaSource":1},"mainColor",8,[4,4286545791],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[15,12],[84,5]],[[[25,"VD295_Flamingo_Toy",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"albedoScale":1,"metallic":0,"roughness":0,"emissiveScale":1,"alphaSource":1},"mainColor",8,[4,4286545791],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[15,12],[85,5]],[[[94,"builtin-standard",[{"hash":4079105024,"name":"builtin-standard|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"metallicRoughnessMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"samplers":[],"textures":[],"buffers":[{"name":"b_ccLightsBuffer","memoryAccess":1,"stageFlags":16,"binding":7,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightIndicesBuffer","memoryAccess":1,"stageFlags":16,"binding":8,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightGridBuffer","memoryAccess":1,"stageFlags":16,"binding":9,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]},{"name":"a_color","format":44,"location":14,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":15,"defines":[]}],"varyings":[{"name":"v_fog_factor","type":13,"count":1,"stageFlags":17,"location":0,"defines":["!CC_USE_ACCURATE_FOG"]},{"name":"v_shadowPos","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_color","type":16,"count":1,"stageFlags":17,"location":2,"defines":["USE_VERTEX_COLOR"]},{"name":"v_position","type":15,"count":1,"stageFlags":17,"location":3,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":17,"location":4,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":5,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":6,"defines":["HAS_SECOND_UV"]},{"name":"v_shadowBias","type":14,"count":1,"stageFlags":17,"location":7,"defines":["CC_RECEIVE_SHADOW"]},{"name":"v_tangent","type":16,"count":1,"stageFlags":17,"location":8,"defines":["USE_NORMAL_MAP"]},{"name":"v_luv","type":15,"count":1,"stageFlags":17,"location":9,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":["CC_FORWARD_ADD"]},{"name":"fragColor0","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor1","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor2","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) out float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nlayout(location = 1) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  layout(location = 14) in vec4 a_color;\n  layout(location = 2) out lowp vec4 v_color;\n#endif\nlayout(location = 3) out vec3 v_position;\nlayout(location = 4) out mediump vec3 v_normal;\nlayout(location = 5) out vec2 v_uv;\n#if HAS_SECOND_UV\n  layout(location = 6) out mediump vec2 v_uv1;\n#endif\n#if CC_RECEIVE_SHADOW\n  layout(location = 7) out mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 8) out mediump vec4 v_tangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  layout(location = 15) in vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_tangent.w = In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) in float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(normalBias > EPSILON_LOWP)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n  }else {\n    return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n  }\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\n  float realtimeShadow = 1.0;\n  vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n  }else {\n    realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n  }\n  return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\n  layout(set = 0, binding = 4) uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    layout(set = 0, binding = 6) uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse / PI;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > EPSILON_LOWP) {\n      finalColor = diffuse * s.lightmap.rgb * shadow;\n    }\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nlayout(location = 1) in highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) in vec3 v_luv;\n  layout(set = 2, binding = 10) uniform sampler2D cc_lightingMap;\n#endif\nlayout(location = 3) in vec3 v_position;\nlayout(location = 5) in vec2 v_uv;\n#if HAS_SECOND_UV\n  layout(location = 6) in mediump vec2 v_uv1;\n#endif\nlayout(location = 4) in mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  layout(location = 7) in mediump vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\n  layout(location = 2) in lowp vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 8) in mediump vec4 v_tangent;\n  layout(set = 1, binding = 2) uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  layout(set = 1, binding = 3) uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  layout(set = 1, binding = 4) uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  layout(set = 1, binding = 5) uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  layout(set = 1, binding = 6) uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    vec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.specularIntensity = 0.5;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(set = 2, binding = 1) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(set = 1, binding = 7) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(set = 1, binding = 8) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(set = 1, binding = 9) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    fragColor2 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out lowp vec4 v_color;\n#endif\nout vec3 v_position;\nout mediump vec3 v_normal;\nout vec2 v_uv;\n#if HAS_SECOND_UV\n  out mediump vec2 v_uv1;\n#endif\n#if CC_RECEIVE_SHADOW\n  out mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  out mediump vec4 v_tangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_tangent.w = In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(normalBias > EPSILON_LOWP)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n  }else {\n    return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n  }\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\n  float realtimeShadow = 1.0;\n  vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n  }else {\n    realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n  }\n  return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse / PI;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > EPSILON_LOWP) {\n      finalColor = diffuse * s.lightmap.rgb * shadow;\n    }\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nin highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  in vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\nin vec3 v_position;\nin vec2 v_uv;\n#if HAS_SECOND_UV\n  in mediump vec2 v_uv1;\n#endif\nin mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  in mediump vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  in mediump vec4 v_tangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    vec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.specularIntensity = 0.5;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(std140) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    fragColor2 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  uniform highp vec4 cc_localShadowBias;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying lowp vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying mediump vec3 v_normal;\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  varying mediump vec4 v_tangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_tangent.w = In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp mat4 cc_matView;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n  uniform mediump vec4 cc_viewPort;\n     uniform vec4 albedo;\n     uniform vec4 albedoScaleAndCutoff;\n     uniform vec4 pbrParams;\n     uniform vec4 emissive;\n     uniform vec4 emissiveScaleParam;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(normalBias > EPSILON_LOWP)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n  }else {\n    return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n  }\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\n  float realtimeShadow = 1.0;\n  vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n  }else {\n    realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n  }\n  return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DLodEXT(tex, coord, lod);\n      #else\n        return texture2D(tex, coord, lod);\n      #endif\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return textureCubeLodEXT(tex, coord, lod);\n      #else\n        return textureCube(tex, coord, lod);\n      #endif\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = textureCube(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse / PI;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > EPSILON_LOWP) {\n      finalColor = diffuse * s.lightmap.rgb * shadow;\n    }\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = textureCube(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nvarying highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\nvarying mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  varying mediump vec4 v_tangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    vec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture2D(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture2D(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture2D(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.specularIntensity = 0.5;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  void main () {\n    StandardSurface s; surf(s);\n    gl_FragData[0] = s.albedo;\n    gl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    gl_FragData[2] = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","defines":["CC_USE_IBL"]},{"name":"cc_diffuseMap","defines":["CC_USE_DIFFUSEMAP"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":223,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":75}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean","defines":[]},{"name":"USE_VERTEX_COLOR","type":"boolean","defines":[]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"USE_NORMAL_MAP","type":"boolean","defines":[]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"USE_TWOSIDE","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":[]},{"name":"CC_USE_IBL","type":"number","defines":[],"range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","defines":[],"range":[0,2]},{"name":"USE_REFLECTION_DENOISE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"NORMAL_UV","type":"string","defines":["USE_NORMAL_MAP"],"options":["v_uv","v_uv1"]},{"name":"PBR_UV","type":"string","defines":[],"options":["v_uv","v_uv1"]},{"name":"USE_PBR_MAP","type":"boolean","defines":[]},{"name":"USE_METALLIC_ROUGHNESS_MAP","type":"boolean","defines":[]},{"name":"USE_OCCLUSION_MAP","type":"boolean","defines":[]},{"name":"USE_EMISSIVE_MAP","type":"boolean","defines":[]},{"name":"EMISSIVE_UV","type":"string","defines":["USE_EMISSIVE_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]},{"name":"CC_PIPELINE_TYPE","type":"number","defines":["CC_FORWARD_ADD"],"range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean","defines":["CC_FORWARD_ADD"]}]},{"hash":3928335406,"name":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]},{"name":"a_texCoord1","format":21,"location":14,"defines":[]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":1,"defines":["HAS_SECOND_UV"]},{"name":"v_worldPos","type":16,"count":1,"stageFlags":17,"location":2,"defines":[]},{"name":"v_clip_depth","type":13,"count":1,"stageFlags":17,"location":3,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  layout(location = 14) in vec2 a_texCoord1;\n#endif\nlayout(location = 0) out vec2 v_uv;\n#if HAS_SECOND_UV\n  layout(location = 1) out vec2 v_uv1;\n#endif\nlayout(location = 2) out vec4 v_worldPos;\nlayout(location = 3) out float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\nlayout(location = 0) in vec2 v_uv;\n#if HAS_SECOND_UV\n  layout(location = 1) in vec2 v_uv1;\n#endif\nlayout(location = 2) in vec4 v_worldPos;\nlayout(location = 3) in float v_clip_depth;\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\n#if HAS_SECOND_UV\n  out vec2 v_uv1;\n#endif\nout vec4 v_worldPos;\nout float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nin vec2 v_uv;\n#if HAS_SECOND_UV\n  in vec2 v_uv1;\n#endif\nin vec4 v_worldPos;\nin float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying vec2 v_uv1;\n#endif\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n   uniform vec4 albedo;\n   uniform vec4 albedoScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying vec2 v_uv1;\n#endif\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture2D(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":184,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":75}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]}]}],[{"name":"opaque","passes":[{"program":"builtin-standard|standard-vs|standard-fs","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"specularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"normalStrength":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,5]},"handleInfo":["emissiveScaleParam",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]},{"name":"transparent","passes":[{"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"specularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"normalStrength":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,5]},"handleInfo":["emissiveScaleParam",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]}]]],0,0,[],[],[]],[[{"name":"default_btn_normal","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"packable":true}],[0],0,[0],[3],[86]],[[{"name":"UI_Rotate_Left","rect":{"x":45,"y":29,"width":167,"height":198},"offset":{"x":0.5,"y":0},"originalSize":{"width":256,"height":256},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[87]],[[[25,"Food_AssetsA",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"albedoScale":0.5,"metallic":0,"roughness":0.5,"emissiveScale":1,"alphaSource":1},"mainColor",8,[4,4286545791],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[15,12],[88,5]],[[[28,".bin",1642054354,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":9744,"length":3420,"count":855,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":9744,"count":203,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.4428846836090088,-1.2968734502792358,-1.911558747291565],"maxPosition",8,[1,1.4428846836090088,1.2968732118606567,1.911558747291565]]],-1],0,0,[],[],[]],[[{"name":"UI_Customization_Panel","rect":{"x":0,"y":0,"width":2732,"height":432},"offset":{"x":0,"y":0},"originalSize":{"width":2732,"height":432},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[89]],[[[94,"dcc/imported-metallic-roughness",[{"hash":1794525484,"name":"dcc/imported-metallic-roughness|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"occlusion","type":13,"count":1},{"name":"roughness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalStrength","type":13,"count":1},{"name":"alphaSource","type":13,"count":1},{"name":"albedoScale","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"baseWeightMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_WEIGHT_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_NORMAL_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_MAP"]},{"name":"roughnessMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_OCCLUSION_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"transparencyColorMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_TRANSPARENCYCOLOR_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["USE_EMISSIVESCALE_MAP"]},{"name":"alphaSourceMap","type":28,"count":1,"stageFlags":16,"binding":11,"defines":["USE_OPACITY_MAP"]}],"samplers":[],"textures":[],"buffers":[{"name":"b_ccLightsBuffer","memoryAccess":1,"stageFlags":16,"binding":12,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightIndicesBuffer","memoryAccess":1,"stageFlags":16,"binding":13,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightGridBuffer","memoryAccess":1,"stageFlags":16,"binding":14,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]},{"name":"a_color","format":44,"location":14,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":15,"defines":[]}],"varyings":[{"name":"v_fog_factor","type":13,"count":1,"stageFlags":17,"location":0,"defines":["!CC_USE_ACCURATE_FOG"]},{"name":"v_shadowPos","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_color","type":16,"count":1,"stageFlags":17,"location":2,"defines":["USE_VERTEX_COLOR"]},{"name":"v_position","type":15,"count":1,"stageFlags":17,"location":3,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":17,"location":4,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":5,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":6,"defines":[]},{"name":"v_shadowBias","type":14,"count":1,"stageFlags":17,"location":7,"defines":["CC_RECEIVE_SHADOW"]},{"name":"v_tangent","type":15,"count":1,"stageFlags":17,"location":8,"defines":["USE_NORMAL_MAP"]},{"name":"v_bitangent","type":15,"count":1,"stageFlags":17,"location":9,"defines":["USE_NORMAL_MAP"]},{"name":"v_luv","type":15,"count":1,"stageFlags":17,"location":10,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":["CC_FORWARD_ADD"]},{"name":"fragColor0","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor1","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor2","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 emissive;\n  float emissiveScale;\n  float occlusion;\n  float roughness;\n  float metallic;\n  float normalStrength;\n  float alphaSource;\n  float albedoScale;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) out float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nlayout(location = 1) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  layout(location = 14) in vec4 a_color;\n  layout(location = 2) out vec4 v_color;\n#endif\nlayout(location = 3) out vec3 v_position;\nlayout(location = 4) out vec3 v_normal;\nlayout(location = 5) out vec2 v_uv;\nlayout(location = 6) out vec2 v_uv1;\n#if CC_RECEIVE_SHADOW\n  layout(location = 7) out vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 8) out vec3 v_tangent;\n  layout(location = 9) out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  layout(location = 15) in vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 10) out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 emissive;\n  float emissiveScale;\n  float occlusion;\n  float roughness;\n  float metallic;\n  float normalStrength;\n  float alphaSource;\n  float albedoScale;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) in float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(normalBias > EPSILON_LOWP)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n  }else {\n    return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n  }\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\n  float realtimeShadow = 1.0;\n  vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n  }else {\n    realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n  }\n  return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\n  layout(set = 0, binding = 4) uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    layout(set = 0, binding = 6) uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse / PI;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > EPSILON_LOWP) {\n      finalColor = diffuse * s.lightmap.rgb * shadow;\n    }\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nlayout(location = 1) in highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 10) in vec3 v_luv;\n  layout(set = 2, binding = 10) uniform sampler2D cc_lightingMap;\n#endif\nlayout(location = 3) in vec3 v_position;\nlayout(location = 5) in vec2 v_uv;\nlayout(location = 6) in vec2 v_uv1;\nlayout(location = 4) in vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  layout(location = 7) in vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\n  layout(location = 2) in vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_WEIGHT_MAP\n  layout(set = 1, binding = 2) uniform sampler2D baseWeightMap;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 8) in vec3 v_tangent;\n  layout(location = 9) in vec3 v_bitangent;\n  layout(set = 1, binding = 3) uniform sampler2D normalMap;\n#endif\n#if USE_METALLIC_MAP\n  layout(set = 1, binding = 4) uniform sampler2D metallicMap;\n#endif\n#if USE_ROUGHNESS_MAP\n  layout(set = 1, binding = 5) uniform sampler2D roughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  layout(set = 1, binding = 6) uniform sampler2D occlusionMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  layout(set = 1, binding = 7) uniform sampler2D transparencyMap;\n#endif\n#if USE_TRANSPARENCYCOLOR_MAP\n  layout(set = 1, binding = 8) uniform sampler2D transparencyColorMap;\n#endif\n#if USE_EMISSIVE_MAP\n  layout(set = 1, binding = 9) uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  layout(set = 1, binding = 10) uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_OPACITY_MAP\n  layout(set = 1, binding = 11) uniform sampler2D alphaSourceMap;\n#endif\nfloat discolor(vec3 srcColor) {\n  return dot(GRAY_VECTOR, srcColor);\n}\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, TEXTURE_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor = texColor;\n  #endif\n  #if USE_WEIGHT_MAP\n      vec4 weightColor = texture(baseWeightMap, TEXTURE_UV);\n      weightColor.rgb = SRGBToLinear(weightColor.rgb);\n      baseColor.rgb *= weightColor.rgb;\n  #else\n      baseColor.rgb *= albedoScale;\n  #endif\n  float metallicValue = metallic;\n  #if USE_METALLIC_MAP\n     vec4 metallicColor = texture(metallicMap, TEXTURE_UV);\n     metallicValue = discolor(metallicColor.rgb);\n     #if USE_METALLIC_CHANNEL\n         metallicColor.rgb = SRGBToLinear(metallicColor.rgb);\n         metallicValue = metallicColor.METALLIC_CHANNEL;\n     #endif\n  #endif\n  s.metallic = metallicValue;\n  float roughnessValue = roughness;\n  #if USE_ROUGHNESS_MAP\n     vec4 roughnessColor = texture(roughnessMap, TEXTURE_UV);\n     roughnessValue = discolor(roughnessColor.rgb);\n     #if USE_ROUGHNESS_CHANNEL\n         roughnessColor.rgb = SRGBToLinear(roughnessColor.rgb);\n         roughnessValue = roughnessColor.ROUGHNESS_CHANNEL;\n     #endif\n  #endif\n  s.roughness = max(0.02, roughnessValue);\n  float occlusionValue = occlusion;\n  #if USE_OCCLUSION_MAP\n     vec4 occlusionColor = texture(occlusionMap, TEXTURE_UV);\n     occlusionValue = discolor(occlusionColor.rgb);\n     #if USE_OCCLUSION_CHANNEL\n         occlusionColor.rgb = SRGBToLinear(occlusionColor.rgb);\n         occlusionValue = occlusionColor.OCCLUSION_CHANNEL;\n     #endif\n  #endif\n  s.occlusion = occlusionValue;\n  #if ALPHA_SOURCE_IS_OPACITY\n    #if USE_OPACITY_MAP\n      baseColor.a = 1.0 - texture(alphaSourceMap, TEXTURE_UV).ALPHA_SOURCE_CHANNEL;\n    #else\n      baseColor.a = 1.0 - alphaSource;\n    #endif\n  #else\n    #if USE_OPACITY_MAP\n      baseColor.a = texture(alphaSourceMap, TEXTURE_UV).ALPHA_SOURCE_CHANNEL;\n    #else\n      baseColor.a = alphaSource;\n    #endif\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.a < albedoScaleAndCutoff.w) discard;\n  #endif\n  s.albedo = baseColor;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * normalStrength) * normalize(v_tangent) +\n      (nmmp.y * normalStrength) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  s.specularIntensity = 0.5;\n  vec3 emissiveColor = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n      emissiveColor.rgb = SRGBToLinear(texture(emissiveMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_EMISSIVESCALE_MAP\n      vec4 emissiveScaleColor = texture(emissiveScaleMap, TEXTURE_UV);\n      emissiveScaleColor.rgb = SRGBToLinear(emissiveScaleColor.rgb);\n      emissiveColor.rgb *= emissiveScaleColor.rgb;\n  #else\n      emissiveColor.rgb *= emissiveScale;\n  #endif\n  s.emissive = emissiveColor.rgb;\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(set = 2, binding = 1) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(set = 1, binding = 12) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(set = 1, binding = 13) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(set = 1, binding = 14) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    fragColor2 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 emissive;\n  float emissiveScale;\n  float occlusion;\n  float roughness;\n  float metallic;\n  float normalStrength;\n  float alphaSource;\n  float albedoScale;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out vec4 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_uv;\nout vec2 v_uv1;\n#if CC_RECEIVE_SHADOW\n  out vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 emissive;\n  float emissiveScale;\n  float occlusion;\n  float roughness;\n  float metallic;\n  float normalStrength;\n  float alphaSource;\n  float albedoScale;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(normalBias > EPSILON_LOWP)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n  }else {\n    return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n  }\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\n  float realtimeShadow = 1.0;\n  vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n  }else {\n    realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n  }\n  return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse / PI;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > EPSILON_LOWP) {\n      finalColor = diffuse * s.lightmap.rgb * shadow;\n    }\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nin highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  in vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\nin vec3 v_position;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  in vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_WEIGHT_MAP\n  uniform sampler2D baseWeightMap;\n#endif\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_ROUGHNESS_MAP\n  uniform sampler2D roughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_TRANSPARENCYCOLOR_MAP\n  uniform sampler2D transparencyColorMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_OPACITY_MAP\n  uniform sampler2D alphaSourceMap;\n#endif\nfloat discolor(vec3 srcColor) {\n  return dot(GRAY_VECTOR, srcColor);\n}\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, TEXTURE_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor = texColor;\n  #endif\n  #if USE_WEIGHT_MAP\n      vec4 weightColor = texture(baseWeightMap, TEXTURE_UV);\n      weightColor.rgb = SRGBToLinear(weightColor.rgb);\n      baseColor.rgb *= weightColor.rgb;\n  #else\n      baseColor.rgb *= albedoScale;\n  #endif\n  float metallicValue = metallic;\n  #if USE_METALLIC_MAP\n     vec4 metallicColor = texture(metallicMap, TEXTURE_UV);\n     metallicValue = discolor(metallicColor.rgb);\n     #if USE_METALLIC_CHANNEL\n         metallicColor.rgb = SRGBToLinear(metallicColor.rgb);\n         metallicValue = metallicColor.METALLIC_CHANNEL;\n     #endif\n  #endif\n  s.metallic = metallicValue;\n  float roughnessValue = roughness;\n  #if USE_ROUGHNESS_MAP\n     vec4 roughnessColor = texture(roughnessMap, TEXTURE_UV);\n     roughnessValue = discolor(roughnessColor.rgb);\n     #if USE_ROUGHNESS_CHANNEL\n         roughnessColor.rgb = SRGBToLinear(roughnessColor.rgb);\n         roughnessValue = roughnessColor.ROUGHNESS_CHANNEL;\n     #endif\n  #endif\n  s.roughness = max(0.02, roughnessValue);\n  float occlusionValue = occlusion;\n  #if USE_OCCLUSION_MAP\n     vec4 occlusionColor = texture(occlusionMap, TEXTURE_UV);\n     occlusionValue = discolor(occlusionColor.rgb);\n     #if USE_OCCLUSION_CHANNEL\n         occlusionColor.rgb = SRGBToLinear(occlusionColor.rgb);\n         occlusionValue = occlusionColor.OCCLUSION_CHANNEL;\n     #endif\n  #endif\n  s.occlusion = occlusionValue;\n  #if ALPHA_SOURCE_IS_OPACITY\n    #if USE_OPACITY_MAP\n      baseColor.a = 1.0 - texture(alphaSourceMap, TEXTURE_UV).ALPHA_SOURCE_CHANNEL;\n    #else\n      baseColor.a = 1.0 - alphaSource;\n    #endif\n  #else\n    #if USE_OPACITY_MAP\n      baseColor.a = texture(alphaSourceMap, TEXTURE_UV).ALPHA_SOURCE_CHANNEL;\n    #else\n      baseColor.a = alphaSource;\n    #endif\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.a < albedoScaleAndCutoff.w) discard;\n  #endif\n  s.albedo = baseColor;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * normalStrength) * normalize(v_tangent) +\n      (nmmp.y * normalStrength) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  s.specularIntensity = 0.5;\n  vec3 emissiveColor = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n      emissiveColor.rgb = SRGBToLinear(texture(emissiveMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_EMISSIVESCALE_MAP\n      vec4 emissiveScaleColor = texture(emissiveScaleMap, TEXTURE_UV);\n      emissiveScaleColor.rgb = SRGBToLinear(emissiveScaleColor.rgb);\n      emissiveColor.rgb *= emissiveScaleColor.rgb;\n  #else\n      emissiveColor.rgb *= emissiveScale;\n  #endif\n  s.emissive = emissiveColor.rgb;\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(std140) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    fragColor2 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  uniform highp vec4 cc_localShadowBias;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\n#if CC_RECEIVE_SHADOW\n  varying vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp mat4 cc_matView;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n  uniform mediump vec4 cc_viewPort;\n     uniform vec4 albedo;\n     uniform vec4 albedoScaleAndCutoff;\n     uniform vec4 emissive;\n     uniform float emissiveScale;\n     uniform float occlusion;\n     uniform float roughness;\n     uniform float metallic;\n     uniform float normalStrength;\n     uniform float alphaSource;\n     uniform float albedoScale;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(normalBias > EPSILON_LOWP)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n  }else {\n    return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n  }\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\n  float realtimeShadow = 1.0;\n  vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n  }else {\n    realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n  }\n  return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DLodEXT(tex, coord, lod);\n      #else\n        return texture2D(tex, coord, lod);\n      #endif\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return textureCubeLodEXT(tex, coord, lod);\n      #else\n        return textureCube(tex, coord, lod);\n      #endif\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = textureCube(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse / PI;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > EPSILON_LOWP) {\n      finalColor = diffuse * s.lightmap.rgb * shadow;\n    }\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = textureCube(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nvarying highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  varying vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\n  varying vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_WEIGHT_MAP\n  uniform sampler2D baseWeightMap;\n#endif\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_ROUGHNESS_MAP\n  uniform sampler2D roughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_TRANSPARENCYCOLOR_MAP\n  uniform sampler2D transparencyColorMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_OPACITY_MAP\n  uniform sampler2D alphaSourceMap;\n#endif\nfloat discolor(vec3 srcColor) {\n  return dot(GRAY_VECTOR, srcColor);\n}\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, TEXTURE_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor = texColor;\n  #endif\n  #if USE_WEIGHT_MAP\n      vec4 weightColor = texture2D(baseWeightMap, TEXTURE_UV);\n      weightColor.rgb = SRGBToLinear(weightColor.rgb);\n      baseColor.rgb *= weightColor.rgb;\n  #else\n      baseColor.rgb *= albedoScale;\n  #endif\n  float metallicValue = metallic;\n  #if USE_METALLIC_MAP\n     vec4 metallicColor = texture2D(metallicMap, TEXTURE_UV);\n     metallicValue = discolor(metallicColor.rgb);\n     #if USE_METALLIC_CHANNEL\n         metallicColor.rgb = SRGBToLinear(metallicColor.rgb);\n         metallicValue = metallicColor.METALLIC_CHANNEL;\n     #endif\n  #endif\n  s.metallic = metallicValue;\n  float roughnessValue = roughness;\n  #if USE_ROUGHNESS_MAP\n     vec4 roughnessColor = texture2D(roughnessMap, TEXTURE_UV);\n     roughnessValue = discolor(roughnessColor.rgb);\n     #if USE_ROUGHNESS_CHANNEL\n         roughnessColor.rgb = SRGBToLinear(roughnessColor.rgb);\n         roughnessValue = roughnessColor.ROUGHNESS_CHANNEL;\n     #endif\n  #endif\n  s.roughness = max(0.02, roughnessValue);\n  float occlusionValue = occlusion;\n  #if USE_OCCLUSION_MAP\n     vec4 occlusionColor = texture2D(occlusionMap, TEXTURE_UV);\n     occlusionValue = discolor(occlusionColor.rgb);\n     #if USE_OCCLUSION_CHANNEL\n         occlusionColor.rgb = SRGBToLinear(occlusionColor.rgb);\n         occlusionValue = occlusionColor.OCCLUSION_CHANNEL;\n     #endif\n  #endif\n  s.occlusion = occlusionValue;\n  #if ALPHA_SOURCE_IS_OPACITY\n    #if USE_OPACITY_MAP\n      baseColor.a = 1.0 - texture2D(alphaSourceMap, TEXTURE_UV).ALPHA_SOURCE_CHANNEL;\n    #else\n      baseColor.a = 1.0 - alphaSource;\n    #endif\n  #else\n    #if USE_OPACITY_MAP\n      baseColor.a = texture2D(alphaSourceMap, TEXTURE_UV).ALPHA_SOURCE_CHANNEL;\n    #else\n      baseColor.a = alphaSource;\n    #endif\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.a < albedoScaleAndCutoff.w) discard;\n  #endif\n  s.albedo = baseColor;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * normalStrength) * normalize(v_tangent) +\n      (nmmp.y * normalStrength) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  s.specularIntensity = 0.5;\n  vec3 emissiveColor = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n      emissiveColor.rgb = SRGBToLinear(texture2D(emissiveMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_EMISSIVESCALE_MAP\n      vec4 emissiveScaleColor = texture2D(emissiveScaleMap, TEXTURE_UV);\n      emissiveScaleColor.rgb = SRGBToLinear(emissiveScaleColor.rgb);\n      emissiveColor.rgb *= emissiveScaleColor.rgb;\n  #else\n      emissiveColor.rgb *= emissiveScale;\n  #endif\n  s.emissive = emissiveColor.rgb;\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  void main () {\n    StandardSurface s; surf(s);\n    gl_FragData[0] = s.albedo;\n    gl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    gl_FragData[2] = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","defines":["CC_USE_IBL"]},{"name":"cc_diffuseMap","defines":["CC_USE_DIFFUSEMAP"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":228,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":80}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean","defines":[]},{"name":"USE_VERTEX_COLOR","type":"boolean","defines":[]},{"name":"USE_NORMAL_MAP","type":"boolean","defines":[]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"USE_TWOSIDE","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":[]},{"name":"CC_USE_IBL","type":"number","defines":[],"range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","defines":[],"range":[0,2]},{"name":"USE_REFLECTION_DENOISE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"TEXTURE_UV","type":"string","defines":[],"options":["v_uv","v_uv1"]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"USE_WEIGHT_MAP","type":"boolean","defines":[]},{"name":"NORMAL_UV","type":"string","defines":["USE_NORMAL_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_METALLIC_MAP","type":"boolean","defines":[]},{"name":"METALLIC_CHANNEL","type":"string","defines":["USE_METALLIC_MAP"],"options":["r","g","b","a"]},{"name":"USE_ROUGHNESS_MAP","type":"boolean","defines":[]},{"name":"ROUGHNESS_CHANNEL","type":"string","defines":["USE_ROUGHNESS_MAP"],"options":["r","g","b","a"]},{"name":"USE_OCCLUSION_MAP","type":"boolean","defines":[]},{"name":"OCCLUSION_CHANNEL","type":"string","defines":["USE_OCCLUSION_MAP"],"options":["r","g","b","a"]},{"name":"USE_TRANSPARENCY_MAP","type":"boolean","defines":[]},{"name":"USE_TRANSPARENCYCOLOR_MAP","type":"boolean","defines":[]},{"name":"USE_EMISSIVE_MAP","type":"boolean","defines":[]},{"name":"USE_EMISSIVESCALE_MAP","type":"boolean","defines":[]},{"name":"USE_OPACITY_MAP","type":"boolean","defines":[]},{"name":"ALPHA_SOURCE_CHANNEL","type":"string","defines":["USE_OPACITY_MAP"],"options":["r","g","b","a"]},{"name":"USE_METALLIC_CHANNEL","type":"boolean","defines":["USE_METALLIC_MAP"]},{"name":"USE_ROUGHNESS_CHANNEL","type":"boolean","defines":["USE_ROUGHNESS_MAP"]},{"name":"USE_OCCLUSION_CHANNEL","type":"boolean","defines":["USE_OCCLUSION_MAP"]},{"name":"ALPHA_SOURCE_IS_OPACITY","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"CC_PIPELINE_TYPE","type":"number","defines":["CC_FORWARD_ADD"],"range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean","defines":["CC_FORWARD_ADD"]}]},{"hash":2529058441,"name":"dcc/imported-metallic-roughness|shadow-caster-vs:vert|shadow-caster-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"occlusion","type":13,"count":1},{"name":"roughness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalStrength","type":13,"count":1},{"name":"alphaSource","type":13,"count":1},{"name":"albedoScale","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]},{"name":"a_texCoord1","format":21,"location":14,"defines":[]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_worldPos","type":16,"count":1,"stageFlags":17,"location":2,"defines":[]},{"name":"v_clip_depth","type":13,"count":1,"stageFlags":17,"location":3,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 emissive;\n  float emissiveScale;\n  float occlusion;\n  float roughness;\n  float metallic;\n  float normalStrength;\n  float alphaSource;\n  float albedoScale;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  layout(location = 14) in vec2 a_texCoord1;\n#endif\nlayout(location = 0) out vec2 v_uv;\nlayout(location = 1) out vec2 v_uv1;\nlayout(location = 2) out vec4 v_worldPos;\nlayout(location = 3) out float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 emissive;\n  float emissiveScale;\n  float occlusion;\n  float roughness;\n  float metallic;\n  float normalStrength;\n  float alphaSource;\n  float albedoScale;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\nlayout(location = 0) in vec2 v_uv;\nlayout(location = 1) in vec2 v_uv1;\nlayout(location = 2) in vec4 v_worldPos;\nlayout(location = 3) in float v_clip_depth;\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 emissive;\n  float emissiveScale;\n  float occlusion;\n  float roughness;\n  float metallic;\n  float normalStrength;\n  float alphaSource;\n  float albedoScale;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\nout vec2 v_uv1;\nout vec4 v_worldPos;\nout float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 emissive;\n  float emissiveScale;\n  float occlusion;\n  float roughness;\n  float metallic;\n  float normalStrength;\n  float alphaSource;\n  float albedoScale;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec4 v_worldPos;\nin float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n   uniform vec4 albedo;\n   uniform vec4 albedoScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture2D(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":189,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":80}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]}]}],[{"name":"opaque","passes":[{"program":"dcc/imported-metallic-roughness|standard-vs|standard-fs","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"BaseColor","type":"color"},"handleInfo":["albedo",0,16]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"BaseColorMap"},"handleInfo":["albedoMap",0,28]},"baseWeightMap":{"value":"grey","type":28},"albedoScale":{"type":13,"value":[1],"editor":{"displayName":"BaseWeight"}},"roughness":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"roughnessMap":{"value":"grey","type":28},"metallic":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"metallicMap":{"value":"grey","type":28},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"occlusionMap":{"value":"white","type":28},"emissiveScale":{"type":13,"value":[1],"editor":{"displayName":"Emissive"}},"emissiveScaleMap":{"value":"grey","type":28,"editor":{"displayName":"EmissiveMap"}},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"displayName":"EmissiveColor","type":"color"}},"emissiveMap":{"value":"grey","type":28,"editor":{"displayName":"EmissiveColorMap"}},"alphaSource":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"alphaSourceMap":{"value":"grey","type":28,"editor":{"parent":"USE_OPACITY_MAP"}},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"normalStrength":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]}},"normalMap":{"value":"normal","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0,0,0,0.5]}}},{"phase":"forward-add","propertyIndex":0,"program":"dcc/imported-metallic-roughness|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"dcc/imported-metallic-roughness|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]},{"name":"transparent","passes":[{"program":"dcc/imported-metallic-roughness|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"BaseColor","type":"color"},"handleInfo":["albedo",0,16]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"BaseColorMap"},"handleInfo":["albedoMap",0,28]},"baseWeightMap":{"value":"grey","type":28},"albedoScale":{"type":13,"value":[1],"editor":{"displayName":"BaseWeight"}},"roughness":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"roughnessMap":{"value":"grey","type":28},"metallic":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"metallicMap":{"value":"grey","type":28},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"occlusionMap":{"value":"white","type":28},"emissiveScale":{"type":13,"value":[1],"editor":{"displayName":"Emissive"}},"emissiveScaleMap":{"value":"grey","type":28,"editor":{"displayName":"EmissiveMap"}},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"displayName":"EmissiveColor","type":"color"}},"emissiveMap":{"value":"grey","type":28,"editor":{"displayName":"EmissiveColorMap"}},"alphaSource":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"alphaSourceMap":{"value":"grey","type":28,"editor":{"parent":"USE_OPACITY_MAP"}},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"normalStrength":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]}},"normalMap":{"value":"normal","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0,0,0,0.5]}}},{"phase":"forward-add","propertyIndex":0,"program":"dcc/imported-metallic-roughness|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"dcc/imported-metallic-roughness|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]}]]],0,0,[],[],[]],[[{"name":"UI_Icon_Food_Steak","rect":{"x":27,"y":88,"width":459,"height":336},"offset":{"x":0.5,"y":0},"originalSize":{"width":512,"height":512},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[90]],[[{"name":"UI_Pop_Up_1","rect":{"x":0,"y":0,"width":460,"height":575},"offset":{"x":0,"y":0},"originalSize":{"width":460,"height":575},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[91]],[[[36,"Food_Berries"],[48,"Food_Berries",[-3],[[67,-2,[11,"66LJ7WJtBF/6SM1AKu7OOs"]]],[1,"deyd1rjS9YuJ4yxHjx4EDa",-1,0],[1,0.1,0.1,0.1]],[31,"Berries",1,[[62,-4,[11,"50QEQTRvRV2awMagNtfvQh"],[0],[24],1]],[1,"f6PMXD2thWI4IggEkzNpfD",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]]],0,[0,10,1,0,0,1,0,-1,2,0,0,2,0,16,1,4],[0,0],[-1,14],[92,93]],[[{"name":"Bg-1","rect":{"x":0,"y":0,"width":1080,"height":1920},"offset":{"x":0,"y":0},"originalSize":{"width":1080,"height":1920},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[94]],[[{"name":"icon_habitat","rect":{"x":18,"y":60,"width":230,"height":152},"offset":{"x":5,"y":-8},"originalSize":{"width":256,"height":256},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[95]],[[{"name":"icon_video","rect":{"x":38,"y":43,"width":183,"height":170},"offset":{"x":1.5,"y":0},"originalSize":{"width":256,"height":256},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[96]],[[{"name":"UI_Name_tag","rect":{"x":0,"y":0,"width":675,"height":181},"offset":{"x":-0.5,"y":0},"originalSize":{"width":676,"height":181},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[97]],[[{"name":"Bg-2","rect":{"x":0,"y":0,"width":1080,"height":1920},"offset":{"x":0,"y":0},"originalSize":{"width":1080,"height":1920},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[98]],[[[28,".bin",3576210858,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":68400,"length":15300,"count":3825,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":68400,"count":1425,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.8554086685180664,-2.2476742267608643,-2.310732364654541],"maxPosition",8,[1,1.855408787727356,2.2476747035980225,2.310732364654541]]],-1],0,0,[],[],[]],[[[25,"Food_AssetsC",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"albedoScale":1,"metallic":0,"roughness":0,"emissiveScale":1,"alphaSource":1},"mainColor",8,[4,4286545791],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[15,12],[99,5]],[[{"name":"UI_btn_Back","rect":{"x":0,"y":0,"width":283,"height":277},"offset":{"x":0,"y":0.5},"originalSize":{"width":283,"height":278},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[100]],[[{"name":"default_btn_pressed","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"packable":true}],[0],0,[0],[3],[101]],[[{"name":"VD297_Giraffe_Toy_Icon","rect":{"x":42,"y":32,"width":174,"height":209},"offset":{"x":1,"y":-8.5},"originalSize":{"width":256,"height":256},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[102]],[[{"name":"Link","rect":{"x":0,"y":0,"width":1280,"height":1280},"offset":{"x":0,"y":0},"originalSize":{"width":1280,"height":1280},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[103]],[[{"name":"UI_Icon_Feeding 1","rect":{"x":22,"y":40,"width":212,"height":176},"offset":{"x":0,"y":0},"originalSize":{"width":256,"height":256},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[104]],[[[36,"VD302_Kangaroo_Rig"],[116,"VD302_Kangaroo_Rig",524288,[[-3,-4,[13,"Bn_FoodSpawn",524288,-6,[1,"f3CmudYmJTjK7M6nViAmg5",-5,0],[1,-5.4358654466568623e-8,0.009165484458208084,0.8870136737823486],[3,1.545431187269876e-8,-0.707106721581899,1.5454308319985022e-8,0.7071068407911907],[1,0.0000025044781562438738,-89.99999034065368,-7.67592264999771e-14]]],1,1,4],[[65,-2,[11,"08p3MFuydXL4oM9CbjboO3"]]],[1,"8fJHyWPHhT77T0qzBIqM/Z",-1,0],[1,135.802,0,223.307],[1,100,100,100]],[85,"Bip001 Head",524288,[[[13,"Bip001 Xtra_Eyelid_up_L",524288,-7,[1,"2d7+KWFQJVFrgz3wx2r7Yn",1,0],[1,0.3271970748901367,0.4205749034881592,-0.18183529376983643],[3,-0.24522146530069025,-0.4163162103317173,0.8753637652717497,0.016897467860142394],[1,132.17461490430898,154.7176502037449,13.518670197215748]],[13,"Bip001 Xtra_Eyelid_up_R",524288,-8,[1,"a5xYRu1R9c+4gSl9Nkoyrr",1,0],[1,0.3271970748901367,0.4205739498138428,0.18183764815330505],[3,0.24522088155166882,0.4163115567490713,0.8753661401629665,0.016897562675627805],[1,-132.17519821674765,-154.71765267277706,13.518521573560058]],[13,"Bip001 Xtra_Eyelid_Low_L",524288,-9,[1,"bbzAt+/A5Za6JtvBJFLV6Q",1,0],[1,0.21905755996704102,0.41451358795166016,-0.20157299935817719],[3,0.4409942824246951,-0.040964274662843414,0.025457053795126677,0.8962130937908391],[1,52.42644045172507,-5.502120724866701,0.5443105331507334]],[13,"Bip001 Xtra_Eyelid_Low_R",524288,-10,[1,"8bMDwNbY5Up6fKdikNpIQL",1,0],[1,0.21905755996704102,0.41451263427734375,0.20157529413700104],[3,-0.4409942824517709,0.040964133104330384,0.025457279176747588,0.896213093845864],[1,-52.426441892868866,5.502117589864751,0.5443408344453377]],[13,"Bip001 Xtra_Eye_R",524288,-11,[1,"c2tjMLgltSz7/DvasIQO6O",1,0],[1,0.2641632556915283,0.35110998153686523,-0.14128649234771729],[3,-0.27964436716809643,0.1581443084705726,0.682003014140958,0.6570093563353323],[1,-98.45224704751105,88.08277038553146,53.873413080213766]],[13,"Bip001 Xtra_Eye_L",524288,-12,[1,"6bI877qbhcC6ioHfi85K1R",1,0],[1,0.2641632556915283,0.35110926628112793,0.1412884145975113],[3,0.27964439645134875,-0.15814812287424745,0.6820021188053784,0.657009355115806],[1,98.4519445966391,-88.08278231192374,53.87309036235816]],[13,"Bip001 Xtra_Mouth_Cor_R",524288,-13,[1,"ed/f9Db/pZuZRZD4YWAqds",1,0],[1,-0.03132891654968262,0.5618903636932373,-0.11657057702541351],[3,0.04929766191040832,-0.0604126283325885,0.7993534421572859,0.5957802693774057],[1,151.22228257200177,-152.1352089628443,71.17731919294856]],[13,"Bip001 Xtra_Mouth_Cor_L",524288,-14,[1,"e9ki9vW3ha/oTYOTJfAkl8",1,0],[1,-0.03132891654968262,0.5618896484375,0.11657369136810303],[3,-0.04929762034087917,0.06040812745717985,0.7993537901967565,0.595780262230903],[1,-151.22349829367852,152.13605821250368,71.17747050798812]],[13,"Bip001 Xtra_Mouth_Up_R",524288,-15,[1,"20BgvTdsleXrtRxNyWlh//",1,0],[1,-0.04088473320007324,0.6360740661621094,-0.06928008049726486],[3,-0.0038198481848174207,0.0019246733316340729,0.7995733037055219,0.6005532752336371],[1,-178.42422555767092,178.26911750409243,73.81321923996768]],[13,"Bip001 Xtra_Mouth_Up_L",524288,-16,[1,"7cMoqyptdaSbxJ3NJe5s4D",1,0],[1,-0.04088473320007324,0.6360738277435303,0.0692836120724678],[3,0.003819830457478615,-0.0019290845247500956,0.7995732969633009,0.6005532701696075],[1,178.42278052602967,-178.26803494978196,73.813208998766]],[13,"Bip001 Xtra_Teath_Up",524288,-17,[1,"34N3Tf3Vhf6p2OCEtjbUr5",1,0],[1,0.002314329147338867,0.554196834564209,0.000004309463747631526],[3,9.336697845026691e-7,1.9915808695504157e-7,0.8147948658617054,0.5797493652989147],[1,179.9998674950161,-179.99977440903933,70.86583252141891]],-18,[13,"Bip001 Xtra_EarL",524288,-19,[1,"3dlgK1+6ZS+pIxXuBluE25",1,0],[1,0.6298751831054688,-0.04161977767944336,0.21326301991939545],[3,0.17229719240550637,-0.3286434668165523,0.041136212122997444,0.9276933551880974],[1,20.3010491465256,-38.635362133307176,-2.1161341392427624]],[13,"Bip001 Xtra_EarR",524288,-20,[1,"68RNEaQ79QPq60RxDOrbld",1,0],[1,0.6298751831054688,-0.04161834716796875,-0.21326324343681335],[3,-0.17229802753627552,0.32864299124926405,0.04113777690385765,0.9276932991680245],[1,-20.30120120360858,38.635335030936766,-2.1159900209997105]],[13,"Bip001 Xtra_eyebrownR",524288,-21,[1,"a5O6YJyIlZ0K3DMvMImW/M",1,0],[1,0.3929600715637207,0.4532432556152344,-0.1358882188796997],[3,-0.23773379651555063,0.542546868955643,-0.31570294536135707,0.7412537941021924],[1,-0.8227543143827625,72.04920289475375,-46.5517219786071]],[13,"Bip001 Xtra_eyebrownL",524288,-22,[1,"ccJkUI+3RXpZAAZAVToHx+",1,0],[1,0.3929600715637207,0.45324230194091797,0.13589075207710266],[3,0.23773374855793258,-0.542545073389861,-0.3157059510744924,0.7412538435604459],[1,0.8225775813222904,-72.04909199221025,-46.55202036838682]],[13,"Bip001 Xtra11_Nose",524288,-23,[1,"beBTxB4F9YIazSRhrqCQYQ",1,0],[1,0.15001845359802246,0.7634279727935791,0.0000010193798516411334],[3,1.9258151975219854e-12,-0.0000027674523216948566,0.9977835439810513,0.06654321417661394],[1,179.99968074891942,-179.99997870859482,7.630929361688651]],[13,"Bn_Mouth",524288,-24,[1,"84hrPyzk1d1ruBlx05r4WZ",1,0],[1,-0.07195711135864258,0.5386135578155518,0.008439688943326473],[3,-0.46549811987707945,-0.5231723192550453,-0.44354066279808146,0.559351325376851],[1,-80.02761183493475,-86.61028004033459,-0.5224675849989031]]],4,4,4,4,4,4,4,4,4,4,4,1,4,4,4,4,4,4],[1,"bfrFfxzL1T1KmmYCwEZLjk",1,0],[1,0.271028995513916,0.1483471393585205,-1.397716005158145e-7],[3,-4.7459346984729076e-7,0.0000010302596964508388,-0.31471839988255196,0.9491850866791363],[1,-0.000018038935986709043,0.0001183982779817365,-36.6876293880894]],[70,"Bip001 Spine",524288,[-25,-26,-27,-28],[1,"24QV1ABdRedL8PrNu+86Nq",1,0],[1,0.3542376756668091,0.3531496524810791,-0.0000013134826986060943],[3,-0.0000018851790819067795,-0.0000011795759439423908,0.06960712936962687,0.9975744821996876],[1,-0.00020810952367528602,-0.00012097697166633093,7.982844695585415]],[85,"Bip001 L Hand",524288,[[-29,-30,-31,[13,"Bn_Hand",524288,-32,[1,"cdSHSn+iNTHKbOD/PLegz3",1,0],[1,0.16577750444412231,0.06132864952087402,-0.046974703669548035],[3,-0.3996487816964595,0.9162200003981678,-0.011799826171741228,-0.02612520356348691],[1,3.5752087539781954,-175.1773245504443,-47.03043486089243]]],1,1,1,4],[1,"0516pAzllTEINtCBbXwvaI",1,0],[1,0.5944492220878601,0,-2.220446049250313e-16],[3,-0.2617311703737297,0.029688528854133044,0.3459904396792379,0.9005031934201249],[1,-38.26907185297872,17.178544816200937,37.415459422889654]],[70,"Bip001 Neck",524288,[2,-33,-34],[1,"42dhuQU8NX0rXxQG7SW2YE",1,0],[1,0.5762070417404175,-0.12533974647521973,9.96238668449223e-7],[3,1.2697269418175673e-13,8.642778814821149e-7,-0.31160864818281975,0.9502105295022409],[1,0.000038299085695490824,0.00011678809352825268,-36.312403738338894]],[70,"Bip001 R Hand",524288,[-35,-36,-37],[1,"04ZamzRGFcKJpv5KTVe1wf",1,0],[1,0.5944493412971497,-1.1920928955078125e-7,0],[3,0.2617312122116491,-0.029688526494057035,0.345990455589461,0.9005031752247349],[1,38.26907848292041,-17.178547481263575,37.41546049159831]],[27,"Bip001 Xtra_Jaw",524288,2,[[13,"Bip001 Xtra_Teath_Low",524288,-38,[1,"054HrpVJ9YdrFA31Ec+dkY",1,0],[1,0.13749122619628906,-0.031085491180419922,0.0000035714842852030415],[3,0.000004232222292237529,-0.0000038132740061028115,0.03182718986028513,0.9994933866480282],[1,0.0004996510135593257,-0.000453101048055823,3.647743322877986]],[107,"Bip001 Xtra_Tongue",524288,-39,[1,"dfbHKl6RxVqLvXw6Lt14xK",1,0],[1,0.08936405181884766,-0.028061389923095703,0.000004445225840754574],[3,-3.0594311178264103e-7,3.817032550457581e-7,-0.048731250106838264,0.9988119268725146],[1,1,0.9999989867210388,1],[1,-0.00003304227590328229,0.000042179892466667365,-5.586402449871046]]],[1,"d7tLOit5hTsbOMYxHRvFOp",1,0],[1,-0.020290136337280273,0.3777594566345215,-9.088580554816872e-9],[3,-9.235465789091367e-8,-0.0000020748226942927456,0.7911309946054532,0.611646752112911],[1,179.9992786301882,-179.9994556648126,75.41733868808973]],[108,"VD302_Kangaroo_Toy",524288,1,[[44,-40,[11,"08oWDW2JpSa5Knf6tUbF/f"],[0,1,2,3,4],[24],1,5,6]],[1,"5fl0cfxJ5Rs5ovU2QsXaQ9",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[20,"Bip001",524288,1,[-41],[1,"61SpoqJn9XKIWNc6m3Gvr3",1,0],[1,-3.732301578907027e-9,1.5775775909423828,0.4474337100982666],[3,-0.5000003576277408,-0.49999964237200345,-0.49999964237200345,0.5000003576277408],[1,-90,-89.99991803772996,0]],[109,"Bip001 Pelvis",524288,9,[3],[1,"f4npe4uvhfYIaPYyEku12n",1,0],[3,-0.678948057080087,-0.19755655885105733,-0.1975572294033232,0.6789492491730041],[1,-89.99992243324212,-32.44732100165269,-0.00007915718266001345]],[20,"Bip001 Spine1",524288,3,[5],[1,"124ooP3KBc1Lk0UF5SkG6P",1,0],[1,0.4582993984222412,-0.00035309791564941406,-9.790710464585572e-10],[3,2.446313346659477e-13,-1.8054307341607132e-7,0.06509341476946535,0.9978791747268894],[1,0.0000013582370161722287,-0.000020821282842442467,7.46443354701361]],[20,"Bip001 L Clavicle",524288,5,[-42],[1,"36Y+vy/Y5QJ7jAvyy3x9XZ",1,0],[1,-0.290891170501709,0.11437880992889404,0.056595951318740845],[3,0.7404151484820694,0.19713777106521088,0.5926956475105046,-0.24826191117410562],[1,-143.0354460567296,-77.30871903103836,-0.13521382911142363]],[20,"Bip001 L UpperArm",524288,12,[-43],[1,"57Le13NptWs5X3lanB4PyH",1,0],[1,0.2798118591308594,1.1920928955078125e-7,2.384185791015625e-7],[3,-0.24198095521163535,0.5819774871081226,-0.35439729720859986,0.6907604342646003],[1,7.057027719358092,83.55855063844022,-50.46736884718895]],[20,"Bip001 L Forearm",524288,13,[4],[1,"bex7q5czhZfLRNzKYoBLyx",1,0],[1,0.5204557180404663,1.1920928955078125e-7,-1.1920928955078125e-7],[3,-8.996704747186443e-18,-2.969889326223742e-17,-0.6873185419958124,0.7263561260351223],[1,-5.595479079571909e-14,-5.763289687687109e-14,-86.83644251224672]],[27,"Bip001 L Finger0",524288,4,[[13,"Bip001 L Finger01",524288,-44,[1,"a6aeXwf6BZdI+Q2cVg8FCt",1,0],[1,0.1283271312713623,-2.220446049250313e-16,-5.960464477539063e-8],[3,-0.0005510463967082443,0.04632963244924116,0.01187961922320866,0.9988554130363908],[1,-0.1261771947815869,5.312755955821363,1.356947306578145]]],[1,"40GhtM2Y1bgZOrgy9wQpjf",1,0],[1,0.08157700300216675,0.006247282028198242,-0.12238441407680511],[3,0.9290023395148231,0.3079701645178377,-0.06974732092525232,0.19298793269681716],[1,151.3789632812749,17.241735558793838,33.044430410905846]],[27,"Bip001 L Finger1",524288,4,[[13,"Bip001 L Finger11",524288,-45,[1,"82YHmJYpNUwIRpMz6/x7rh",1,0],[1,0.0953603982925415,-2.384185791015625e-7,5.960464477539063e-8],[3,1.0302478230703421e-8,-1.3092540701434747e-8,0.2016598630980403,0.9794556139076848],[1,0.0000015880320747349408,-0.0000018587233107113073,23.268080227659283]]],[1,"efGIrw9kZbM5dp1NBwHMRu",1,0],[1,0.2140156626701355,0.02871990203857422,-0.07965849339962006],[3,0.14175589132700384,0.05487470977109217,0.29237341365277086,0.9441460800589339],[1,16.628244260928607,1.4427303831348735,34.58610116822202]],[27,"Bip001 L Finger2",524288,4,[[13,"Bip001 L Finger21",524288,-46,[1,"56GP/33ipbt5RscKxkRlan",1,0],[1,0.07172501087188721,1.1920928955078125e-7,5.960464477539063e-8],[3,-1.0171859984491851e-17,-1.4991040769140968e-17,0.13798254917676323,0.9904346601985827],[1,-9.53743987823341e-16,-1.601566231679269e-15,15.862243670868283]]],[1,"a3opXY1K1bs63KtREsU6Cj",1,0],[1,0.20017272233963013,0.027018070220947266,0.010468840599060059],[3,0.016227573424614575,-0.07892323415809137,0.25775862166212676,0.9628438512706079],[1,4.745212621468258,-10.625984962258268,29.590727366189885]],[20,"Bip001 R Clavicle",524288,5,[-47],[1,"80Sxap8RleT7LfBkzDAi93",1,0],[1,-0.2908914089202881,0.1143791675567627,-0.056598000228405],[3,0.7404158188458404,0.19713941411025176,-0.5926951228460576,0.24825985974701364],[1,143.03551574473522,77.30872223520217,-0.1349050251337831]],[20,"Bip001 R UpperArm",524288,18,[-48],[1,"94nYA+SUZazqUalPScGfCg",1,0],[1,0.2798118591308594,4.440892098500626e-16,0],[3,0.24198129715613026,-0.5819780812733067,-0.35439678942351904,0.6907600744038257],[1,-7.056981598696757,-83.5586140647127,-50.46734445139137]],[20,"Bip001 R Forearm",524288,19,[6],[1,"39NhMc+jhSCqKPANQHLh8+",1,0],[1,0.5204557180404663,1.1920928955078125e-7,0],[3,4.9317570815256714e-17,-8.45495145977068e-18,-0.6873185717527179,0.7263560978774832],[1,6.231598940146356e-14,5.763298592223944e-14,-86.83644720676268]],[27,"Bip001 R Finger0",524288,6,[[13,"Bip001 R Finger01",524288,-49,[1,"84l6lm3SBYBZ8FSo3q+7NM",1,0],[1,0.11112487316131592,2.220446049250313e-16,-1.1920928955078125e-7],[3,0.0005510246851597509,-0.046329632441594146,0.011879634122409057,0.9988554128715231],[1,0.12617478816212,-5.3127559293270386,1.356949127499545]]],[1,"47JEn10QFZeY7XBihtHdxT",1,0],[1,0.0954056978225708,0.005409955978393555,0.10597886145114899],[3,0.9290023316959993,0.30797019172817003,0.06974726818416987,-0.19298794597372107],[1,-151.37896227054966,-17.241730691025925,33.044434802218554]],[27,"Bip001 R Finger1",524288,6,[[13,"Bip001 R Finger11",524288,-50,[1,"e57STHoJpa0p56K4UDKx2N",1,0],[1,0.09536051750183105,1.1920928955078125e-7,5.960464477539063e-8],[3,-1.0302478230703421e-8,1.3092540701434747e-8,0.2016598630980403,0.9794556139076848],[1,-0.0000015880320747349408,0.0000018587233107113073,23.268080227659283]]],[1,"53/rmZzdJZL463F9C5r7qA",1,0],[1,0.2140156626701355,0.02871990203857422,0.07965849339962006],[3,-0.14175589118211213,-0.0548747283414547,0.2923734133539298,0.9441460790939021],[1,-16.628243493903444,-1.4427328337497123,34.58610145498249]],[27,"Bip001 R Finger2",524288,6,[[13,"Bip001 R Finger21",524288,-51,[1,"6cklssd71bQpgcGHdZO8+Q",1,0],[1,0.07172489166259766,0,0],[3,4.893729611197911e-18,-3.696921671140056e-18,0.13798254917676323,0.9904346601985827],[1,6.381709387020008e-16,-5.16634253009268e-16,15.862243670868283]]],[1,"9fgNNDboxcjIG+O1o8GHRt",1,0],[1,0.20017272233963013,0.027018070220947266,-0.010468810796737671],[3,-0.016227580863691093,0.07892324155272112,0.2577586214793942,0.9628438505880201],[1,-4.745213810691006,10.625986151481015,29.59072722663627]],[20,"Bip001 L Thigh",524288,3,[-52],[1,"1aOCmC7G1QLYh3hQ/RIfCW",1,0],[1,-0.39984893798828125,-0.30053311586380005,0.3836286962032318],[3,0.7178273552306246,0.680038369359236,0.1348885996845741,0.06384958854192135],[1,-126.10226971349779,-70.08105235291427,83.47655542639572]],[20,"Bip001 L Calf",524288,24,[-53],[1,"dbtmT0gRdSBIMmHDpIZtZm",1,0],[1,0.743604302406311,-1.1920928955078125e-7,-2.7755575615628914e-17],[3,0,0,-0.41653967720321833,0.909117537678951],[1,0,0,-49.23262954822765]],[27,"Bip001 L Foot",524288,25,[[13,"Bip001 L Toe0",524288,-54,[1,"0ej8X8mtRS8IOXZwhuA0cA",1,0],[1,0.0993526503443718,0.3203730583190918,0.015012085437774658],[3,-0.012606775107827504,-0.004188367072502582,0.7176545698822673,0.6962725365327463],[1,-159.190288938885,157.82919259324692,88.13791814938088]]],[1,"27lKXEzcFQsZTcP6tappE1",1,0],[1,0.8391543626785278,2.9802322387695312e-8,0],[3,0.09368384456679991,0.04668617534947475,0.18506039337690455,0.9771368323329169],[1,10.282468224363756,3.491167402013983,21.740666790231035]],[20,"Bip001 R Thigh",524288,3,[-55],[1,"abAw8bUFFfbJbDdcCTemu+",1,0],[1,-0.399849534034729,-0.3005313277244568,-0.3836267292499542],[3,0.7178270792704299,0.6800386286793662,-0.134887694859659,-0.06385184057972494],[1,126.10304314074824,70.08038736689647,83.47680202680553]],[20,"Bip001 R Calf",524288,27,[-56],[1,"54Lh51XGBYv7YuKOF5iKJs",1,0],[1,0.7436041831970215,0,5.551115123125783e-17],[3,-5.0466161121084984e-17,2.312259701504717e-17,-0.41653967720321833,0.909117537678951],[1,-6.361109362927037e-15,0,-49.23262954822765]],[27,"Bip001 R Foot",524288,28,[[13,"Bip001 R Toe0",524288,-57,[1,"46OYGFnqVWX54eydGHqJue",1,0],[1,0.09935265779495239,0.320372998714447,-0.01501205563545227],[3,0.012606777493592694,0.004188363055347829,0.7176545996614502,0.6962725058200326],[1,159.19032927263092,-157.8292330582914,88.13791339787937]]],[1,"a0sQDO/bdTOryUmf6KpZ23",1,0],[1,0.8391544222831726,-5.551115123125783e-17,1.4901161193847656e-8],[3,-0.0936838530691832,-0.04668609764253182,0.1850603507511224,0.9771368433033805],[1,-10.282471032387543,-3.4911582401498076,21.740661053193115]],[20,"Bip001 Xtra_Tail",524288,3,[-58],[1,"82O4d8FFlZfbWoM1gQ5T0P",1,0],[1,-0.9858397245407104,-0.43601518869400024,0.000001985863264053478],[3,9.877768196883434e-7,-0.0000026041092780163377,0.9789544108644718,-0.20407905684130798],[1,179.999706525755,-179.99994555523935,-23.551186460093533]],[27,"Bip001 Xtra_Tail1",524288,30,[[13,"Bip001 Xtra_Tail2",524288,-59,[1,"32EOimsNxW6auKvQxSU90n",1,0],[1,0.9689803123474121,-0.0008437633514404297,-2.9117472877260298e-9],[3,3.4403779720176436e-7,5.077550272064185e-7,-0.010108478258240874,0.9999489080282684],[1,0.00004001814766795572,0.00005859195632515687,-1.1583660107752876]]],[1,"b98OsIwtddvaimim2Y6TQy",1,0],[1,0.7776881456375122,-0.0007715225219726562,-2.1395862859208137e-9],[3,1.7354177343170095e-13,2.4402726421175402e-8,-0.008798220935442457,0.9999612949051431],[1,2.4626572286066044e-8,0.000002796671380546391,-1.0082148613665045]]],0,[0,10,1,0,0,1,0,-1,8,0,-2,9,0,10,1,0,1,1,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,-12,7,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,-1,11,0,-2,24,0,-3,27,0,-4,30,0,-1,15,0,-2,16,0,-3,17,0,1,4,0,-2,12,0,-3,18,0,-1,21,0,-2,22,0,-3,23,0,1,7,0,1,7,0,0,8,0,-1,10,0,-1,13,0,-1,14,0,1,15,0,1,16,0,1,17,0,-1,19,0,-1,20,0,1,21,0,1,22,0,1,23,0,-1,25,0,-1,26,0,1,26,0,-1,28,0,-1,29,0,1,29,0,-1,31,0,1,31,0,16,1,2,1,5,3,1,10,4,1,14,5,1,11,6,1,20,59],[0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,14,19],[10,10,10,10,39,26,40]],[[{"name":"UI_Icon_Feeding 1","rect":{"x":22,"y":40,"width":212,"height":176},"offset":{"x":0,"y":0},"originalSize":{"width":256,"height":256},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[105]],[[{"name":"VD295_Flamingo_Toy_Icon","rect":{"x":48,"y":34,"width":192,"height":207},"offset":{"x":16,"y":-9.5},"originalSize":{"width":256,"height":256},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[106]],[[[172,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{},{}],[[[{},"mainColor",8,[4,16777215]],{},{}],11,0,0]]],0,0,[0],[12],[41]],[[{"name":"UI_Customization_tab.png_selection","rect":{"x":0,"y":0,"width":275,"height":199},"offset":{"x":0,"y":0},"originalSize":{"width":275,"height":199},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[107]],[[[174,[[175,[176,[-10,-11,-12,-13,-14],[[177,-5,-4],[95,0,-7,-6,[[178,1,[96,"velocity"],[97]]]],[95,0,-9,-8,[[179,[96,"velocity"],[97]]]]],-3,-2,-1]]],[{},"velocity",4,[180]]],[98,"Idle",[99,0]],[74,"Entry"],[98,"Run",[99,1]],[74,"Exit"],[74,"Any"]],0,[0,33,5,0,34,4,0,35,2,0,22,1,0,23,2,0,22,3,0,23,1,0,22,1,0,23,3,0,-1,2,0,-2,4,0,-3,5,0,-4,1,0,-5,3,14],[0,0],[24,24],[9,22]],[[[36,"Food_Seaweed"],[48,"Food_Seaweed",[-3],[[67,-2,[11,"18XFFtjY9BUY7wZ1m9PaDG"]]],[1,"ee9LrN7tNcaYoON4jeTkFo",-1,0],[1,0.1,0.1,0.1]],[31,"Food_Seaweed",1,[[62,-4,[11,"92zFs6bT1SKoRdwKB4Y0AR"],[0],[24],1]],[1,"a9DNsBItRSZLYa2jQjPOIE",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]]],0,[0,10,1,0,0,1,0,-1,2,0,0,2,0,16,1,4],[0,0],[-1,14],[108,109]],[[{"name":"UI_Unlock_BG","rect":{"x":0,"y":0,"width":1080,"height":1920},"offset":{"x":0,"y":0},"originalSize":{"width":1080,"height":1920},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[110]],[[{"name":"UI_MM_Icon_camera","rect":{"x":0,"y":0,"width":242,"height":209},"offset":{"x":0,"y":0},"originalSize":{"width":242,"height":209},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[111]],[[{"name":"UI_Icon_Food_Berries","rect":{"x":70,"y":61,"width":372,"height":390},"offset":{"x":0,"y":0},"originalSize":{"width":512,"height":512},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[112]],[[[64],[52,"VD302_Kangaroo_Rig",[[-3,-4,[6,"Bn_FoodSpawn",-6,[1,"f3CmudYmJTjK7M6nViAmg5",-5,0],[1,-5.4358654466568623e-8,0.009165484458208084,0.8870136737823486],[3,1.545431187269876e-8,-0.707106721581899,1.5454308319985022e-8,0.7071068407911907],[1,0.0000025044781562438738,-89.99999034065368,-7.67592264999771e-14]]],1,1,4],[[65,-2,[11,"08p3MFuydXL4oM9CbjboO3"]]],[1,"8fJHyWPHhT77T0qzBIqM/Z",-1,0]],[35,"Bip001 Head",[[[6,"Bip001 Xtra_Eyelid_up_L",-7,[1,"2d7+KWFQJVFrgz3wx2r7Yn",1,0],[1,0.3271970748901367,0.4205749034881592,-0.18183529376983643],[3,-0.24522146530069025,-0.4163162103317173,0.8753637652717497,0.016897467860142394],[1,132.17461490430898,154.7176502037449,13.518670197215748]],[6,"Bip001 Xtra_Eyelid_up_R",-8,[1,"a5xYRu1R9c+4gSl9Nkoyrr",1,0],[1,0.3271970748901367,0.4205739498138428,0.18183764815330505],[3,0.24522088155166882,0.4163115567490713,0.8753661401629665,0.016897562675627805],[1,-132.17519821674765,-154.71765267277706,13.518521573560058]],[6,"Bip001 Xtra_Eyelid_Low_L",-9,[1,"bbzAt+/A5Za6JtvBJFLV6Q",1,0],[1,0.21905755996704102,0.41451358795166016,-0.20157299935817719],[3,0.4409942824246951,-0.040964274662843414,0.025457053795126677,0.8962130937908391],[1,52.42644045172507,-5.502120724866701,0.5443105331507334]],[6,"Bip001 Xtra_Eyelid_Low_R",-10,[1,"8bMDwNbY5Up6fKdikNpIQL",1,0],[1,0.21905755996704102,0.41451263427734375,0.20157529413700104],[3,-0.4409942824517709,0.040964133104330384,0.025457279176747588,0.896213093845864],[1,-52.426441892868866,5.502117589864751,0.5443408344453377]],[6,"Bip001 Xtra_Eye_R",-11,[1,"c2tjMLgltSz7/DvasIQO6O",1,0],[1,0.2641632556915283,0.35110998153686523,-0.14128649234771729],[3,-0.27964436716809643,0.1581443084705726,0.682003014140958,0.6570093563353323],[1,-98.45224704751105,88.08277038553146,53.873413080213766]],[6,"Bip001 Xtra_Eye_L",-12,[1,"6bI877qbhcC6ioHfi85K1R",1,0],[1,0.2641632556915283,0.35110926628112793,0.1412884145975113],[3,0.27964439645134875,-0.15814812287424745,0.6820021188053784,0.657009355115806],[1,98.4519445966391,-88.08278231192374,53.87309036235816]],[6,"Bip001 Xtra_Mouth_Cor_R",-13,[1,"ed/f9Db/pZuZRZD4YWAqds",1,0],[1,-0.03132891654968262,0.5618903636932373,-0.11657057702541351],[3,0.04929766191040832,-0.0604126283325885,0.7993534421572859,0.5957802693774057],[1,151.22228257200177,-152.1352089628443,71.17731919294856]],[6,"Bip001 Xtra_Mouth_Cor_L",-14,[1,"e9ki9vW3ha/oTYOTJfAkl8",1,0],[1,-0.03132891654968262,0.5618896484375,0.11657369136810303],[3,-0.04929762034087917,0.06040812745717985,0.7993537901967565,0.595780262230903],[1,-151.22349829367852,152.13605821250368,71.17747050798812]],[6,"Bip001 Xtra_Mouth_Up_R",-15,[1,"20BgvTdsleXrtRxNyWlh//",1,0],[1,-0.04088473320007324,0.6360740661621094,-0.06928008049726486],[3,-0.0038198481848174207,0.0019246733316340729,0.7995733037055219,0.6005532752336371],[1,-178.42422555767092,178.26911750409243,73.81321923996768]],[6,"Bip001 Xtra_Mouth_Up_L",-16,[1,"7cMoqyptdaSbxJ3NJe5s4D",1,0],[1,-0.04088473320007324,0.6360738277435303,0.0692836120724678],[3,0.003819830457478615,-0.0019290845247500956,0.7995732969633009,0.6005532701696075],[1,178.42278052602967,-178.26803494978196,73.813208998766]],[6,"Bip001 Xtra_Teath_Up",-17,[1,"34N3Tf3Vhf6p2OCEtjbUr5",1,0],[1,0.002314329147338867,0.554196834564209,0.000004309463747631526],[3,9.336697845026691e-7,1.9915808695504157e-7,0.8147948658617054,0.5797493652989147],[1,179.9998674950161,-179.99977440903933,70.86583252141891]],-18,[6,"Bip001 Xtra_EarL",-19,[1,"3dlgK1+6ZS+pIxXuBluE25",1,0],[1,0.6298751831054688,-0.04161977767944336,0.21326301991939545],[3,0.17229719240550637,-0.3286434668165523,0.041136212122997444,0.9276933551880974],[1,20.3010491465256,-38.635362133307176,-2.1161341392427624]],[6,"Bip001 Xtra_EarR",-20,[1,"68RNEaQ79QPq60RxDOrbld",1,0],[1,0.6298751831054688,-0.04161834716796875,-0.21326324343681335],[3,-0.17229802753627552,0.32864299124926405,0.04113777690385765,0.9276932991680245],[1,-20.30120120360858,38.635335030936766,-2.1159900209997105]],[6,"Bip001 Xtra_eyebrownR",-21,[1,"a5O6YJyIlZ0K3DMvMImW/M",1,0],[1,0.3929600715637207,0.4532432556152344,-0.1358882188796997],[3,-0.23773379651555063,0.542546868955643,-0.31570294536135707,0.7412537941021924],[1,-0.8227543143827625,72.04920289475375,-46.5517219786071]],[6,"Bip001 Xtra_eyebrownL",-22,[1,"ccJkUI+3RXpZAAZAVToHx+",1,0],[1,0.3929600715637207,0.45324230194091797,0.13589075207710266],[3,0.23773374855793258,-0.542545073389861,-0.3157059510744924,0.7412538435604459],[1,0.8225775813222904,-72.04909199221025,-46.55202036838682]],[6,"Bip001 Xtra11_Nose",-23,[1,"beBTxB4F9YIazSRhrqCQYQ",1,0],[1,0.15001845359802246,0.7634279727935791,0.0000010193798516411334],[3,1.9258151975219854e-12,-0.0000027674523216948566,0.9977835439810513,0.06654321417661394],[1,179.99968074891942,-179.99997870859482,7.630929361688651]],[6,"Bn_Mouth",-24,[1,"84hrPyzk1d1ruBlx05r4WZ",1,0],[1,-0.07195711135864258,0.5386135578155518,0.008439688943326473],[3,-0.46549811987707945,-0.5231723192550453,-0.44354066279808146,0.559351325376851],[1,-80.02761183493475,-86.61028004033459,-0.5224675849989031]]],4,4,4,4,4,4,4,4,4,4,4,1,4,4,4,4,4,4],[1,"bfrFfxzL1T1KmmYCwEZLjk",1,0],[1,0.271028995513916,0.1483471393585205,-1.397716005158145e-7],[3,-4.7459346984729076e-7,0.0000010302596964508388,-0.31471839988255196,0.9491850866791363],[1,-0.000018038935986709043,0.0001183982779817365,-36.6876293880894]],[34,"Bip001 Spine",[-25,-26,-27,-28],[1,"24QV1ABdRedL8PrNu+86Nq",1,0],[1,0.3542376756668091,0.3531496524810791,-0.0000013134826986060943],[3,-0.0000018851790819067795,-0.0000011795759439423908,0.06960712936962687,0.9975744821996876],[1,-0.00020810952367528602,-0.00012097697166633093,7.982844695585415]],[35,"Bip001 L Hand",[[-29,-30,-31,[6,"Bn_Hand",-32,[1,"cdSHSn+iNTHKbOD/PLegz3",1,0],[1,0.16577750444412231,0.06132864952087402,-0.046974703669548035],[3,-0.3996487816964595,0.9162200003981678,-0.011799826171741228,-0.02612520356348691],[1,3.5752087539781954,-175.1773245504443,-47.03043486089243]]],1,1,1,4],[1,"0516pAzllTEINtCBbXwvaI",1,0],[1,0.5944492220878601,0,-2.220446049250313e-16],[3,-0.2617311703737297,0.029688528854133044,0.3459904396792379,0.9005031934201249],[1,-38.26907185297872,17.178544816200937,37.415459422889654]],[34,"Bip001 Neck",[2,-33,-34],[1,"42dhuQU8NX0rXxQG7SW2YE",1,0],[1,0.5762070417404175,-0.12533974647521973,9.96238668449223e-7],[3,1.2697269418175673e-13,8.642778814821149e-7,-0.31160864818281975,0.9502105295022409],[1,0.000038299085695490824,0.00011678809352825268,-36.312403738338894]],[34,"Bip001 R Hand",[-35,-36,-37],[1,"04ZamzRGFcKJpv5KTVe1wf",1,0],[1,0.5944493412971497,-1.1920928955078125e-7,0],[3,0.2617312122116491,-0.029688526494057035,0.345990455589461,0.9005031752247349],[1,38.26907848292041,-17.178547481263575,37.41546049159831]],[14,"Bip001 Xtra_Jaw",2,[[6,"Bip001 Xtra_Teath_Low",-38,[1,"054HrpVJ9YdrFA31Ec+dkY",1,0],[1,0.13749122619628906,-0.031085491180419922,0.0000035714842852030415],[3,0.000004232222292237529,-0.0000038132740061028115,0.03182718986028513,0.9994933866480282],[1,0.0004996510135593257,-0.000453101048055823,3.647743322877986]],[81,"Bip001 Xtra_Tongue",-39,[1,"dfbHKl6RxVqLvXw6Lt14xK",1,0],[1,0.08936405181884766,-0.028061389923095703,0.000004445225840754574],[3,-3.0594311178264103e-7,3.817032550457581e-7,-0.048731250106838264,0.9988119268725146],[1,1,0.9999989867210388,1],[1,-0.00003304227590328229,0.000042179892466667365,-5.586402449871046]]],[1,"d7tLOit5hTsbOMYxHRvFOp",1,0],[1,-0.020290136337280273,0.3777594566345215,-9.088580554816872e-9],[3,-9.235465789091367e-8,-0.0000020748226942927456,0.7911309946054532,0.611646752112911],[1,179.9992786301882,-179.9994556648126,75.41733868808973]],[31,"VD302_Kangaroo_Toy",1,[[44,-40,[11,"08oWDW2JpSa5Knf6tUbF/f"],[0,1,2,3,4],[24],1,5,6]],[1,"5fl0cfxJ5Rs5ovU2QsXaQ9",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[7,"Bip001",1,[-41],[1,"61SpoqJn9XKIWNc6m3Gvr3",1,0],[1,-3.732301578907027e-9,1.5775775909423828,0.4474337100982666],[3,-0.5000003576277408,-0.49999964237200345,-0.49999964237200345,0.5000003576277408],[1,-90,-89.99991803772996,0]],[69,"Bip001 Pelvis",9,[3],[1,"f4npe4uvhfYIaPYyEku12n",1,0],[3,-0.678948057080087,-0.19755655885105733,-0.1975572294033232,0.6789492491730041],[1,-89.99992243324212,-32.44732100165269,-0.00007915718266001345]],[7,"Bip001 Spine1",3,[5],[1,"124ooP3KBc1Lk0UF5SkG6P",1,0],[1,0.4582993984222412,-0.00035309791564941406,-9.790710464585572e-10],[3,2.446313346659477e-13,-1.8054307341607132e-7,0.06509341476946535,0.9978791747268894],[1,0.0000013582370161722287,-0.000020821282842442467,7.46443354701361]],[7,"Bip001 L Clavicle",5,[-42],[1,"36Y+vy/Y5QJ7jAvyy3x9XZ",1,0],[1,-0.290891170501709,0.11437880992889404,0.056595951318740845],[3,0.7404151484820694,0.19713777106521088,0.5926956475105046,-0.24826191117410562],[1,-143.0354460567296,-77.30871903103836,-0.13521382911142363]],[7,"Bip001 L UpperArm",12,[-43],[1,"57Le13NptWs5X3lanB4PyH",1,0],[1,0.2798118591308594,1.1920928955078125e-7,2.384185791015625e-7],[3,-0.24198095521163535,0.5819774871081226,-0.35439729720859986,0.6907604342646003],[1,7.057027719358092,83.55855063844022,-50.46736884718895]],[7,"Bip001 L Forearm",13,[4],[1,"bex7q5czhZfLRNzKYoBLyx",1,0],[1,0.5204557180404663,1.1920928955078125e-7,-1.1920928955078125e-7],[3,-8.996704747186443e-18,-2.969889326223742e-17,-0.6873185419958124,0.7263561260351223],[1,-5.595479079571909e-14,-5.763289687687109e-14,-86.83644251224672]],[14,"Bip001 L Finger0",4,[[6,"Bip001 L Finger01",-44,[1,"a6aeXwf6BZdI+Q2cVg8FCt",1,0],[1,0.1283271312713623,-2.220446049250313e-16,-5.960464477539063e-8],[3,-0.0005510463967082443,0.04632963244924116,0.01187961922320866,0.9988554130363908],[1,-0.1261771947815869,5.312755955821363,1.356947306578145]]],[1,"40GhtM2Y1bgZOrgy9wQpjf",1,0],[1,0.08157700300216675,0.006247282028198242,-0.12238441407680511],[3,0.9290023395148231,0.3079701645178377,-0.06974732092525232,0.19298793269681716],[1,151.3789632812749,17.241735558793838,33.044430410905846]],[14,"Bip001 L Finger1",4,[[6,"Bip001 L Finger11",-45,[1,"82YHmJYpNUwIRpMz6/x7rh",1,0],[1,0.0953603982925415,-2.384185791015625e-7,5.960464477539063e-8],[3,1.0302478230703421e-8,-1.3092540701434747e-8,0.2016598630980403,0.9794556139076848],[1,0.0000015880320747349408,-0.0000018587233107113073,23.268080227659283]]],[1,"efGIrw9kZbM5dp1NBwHMRu",1,0],[1,0.2140156626701355,0.02871990203857422,-0.07965849339962006],[3,0.14175589132700384,0.05487470977109217,0.29237341365277086,0.9441460800589339],[1,16.628244260928607,1.4427303831348735,34.58610116822202]],[14,"Bip001 L Finger2",4,[[6,"Bip001 L Finger21",-46,[1,"56GP/33ipbt5RscKxkRlan",1,0],[1,0.07172501087188721,1.1920928955078125e-7,5.960464477539063e-8],[3,-1.0171859984491851e-17,-1.4991040769140968e-17,0.13798254917676323,0.9904346601985827],[1,-9.53743987823341e-16,-1.601566231679269e-15,15.862243670868283]]],[1,"a3opXY1K1bs63KtREsU6Cj",1,0],[1,0.20017272233963013,0.027018070220947266,0.010468840599060059],[3,0.016227573424614575,-0.07892323415809137,0.25775862166212676,0.9628438512706079],[1,4.745212621468258,-10.625984962258268,29.590727366189885]],[7,"Bip001 R Clavicle",5,[-47],[1,"80Sxap8RleT7LfBkzDAi93",1,0],[1,-0.2908914089202881,0.1143791675567627,-0.056598000228405],[3,0.7404158188458404,0.19713941411025176,-0.5926951228460576,0.24825985974701364],[1,143.03551574473522,77.30872223520217,-0.1349050251337831]],[7,"Bip001 R UpperArm",18,[-48],[1,"94nYA+SUZazqUalPScGfCg",1,0],[1,0.2798118591308594,4.440892098500626e-16,0],[3,0.24198129715613026,-0.5819780812733067,-0.35439678942351904,0.6907600744038257],[1,-7.056981598696757,-83.5586140647127,-50.46734445139137]],[7,"Bip001 R Forearm",19,[6],[1,"39NhMc+jhSCqKPANQHLh8+",1,0],[1,0.5204557180404663,1.1920928955078125e-7,0],[3,4.9317570815256714e-17,-8.45495145977068e-18,-0.6873185717527179,0.7263560978774832],[1,6.231598940146356e-14,5.763298592223944e-14,-86.83644720676268]],[14,"Bip001 R Finger0",6,[[6,"Bip001 R Finger01",-49,[1,"84l6lm3SBYBZ8FSo3q+7NM",1,0],[1,0.11112487316131592,2.220446049250313e-16,-1.1920928955078125e-7],[3,0.0005510246851597509,-0.046329632441594146,0.011879634122409057,0.9988554128715231],[1,0.12617478816212,-5.3127559293270386,1.356949127499545]]],[1,"47JEn10QFZeY7XBihtHdxT",1,0],[1,0.0954056978225708,0.005409955978393555,0.10597886145114899],[3,0.9290023316959993,0.30797019172817003,0.06974726818416987,-0.19298794597372107],[1,-151.37896227054966,-17.241730691025925,33.044434802218554]],[14,"Bip001 R Finger1",6,[[6,"Bip001 R Finger11",-50,[1,"e57STHoJpa0p56K4UDKx2N",1,0],[1,0.09536051750183105,1.1920928955078125e-7,5.960464477539063e-8],[3,-1.0302478230703421e-8,1.3092540701434747e-8,0.2016598630980403,0.9794556139076848],[1,-0.0000015880320747349408,0.0000018587233107113073,23.268080227659283]]],[1,"53/rmZzdJZL463F9C5r7qA",1,0],[1,0.2140156626701355,0.02871990203857422,0.07965849339962006],[3,-0.14175589118211213,-0.0548747283414547,0.2923734133539298,0.9441460790939021],[1,-16.628243493903444,-1.4427328337497123,34.58610145498249]],[14,"Bip001 R Finger2",6,[[6,"Bip001 R Finger21",-51,[1,"6cklssd71bQpgcGHdZO8+Q",1,0],[1,0.07172489166259766,0,0],[3,4.893729611197911e-18,-3.696921671140056e-18,0.13798254917676323,0.9904346601985827],[1,6.381709387020008e-16,-5.16634253009268e-16,15.862243670868283]]],[1,"9fgNNDboxcjIG+O1o8GHRt",1,0],[1,0.20017272233963013,0.027018070220947266,-0.010468810796737671],[3,-0.016227580863691093,0.07892324155272112,0.2577586214793942,0.9628438505880201],[1,-4.745213810691006,10.625986151481015,29.59072722663627]],[7,"Bip001 L Thigh",3,[-52],[1,"1aOCmC7G1QLYh3hQ/RIfCW",1,0],[1,-0.39984893798828125,-0.30053311586380005,0.3836286962032318],[3,0.7178273552306246,0.680038369359236,0.1348885996845741,0.06384958854192135],[1,-126.10226971349779,-70.08105235291427,83.47655542639572]],[7,"Bip001 L Calf",24,[-53],[1,"dbtmT0gRdSBIMmHDpIZtZm",1,0],[1,0.743604302406311,-1.1920928955078125e-7,-2.7755575615628914e-17],[3,0,0,-0.41653967720321833,0.909117537678951],[1,0,0,-49.23262954822765]],[14,"Bip001 L Foot",25,[[6,"Bip001 L Toe0",-54,[1,"0ej8X8mtRS8IOXZwhuA0cA",1,0],[1,0.0993526503443718,0.3203730583190918,0.015012085437774658],[3,-0.012606775107827504,-0.004188367072502582,0.7176545698822673,0.6962725365327463],[1,-159.190288938885,157.82919259324692,88.13791814938088]]],[1,"27lKXEzcFQsZTcP6tappE1",1,0],[1,0.8391543626785278,2.9802322387695312e-8,0],[3,0.09368384456679991,0.04668617534947475,0.18506039337690455,0.9771368323329169],[1,10.282468224363756,3.491167402013983,21.740666790231035]],[7,"Bip001 R Thigh",3,[-55],[1,"abAw8bUFFfbJbDdcCTemu+",1,0],[1,-0.399849534034729,-0.3005313277244568,-0.3836267292499542],[3,0.7178270792704299,0.6800386286793662,-0.134887694859659,-0.06385184057972494],[1,126.10304314074824,70.08038736689647,83.47680202680553]],[7,"Bip001 R Calf",27,[-56],[1,"54Lh51XGBYv7YuKOF5iKJs",1,0],[1,0.7436041831970215,0,5.551115123125783e-17],[3,-5.0466161121084984e-17,2.312259701504717e-17,-0.41653967720321833,0.909117537678951],[1,-6.361109362927037e-15,0,-49.23262954822765]],[14,"Bip001 R Foot",28,[[6,"Bip001 R Toe0",-57,[1,"46OYGFnqVWX54eydGHqJue",1,0],[1,0.09935265779495239,0.320372998714447,-0.01501205563545227],[3,0.012606777493592694,0.004188363055347829,0.7176545996614502,0.6962725058200326],[1,159.19032927263092,-157.8292330582914,88.13791339787937]]],[1,"a0sQDO/bdTOryUmf6KpZ23",1,0],[1,0.8391544222831726,-5.551115123125783e-17,1.4901161193847656e-8],[3,-0.0936838530691832,-0.04668609764253182,0.1850603507511224,0.9771368433033805],[1,-10.282471032387543,-3.4911582401498076,21.740661053193115]],[7,"Bip001 Xtra_Tail",3,[-58],[1,"82O4d8FFlZfbWoM1gQ5T0P",1,0],[1,-0.9858397245407104,-0.43601518869400024,0.000001985863264053478],[3,9.877768196883434e-7,-0.0000026041092780163377,0.9789544108644718,-0.20407905684130798],[1,179.999706525755,-179.99994555523935,-23.551186460093533]],[14,"Bip001 Xtra_Tail1",30,[[6,"Bip001 Xtra_Tail2",-59,[1,"32EOimsNxW6auKvQxSU90n",1,0],[1,0.9689803123474121,-0.0008437633514404297,-2.9117472877260298e-9],[3,3.4403779720176436e-7,5.077550272064185e-7,-0.010108478258240874,0.9999489080282684],[1,0.00004001814766795572,0.00005859195632515687,-1.1583660107752876]]],[1,"b98OsIwtddvaimim2Y6TQy",1,0],[1,0.7776881456375122,-0.0007715225219726562,-2.1395862859208137e-9],[3,1.7354177343170095e-13,2.4402726421175402e-8,-0.008798220935442457,0.9999612949051431],[1,2.4626572286066044e-8,0.000002796671380546391,-1.0082148613665045]]],0,[0,10,1,0,0,1,0,-1,8,0,-2,9,0,10,1,0,1,1,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,-12,7,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,-1,11,0,-2,24,0,-3,27,0,-4,30,0,-1,15,0,-2,16,0,-3,17,0,1,4,0,-2,12,0,-3,18,0,-1,21,0,-2,22,0,-3,23,0,1,7,0,1,7,0,0,8,0,-1,10,0,-1,13,0,-1,14,0,1,15,0,1,16,0,1,17,0,-1,19,0,-1,20,0,1,21,0,1,22,0,1,23,0,-1,25,0,-1,26,0,1,26,0,-1,28,0,-1,29,0,1,29,0,-1,31,0,1,31,0,16,1,2,1,5,3,1,10,4,1,14,5,1,11,6,1,20,59],[0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,14,19],[10,10,10,10,39,26,40]],[[[66,"Skin-0",498196334,["Bip001/Bip001 Pelvis","Bip001/Bip001 Pelvis/Bip001 Spine","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_EarL","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L Foot","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L Foot/Bip001 L Toe0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Xtra_Tail","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Xtra_Tail/Bip001 Xtra_Tail1","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Xtra_Tail/Bip001 Xtra_Tail1/Bip001 Xtra_Tail2","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Teath_Up","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra11_Nose","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Mouth_Cor_L","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Mouth_Up_L","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Eye_L","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Jaw","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Eyelid_up_R","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Eyelid_Low_R","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_eyebrownL","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_EarR","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger1","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger2","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger0/Bip001 L Finger01","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger2/Bip001 L Finger21","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger1/Bip001 L Finger11","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Jaw/Bip001 Xtra_Teath_Low","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Jaw/Bip001 Xtra_Tongue","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R Foot","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R Foot/Bip001 R Toe0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Mouth_Cor_R","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Mouth_Up_R","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Eye_R","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Eyelid_up_L","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_eyebrownR","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Eyelid_Low_L","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger1","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger2","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger0/Bip001 R Finger01","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger2/Bip001 R Finger21","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger1/Bip001 R Finger11"],[[[7,-2.2991228831870103e-7,0.0000021223245312285144,1,0,-0.843885064125061,-0.5365239381790161,9.446583248973184e-7,0,0.5365239381790161,-0.843885064125061,0.000001914351514642476,0,-1.223990797996521,1.0912352800369263,-0.000002653238425409654,1],[7,0.0000021580426619038917,-0.0000017917390096044983,1,0,-0.9102181792259216,-0.41412901878356934,0.000001222278569912305,0,0.41412901878356934,-0.9102181792259216,-0.000002524581532270531,0,-1.4604322910308838,0.9501123428344727,0.000005443584086606279,1],[7,0.0000022673089006275404,-0.0000020804122868867125,1,0,-0.9563044905662537,-0.292372465133667,0.0000015599825928802602,0,0.292372465133667,-0.9563044905662537,-0.0000026524064651312074,0,-1.7789958715438843,1.1916745901107788,0.000006113581548561342,1],[7,0.10681141912937164,0.27512702345848083,-0.9554561376571655,0,-0.4466782212257385,-0.8452445864677429,-0.29332584142684937,0,-0.8882960677146912,0.458111971616745,0.03261147439479828,0,1.160521388053894,-1.2064440250396729,0.18384863436222076,1],[7,-0.10681033879518509,-0.2751246392726898,-0.9554569125175476,0,-0.44667848944664,-0.845245361328125,0.29332321882247925,0,-0.8882960081100464,0.45811203122138977,-0.03261130675673485,0,1.1605212688446045,-1.206444501876831,-0.18384996056556702,1],[7,0.0000013430887975118821,-0.0000014026934422872728,1,0,6.123234262925839e-17,-1,-0.0000014026934422872728,0,1,1.8840031531380808e-12,-0.0000013430887975118821,0,-2.076772928237915,-2.1481194496154785,-0.000003301154720247723,1],[7,0.623935878276825,0.2926383912563324,0.7246147394180298,0,0.03692517429590225,-0.9372434616088867,0.34671449661254883,0,0.7806026339530945,-0.18957112729549408,-0.5955855250358582,0,-2.168097972869873,-1.5236104726791382,2.1878583431243896,1],[7,0.02202714793384075,0.0956166461110115,-0.9951744675636292,0,0.009938792325556278,-0.995387852191925,-0.09541713446378708,0,-0.9997080564498901,-0.007789065130054951,-0.022875864058732986,0,0.13629859685897827,-0.5169750452041626,0.3017520010471344,1],[7,0.10710428655147552,-0.0014616863336414099,-0.994246780872345,0,-0.993991494178772,0.022551216185092926,-0.1071099266409874,0,0.022578034549951553,0.9997446537017822,0.0009624279337003827,0,-0.8415331840515137,-0.01824263297021389,0.27608951926231384,1],[7,-0.13862541317939758,0.26055049896240234,-0.9554561376571655,0,0.3484842777252197,-0.890235185623169,-0.29332584142684937,0,-0.9270067811012268,-0.37362387776374817,0.03261147066950798,0,1.1859633922576904,-0.4720359742641449,0.18384864926338196,1],[7,-3.912690829110943e-7,-0.000002997001274707145,1,0,0.9998729825019836,0.015939252451062202,4.389893035749992e-7,0,-0.015939252451062202,0.9998729825019836,0.0000029903837912570452,0,-0.11879183351993561,-1.460300087928772,-0.000004473049102671212,1],[7,-3.872775948821072e-7,-0.000003003851134053548,1,0,0.999437689781189,0.03353030979633331,4.877799142377626e-7,0,-0.03353030979633331,0.999437689781189,0.0000029891764370404417,0,-0.870659589767456,-1.4750769138336182,-0.000004514033662417205,1],[7,0.9755656123161316,-0.13394685089588165,-0.17415523529052734,0,-0.1293656975030899,0.2904920279979706,-0.9480922818183899,0,0.1775846928358078,0.9474558234214783,0.26606589555740356,0,-0.5785400867462158,-1.0337923765182495,-2.120706558227539,1],[7,0.2831258773803711,0.24831736087799072,0.9263790845870972,0,0.3663841784000397,0.8646398186683655,-0.34374475479125977,0,-0.8863420486450195,0.4367336332798004,0.1538223773241043,0,2.077375650405884,0.7522141337394714,-1.1922980546951294,1],[7,-0.23231428861618042,0.29639819264411926,0.9263790249824524,0,-0.843102753162384,0.4135422110557556,-0.34374481439590454,0,-0.4849821925163269,-0.8608895540237427,0.1538223773241043,0,-0.6651468276977539,1.5960592031478882,-1.1922980546951294,1],[7,-0.213507741689682,-0.08444567769765854,0.9732848405838013,0,-0.30786123871803284,0.9513128995895386,0.015004347078502178,0,-0.9271654486656189,-0.29643312096595764,-0.2291102409362793,0,0.29363712668418884,2.337261199951172,-0.08092508465051651,1],[7,0.0000014165001402943744,-8.723572477720154e-7,1,0,-0.597450852394104,-0.8019054532051086,1.4674117210233817e-7,0,0.8019054532051086,-0.597450852394104,-0.000001657090024309582,0,-2.6777422428131104,-0.33347174525260925,5.395536391006317e-7,1],[7,-0.9755649566650391,0.13394547998905182,-0.1741597205400467,0,-0.12937031686306,0.2904926538467407,0.948091447353363,0,0.1775846779346466,0.9474558234214783,-0.26606592535972595,0,-0.5785455107688904,-1.0337915420532227,2.1207056045532227,1],[7,-0.0000013488855756804696,-0.0000023332913769991137,1,0,0.9985556602478027,0.05372799560427666,0.0000014723001413585735,0,-0.05372799560427666,0.9985556602478027,0.0000022574481590709183,0,-1.809460997581482,-1.5111218690872192,-0.0000053369362831290346,1],[7,-1.2642155411413114e-7,0.0000018987676639881101,1,0,-0.9447540640830994,0.3277801275253296,-7.418154837068869e-7,0,-0.3277801275253296,-0.9447540640830994,0.0000017524298527860083,0,-1.8715406656265259,2.849992513656616,-0.000012257460184628144,1],[7,1.820463069179823e-7,-0.000004132366029807599,1,0,-0.13279256224632263,0.9911437630653381,0.000004119944151170785,0,-0.9911437630653381,-0.13279256224632263,-3.683135219034739e-7,0,1.8204394578933716,3.1814632415771484,0.000009789751857169904,1],[7,-0.1507934033870697,0.03783423453569412,0.987841010093689,0,-0.9465226531028748,0.282792329788208,-0.15531708300113678,0,-0.28523018956184387,-0.9584346413612366,-0.006832254584878683,0,-1.9640837907791138,2.722384452819824,-0.5220943093299866,1],[7,0.008424214087426662,0.001503507373854518,0.9999633431434631,0,-0.9603582620620728,0.278662770986557,0.007671574596315622,0,-0.2786410450935364,-0.9603877067565918,0.0037914214190095663,0,-2.1071245670318604,2.730989933013916,-0.055643029510974884,1],[7,0.5892452001571655,0.15174312889575958,0.7935767769813538,0,-0.8077134490013123,0.08665431290864944,0.5831723809242249,0,0.019725549966096878,-0.9846141338348389,0.17362560331821442,0,-2.148092031478882,2.5000483989715576,0.9389092922210693,1],[7,0.0000010344812153562088,-0.00000304272657558613,1,0,-0.9677857756614685,0.25177520513534546,0.0000017672391550149769,0,-0.25177520513534546,-0.9677857756614685,-0.000002684250603124383,0,-1.9267382621765137,2.6261889934539795,0.000007445625215041218,1],[7,0.4152470529079437,0.7371376752853394,0.5331021547317505,0,-0.2337615191936493,0.6527981162071228,-0.7205623388290405,0,-0.8791617155075073,0.17459262907505035,0.4433869421482086,0,1.4375085830688477,1.1230813264846802,-3.0137319564819336,1],[7,-0.0958782434463501,-0.788364827632904,0.6076908707618713,0,-0.00949897337704897,-0.6097509264945984,-0.7925361394882202,0,0.9953477382659912,-0.08175940811634064,0.05097319558262825,0,-2.290165662765503,-1.2159446477890015,-2.2705013751983643,1],[7,0.6542202830314636,0.6950106024742126,0.29825499653816223,0,0.7259984016418457,-0.6876254677772522,0.00987104419618845,0,0.2119482159614563,0.21007481217384338,-0.9544351696968079,0,1.2762246131896973,-2.40203857421875,2.342348098754883,1],[7,-0.4587996006011963,0.24139876663684845,-0.8551197052001953,0,0.2685454785823822,-0.8797081112861633,-0.3924235999584198,0,-0.8469869494438171,-0.4096819758415222,0.33878323435783386,0,1.4305472373962402,-1.5750685930252075,-0.976220428943634,1],[7,-0.6239359378814697,-0.29264163970947266,0.7246133685112,0,0.036924704909324646,-0.937241792678833,-0.3467191755771637,0,0.7806023955345154,-0.1895744502544403,0.5955846905708313,0,-2.1680946350097656,-1.523597240447998,-2.187870740890503,1],[7,-0.24382926523685455,0.33969470858573914,0.9083805084228516,0,0.28632235527038574,0.9201139211654663,-0.2672272026538849,0,-0.9265890717506409,0.19493180513381958,-0.32161274552345276,0,1.375985860824585,1.7779854536056519,-0.5302243828773499,1],[7,-0.06811316311359406,0.02415967918932438,0.9973849654197693,0,0.20904749631881714,0.9778598546981812,-0.009410499595105648,0,-0.9755297899246216,0.20785993337631226,-0.07165571302175522,0,1.2060257196426392,1.9562736749649048,-0.2698199152946472,1],[7,-0.3718286454677582,0.25224223732948303,-0.8933741450309753,0,0.28280961513519287,-0.8858461976051331,-0.3678242564201355,0,-0.8841734528541565,-0.38942211866378784,0.2580465078353882,0,1.3493281602859497,-1.6055940389633179,-0.8549889922142029,1],[7,-0.05891624465584755,0.04185635223984718,0.9973849654197693,0,0.4683610796928406,0.8834865689277649,-0.009410044178366661,0,-0.8815698623657227,0.4665820896625519,-0.07165566831827164,0,1.625807523727417,1.5717490911483765,-0.2698189914226532,1],[7,-0.08980692923069,0.4083864986896515,0.9083806872367859,0,0.6265106797218323,0.7321711778640747,-0.26722678542137146,0,-0.7742215991020203,0.5451115369796753,-0.32161247730255127,0,1.8788316249847412,1.1274861097335815,-0.5302237272262573,1],[7,0.000008730880836083088,0.000005115045496495441,1,0,-0.9498062133789062,0.31283774971961975,0.000006692473107250407,0,-0.31283754110336304,-0.949806809425354,0.000007589652796013979,0,-1.8909850120544434,2.783221960067749,-0.0000040729460124566685,1],[7,5.930592124059331e-7,-0.0000035909574762627017,1,0,-0.9876986742019653,0.15636876225471497,0.0000011472766345832497,0,-0.15636862814426422,-0.9876995086669922,-0.000003454045781836612,0,-2.264909029006958,2.4453847408294678,0.0000029631078177771997,1],[7,0.13862431049346924,-0.2605481743812561,-0.9554569125175476,0,0.3484846353530884,-0.8902359008789062,0.293323278427124,0,-0.9270068407058716,-0.3736238479614258,-0.03261130675673485,0,1.18596351146698,-0.4720363914966583,-0.18384990096092224,1],[7,-0.02202717401087284,-0.09561396390199661,-0.995174765586853,0,0.009938732720911503,-0.9953881502151489,0.09541445970535278,0,-0.9997080564498901,-0.007789065130054951,0.022875864058732986,0,0.13629856705665588,-0.5169752240180969,-0.30175334215164185,1],[7,-0.10710158199071884,0.0014616352273151278,-0.9942470788955688,0,-0.9939919114112854,0.0225512832403183,0.10710721462965012,0,0.022578099742531776,0.999744713306427,-0.0009624242084100842,0,-0.8415333032608032,-0.018242577090859413,-0.2760908901691437,1],[7,-0.2831268906593323,-0.24831974506378174,0.9263781309127808,0,0.3663834035396576,0.864639163017273,0.3437473177909851,0,-0.8863420486450195,0.4367336630821228,-0.1538223773241043,0,2.0773754119873047,0.7522141933441162,1.1923000812530518,1],[7,0.23231659829616547,-0.2963992953300476,0.9263781309127808,0,-0.8431020975112915,0.41354137659072876,0.3437473475933075,0,-0.4849821627140045,-0.8608895540237427,-0.1538223773241043,0,-0.6651470065116882,1.596058964729309,1.1923000812530518,1],[7,0.21350860595703125,0.08444306999444962,0.9732848405838013,0,-0.30786067247390747,0.9513130187988281,-0.015001680701971054,0,-0.9271654486656189,-0.29643312096595764,0.2291102558374405,0,0.2936372756958008,2.337261915206909,0.08092702180147171,1],[7,0.15079596638679504,-0.03784048184752464,0.987840473651886,0,-0.9465222358703613,0.2827913463115692,0.15532134473323822,0,-0.2852301597595215,-0.9584347009658813,0.006826938595622778,0,-1.9640837907791138,2.722381591796875,0.5221090912818909,1],[7,-0.008421581238508224,-0.0015098185976967216,0.9999634027481079,0,-0.9603583216667175,0.2786628305912018,-0.007667286787182093,0,-0.27864107489585876,-0.960387647151947,-0.003796749282628298,0,-2.1071248054504395,2.730989456176758,0.05565791204571724,1],[7,-0.5892429351806641,-0.15174777805805206,0.7935775518417358,0,-0.8077150583267212,0.08665712177753448,-0.5831696391105652,0,0.019725549966096878,-0.9846131801605225,-0.17363105714321136,0,-2.1480917930603027,2.500053644180298,-0.938895583152771,1],[7,-0.4152464270591736,-0.7371426224708557,0.5330958962440491,0,-0.23376278579235077,0.6527919769287109,0.7205675840377808,0,-0.8791617155075073,0.17459513247013092,-0.4433860778808594,0,1.4375083446502686,1.1230642795562744,3.0137386322021484,1],[7,-0.654222309589386,-0.6950103044509888,0.29825112223625183,0,0.7259965538978577,-0.6876273155212402,-0.009874043054878712,0,0.2119482010602951,0.21006949245929718,0.9544363021850586,0,1.2762247323989868,-2.4020254611968994,-2.3423614501953125,1],[7,0.09587827324867249,0.7883630990982056,0.6076930165290833,0,-0.009498710744082928,-0.6097531318664551,0.792534351348877,0,0.9953477382659912,-0.08175912499427795,-0.050973646342754364,0,-2.290165662765503,-1.2159574031829834,2.270494222640991,1],[7,0.4587988257408142,-0.24139617383480072,-0.855120837688446,0,0.26854678988456726,-0.8797087669372559,0.3924211263656616,0,-0.8469869494438171,-0.40968194603919983,-0.33878326416015625,0,1.424010157585144,-1.5891488790512085,0.9613828063011169,1],[7,0.24382849037647247,-0.3396972119808197,0.9083797335624695,0,0.28632304072380066,0.9201129078865051,0.26722967624664307,0,-0.9265890717506409,0.1949317902326584,0.32161277532577515,0,1.3759866952896118,1.7779853343963623,0.5302263498306274,1],[7,0.06811259686946869,-0.02416236512362957,0.9973849654197693,0,0.20904769003391266,0.977859616279602,0.009413241408765316,0,-0.9755297899246216,0.20785990357398987,0.07165572792291641,0,1.2060259580612183,1.9562740325927734,0.2698219418525696,1],[7,0.3718278110027313,-0.25223955512046814,-0.8933753371238708,0,0.2828107178211212,-0.8858469128608704,0.3678215742111206,0,-0.8841734528541565,-0.38942208886146545,-0.25804653763771057,0,1.3582377433776855,-1.6199241876602173,0.8392590284347534,1],[7,0.05891496315598488,-0.04185879975557327,0.9973850250244141,0,0.4683612585067749,0.8834863305091858,0.009412799961864948,0,-0.8815698027610779,0.4665820598602295,0.07165569067001343,0,1.6258078813552856,1.571749210357666,0.26982104778289795,1],[7,0.0898052304983139,-0.4083884656429291,0.9083799719810486,0,0.6265109181404114,0.7321699857711792,0.26722925901412964,0,-0.7742215394973755,0.5451115369796753,0.32161247730255127,0,1.878832221031189,1.1274856328964233,0.5302256345748901,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[25,"VD302_Kangaroo_Eye",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"albedoScale":1,"metallic":0,"roughness":0,"emissiveScale":1,"alphaSource":1},"mainColor",8,[4,4294967295],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[15,12],[113,5]],[[[25,"VD302_Kangaroo_Toy",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"albedoScale":1,"metallic":0,"roughness":1,"emissiveScale":1,"alphaSource":1},"mainColor",8,[4,4294967295],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[15,12],[114,5]],[[[28,".bin",677989383,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":184512,"length":16002,"count":8001,"stride":2}},{"primitiveMode":7,"jointMapIndex":1,"vertexBundelIndices":[1],"indexView":{"offset":329346,"length":8946,"count":4473,"stride":2}},{"primitiveMode":7,"jointMapIndex":2,"vertexBundelIndices":[2],"indexView":{"offset":477108,"length":10176,"count":5088,"stride":2}},{"primitiveMode":7,"jointMapIndex":2,"vertexBundelIndices":[3],"indexView":{"offset":509940,"length":1008,"count":504,"stride":2}},{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[4],"indexView":{"offset":528420,"length":3840,"count":960,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":184512,"count":1922,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":200514,"length":128832,"count":1342,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":338292,"length":138816,"count":1446,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":487284,"length":22656,"count":236,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":510948,"length":17472,"count":182,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,18,21,23,24,25,26,28,31,32,33,34,37,45],[0,1,2,3,4,5,6,9,10,11,12,16,17,18,19,24,29,31,33,34,35,36,37,38,39,40,41,43,46],[0,1,2,3,4,5,9,10,11,16,17,19,24,29,35,36,37,38,39,40,41,42,43,46,48,49,51,52,53,54]]},"minPosition",8,[1,-0.633299708366394,-2.9354195594787598,0],"maxPosition",8,[1,0.633299708366394,2.9354195594787598,3.0187833309173584]]],-1],0,0,[],[],[]],[[{"name":"UI_MM_pin","rect":{"x":0,"y":0,"width":85,"height":92},"offset":{"x":0,"y":0},"originalSize":{"width":85,"height":92},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[115]],[[[25,"VD289_Lion_Toy",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"albedoScale":1,"metallic":0,"roughness":1,"emissiveScale":1,"alphaSource":1},"mainColor",8,[4,4294967295],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[15,12],[116,5]],[[[66,"Skin-0",2148985371,["Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh","Bip001/Bip001 Pelvis","Bip001/Bip001 Pelvis/Bip001 Spine","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L HorseLink","Bip001/Bip001 Pelvis/Bip001 Tail_01/Bip001 Tail_02/Bip001 Tail_03","Bip001/Bip001 Pelvis/Bip001 Tail_01/Bip001 Tail_02/Bip001 Tail_03/Bip001 Tail_04","Bip001/Bip001 Pelvis/Bip001 Tail_01","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001Neck Giggle","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Xtra_Hair","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Chest Giggle","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L HorseLink/Bip001 L Foot","Bip001/Bip001 Pelvis/Bip001 Tail_01/Bip001 Tail_02","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Bip001 L_Ear","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L HorseLink/Bip001 L Foot/Bip001 L Toe0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Jaw","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 L_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 L_Upper_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 L_Eye Ball","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Jaw/Bip001 Tongue_01","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 R_Upper_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R HorseLink/Bip001 R Foot/Bip001 R Toe0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 L_Lower_Eye","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 L_Upper_Eye","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Bip001 L_Ear/Bip001 Xtra_Lear1","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Jaw/Bip001 L_Lower_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Jaw/Bip001 R_Lower_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 R_Ear","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R HorseLink","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R HorseLink/Bip001 R Foot","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 R_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 R_Upper_Eye","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 R_Lower_Eye","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 R_Ear/Bip001 Xtra_Rear1","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Jaw/Bip001 Lower_Teeth","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Jaw/Bip001 Tongue_01/Bip001 Tongue_02","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 R_Eye Ball"],[[[7,-3.053580428513669e-7,0.0000013296380529936869,-1,0,0.256775826215744,-0.9664709568023682,-0.0000013634652304972406,0,-0.9664709568023682,-0.256775826215744,-4.629919558851725e-8,0,1.3855551481246948,1.015037178993225,0.2612881660461426,1],[7,-0.000004271163561497815,0.0000027876039894181304,1,0,-0.9998416304588318,-0.017792878672480583,-0.00000422088805862586,0,0.017792878672480583,-0.9998416304588318,0.000002863159124899539,0,0.5966652631759644,1.6106069087982178,-0.0000020572379071381874,1],[7,0.000002188548705817084,-0.000004311048542149365,1,0,-0.9932107329368591,0.11632832884788513,0.000002675187715794891,0,-0.11632832884788513,-0.9932107329368591,-0.000004027190243505174,0,0.5168375372886658,1.4000802040100098,0.00000435832316725282,1],[7,-5.676564001078077e-7,0.0000012753492910633213,-1,0,0.256775826215744,-0.9664709568023682,-0.000001378348542857566,0,-0.9664709568023682,-0.256775826215744,2.2114463149591757e-7,0,1.3855538368225098,1.0150392055511475,-0.26128649711608887,1],[7,0.000002346306700928835,-0.000004057476871821564,1,0,-0.9999880790710449,0.004876255057752132,0.000002366064336456475,0,-0.004876255057752132,-0.9999880790710449,-0.000004045987680001417,0,-0.42657774686813354,1.361762285232544,0.000004252044618624495,1],[7,-5.987060944789846e-7,0.0000012258595916136983,-1,0,0.4690953195095062,-0.8831474781036377,-0.0000013634652304972406,0,-0.8831474781036377,-0.4690953195095062,-4.629919558851725e-8,0,0.33147427439689636,1.1192612648010254,0.2612881660461426,1],[7,5.818359838372089e-8,0.0000013630082094095997,-1,0,-0.00871762353926897,-0.9999619722366333,-0.0000013634636388815125,0,-0.9999619722366333,0.00871762353926897,-4.629919558851725e-8,0,0.5982152223587036,0.9488317370414734,0.26128819584846497,1],[7,-0.000004236486347508617,-0.000002751383590293699,1,0,0.9999504685401917,-0.009945729747414589,0.000004208912741887616,0,0.009945729747414589,0.9999504685401917,0.00000279338269137952,0,-1.8848037719726562,-1.8109633922576904,-0.000010619799468258861,1],[7,-0.000003647768835435272,-5.04460501815629e-7,1,0,0.9999739527702332,-0.007211687974631786,0.0000036440360418055207,0,0.007211687974631786,0.9999739527702332,5.307539936438843e-7,0,-2.4394681453704834,-1.8218427896499634,-0.0000050889152589661535,1],[7,-0.0000013709058066524449,-0.000002772508651105454,1,0,0.9999995231628418,-0.0007962750387378037,0.0000013686978945770534,0,0.0007962750387378037,0.9999995231628418,0.0000027735998173739063,0,-0.9221391677856445,-1.8173305988311768,-0.00000605868035563617,1],[7,-0.05474542826414108,-0.009147865697741508,0.9984584450721741,0,0.10459691286087036,0.9944038987159729,0.014845762401819229,0,-0.9930067658424377,0.10524840652942657,-0.05348222702741623,0,1.502079963684082,0.9243525862693787,-0.23913556337356567,1],[7,0.000001879893147815892,-0.000004676097432820825,1,0,-0.9566370844841003,0.2912822365760803,0.00000316043997372617,0,-0.2912822365760803,-0.9566370844841003,-0.00000392574929719558,0,-1.0982829332351685,1.5582553148269653,0.000004133215043111704,1],[7,-0.0000013096339444018668,-0.0000031788708838575985,1,0,0.9553048014640808,0.2956223487854004,0.0000021908451799390605,0,-0.2956223487854004,0.9553048014640808,0.000002649634097906528,0,1.6887753009796143,-1.6293219327926636,-0.0000028921190278197173,1],[7,0.4700365364551544,0.8689171075820923,0.15507622063159943,0,0.31667274236679077,-0.002017348539084196,-0.9485326409339905,0,-0.8238834142684937,0.494953453540802,-0.27611061930656433,0,1.5526994466781616,-0.9722108840942383,-0.6871752142906189,1],[7,0.0000013239805412013084,-0.0000031292283892980777,1,0,-0.9657670855522156,0.25941088795661926,0.0000020904124085063813,0,-0.25941088795661926,-0.9657670855522156,-0.0000026786506168718915,0,-0.9883826971054077,2.2811074256896973,0.000002281797605974134,1],[7,-0.47004011273384094,-0.868915855884552,0.15507251024246216,0,0.3166705369949341,-0.002021381864324212,0.9485333561897278,0,-0.8238822221755981,0.4949556887149811,0.2761102020740509,0,1.5526989698410034,-0.9722117185592651,0.687175452709198,1],[7,-0.05373343080282211,-0.013909182511270046,0.9984584450721741,0,0.01707155816257,0.9997439980506897,0.014845822006464005,0,-0.9984093308448792,0.017842955887317657,-0.05348222330212593,0,0.6888176798820496,0.9885033965110779,-0.2391355037689209,1],[7,-0.000001743067855386471,-0.000004802195689990185,1,0,0.21240085363388062,0.9771825075149536,0.000005062851869297447,0,-0.9771825075149536,0.21240085363388062,-6.833050747445668e-7,0,0.9301970601081848,0.2071494460105896,-0.0000011898994216608116,1],[7,0.0031883339397609234,-0.05161985009908676,0.9986617565155029,0,-0.9999527335166931,-0.009327254258096218,0.002710339380428195,0,0.009174864739179611,-0.9986231327056885,-0.051647163927555084,0,-1.1554360389709473,0.06005057319998741,-0.2441503405570984,1],[7,-0.05164109915494919,-0.002028260612860322,0.998663604259491,0,-0.0022602304816246033,0.9999955892562866,0.001914088730700314,0,-0.9986631274223328,-0.002158364513888955,-0.05164545774459839,0,0.17847582697868347,0.9889724850654602,-0.2522744834423065,1],[7,-0.0000026164243536186405,0.000003467642045507091,-1,0,0.0025842629838734865,-0.9999967217445374,-0.0000034743916330626234,0,-0.9999967217445374,-0.0025842629838734865,0.0000026074542347487295,0,0.1560952514410019,0.9506561160087585,0.2612897455692291,1],[7,-0.00000279784057966026,-0.0000041826997403404675,1,0,0.9999812841415405,0.006104842759668827,0.000002823323256961885,0,-0.006104842759668827,0.9999812841415405,0.00000416554166804417,0,-1.4490381479263306,-1.8334659337997437,-0.000010504343663342297,1],[7,0.648626983165741,0.36859947443008423,0.6658961176872253,0,-0.13380439579486847,-0.8060548305511475,0.5765172243118286,0,0.7492526769638062,-0.4630443751811981,-0.47350868582725525,0,-2.0276529788970947,-0.5765734314918518,1.9002386331558228,1],[7,0.000002442543518554885,8.428528417425696e-7,-1,0,-0.9999925494194031,0.003880994161590934,-0.0000024392538762185723,0,0.003880994161590934,0.9999925494194031,8.52325911182561e-7,0,0.7298500537872314,-0.024920398369431496,0.26128894090652466,1],[7,8.315606123687758e-7,-0.0000034833960853575263,1,0,-0.8579292297363281,0.5137678384780884,0.0000025030772121681366,0,-0.5137678384780884,-0.8579292297363281,-0.0000025612785066186916,0,-0.8776954412460327,2.4470114707946777,0.0000023768395749357296,1],[7,-0.5365011692047119,0.00042451475746929646,0.8438995480537415,0,-0.8148033618927002,0.2600625455379486,-0.5181342959403992,0,-0.21968664228916168,-0.9655916690826416,-0.13917796313762665,0,-1.2727903127670288,2.059884786605835,-0.9937133193016052,1],[7,0.34839677810668945,-0.047688424587249756,0.9361332654953003,0,-0.9061119556427002,0.2385333776473999,0.3493751883506775,0,-0.2399601936340332,-0.9699627161026001,0.03989320248365402,0,-1.7183424234390259,2.049438953399658,0.6295999884605408,1],[7,-0.9999998807907104,0.000421671022195369,-0.00013032501738052815,0,-0.00013061740901321173,-0.0006934906705282629,0.9999997615814209,0,0.0004215805674903095,0.9999995827674866,0.000693545734975487,0,0.1608973741531372,-1.9572935104370117,2.0454792976379395,1],[7,0.0000012741526234094636,-0.0000029701839139306685,1,0,-0.974692165851593,0.22355152666568756,0.0000019058954876527423,0,-0.22355152666568756,-0.974692165851593,-0.000002610175897643785,0,-1.5861706733703613,2.0291032791137695,0.000001656215317780152,1],[7,-0.3483942747116089,0.04768257588148117,0.9361345171928406,0,-0.9061129093170166,0.23853544890880585,-0.3493712842464447,0,-0.2399601936340332,-0.969962477684021,-0.0398985855281353,0,-1.7183395624160767,2.0494420528411865,-0.6295961141586304,1],[7,2.9924990485596936e-7,-8.534938160664751e-7,-1,0,-0.9999925494194031,0.0038810239639133215,-3.0256003924478136e-7,0,0.0038810239639133215,0.9999925494194031,-8.52325911182561e-7,0,0.7298523187637329,-0.02491971291601658,-0.26128724217414856,1],[7,0.02177341841161251,0.3172408938407898,0.9480950236320496,0,-0.9997456669807434,0.0013370864326134324,0.022512199357151985,0,0.005874105263501406,-0.9483439922332764,0.31718936562538147,0,-2.1322848796844482,1.7667109966278076,-0.730063259601593,1],[7,0.021649478003382683,0.31680187582969666,0.9482446312904358,0,-0.9997476935386658,0.001172898686490953,0.022433491423726082,0,0.005994777195155621,-0.9484910368919373,0.3167473077774048,0,-2.147172689437866,1.823690414428711,-0.7367159724235535,1],[7,0.6489221453666687,0.36808302998542786,0.6658942699432373,0,-0.13385029137134552,-0.806315541267395,0.576141893863678,0,0.748988926410675,-0.46300122141838074,-0.4739679992198944,0,-2.192505359649658,-0.5692633390426636,1.894734263420105,1],[7,0.29832497239112854,-0.0400119386613369,0.9536253213882446,0,-0.8621978163719177,0.41726866364479065,0.2872311472892761,0,-0.40941065549850464,-0.9079018831253052,0.08998347073793411,0,-1.3292657136917114,2.3362574577331543,0.4230286478996277,1],[7,-0.2983228862285614,0.04000537842512131,0.953626275062561,0,-0.8621985912322998,0.41727036237716675,-0.2872264087200165,0,-0.40941059589385986,-0.9079013466835022,-0.08998873084783554,0,-1.3292632102966309,2.336259365081787,-0.42302340269088745,1],[7,-0.6486266255378723,-0.368600994348526,0.6658955812454224,0,-0.13380618393421173,-0.8060526251792908,-0.5765198469161987,0,0.7492526769638062,-0.4630470275878906,0.47350606322288513,0,-2.0276477336883545,-0.576559841632843,-1.9002472162246704,1],[7,-8.418801940024423e-7,0.0000011135471140732989,-1,0,0.4690953195095062,-0.8831474781036377,-0.000001378348542857566,0,-0.8831474781036377,-0.4690953195095062,2.2114463149591757e-7,0,0.3314725458621979,1.119262933731079,-0.26128649711608887,1],[7,0.0547451451420784,0.009145164862275124,0.9984585046768188,0,0.1045970618724823,0.9944038987159729,-0.014843050390481949,0,-0.9930067658424377,0.10524840652942657,0.05348223075270653,0,1.5020805597305298,0.9243530035018921,0.23913080990314484,1],[7,0.05373338609933853,0.013906423933804035,0.9984585046768188,0,0.017071707174181938,0.9997440576553345,-0.014843067154288292,0,-0.9984093308448792,0.017842957749962807,0.05348223075270653,0,0.6888182759284973,0.9885038733482361,0.23913079500198364,1],[7,-2.0912028730890597e-7,0.0000013802249441141612,-1,0,-0.00871762353926897,-0.9999619722366333,-0.0000013783495660391054,0,-0.9999619722366333,0.00871762353926897,2.2114463149591757e-7,0,0.5982144474983215,0.9488340020179749,-0.26128649711608887,1],[7,0.051641110330820084,0.0020254631526768208,0.9986636638641357,0,-0.0022600863594561815,0.9999956488609314,-0.0019112949958071113,0,-0.9986631274223328,-0.0021583649795502424,0.05164546146988869,0,0.17847642302513123,0.988973081111908,0.25226980447769165,1],[7,-0.0031855928245931864,0.05161987617611885,0.9986617565155029,0,-0.9999527931213379,-0.009327113628387451,-0.002707601524889469,0,0.00917486660182476,-0.9986231327056885,0.051647163927555084,0,-1.155436635017395,0.06005116179585457,0.24414563179016113,1],[7,0.0000026093389351444785,-7.258095706674794e-7,-1,0,0.0025842629838734865,-0.9999967217445374,7.325502906496695e-7,0,-0.9999967217445374,-0.0025842629838734865,-0.000002607454462122405,0,0.1560945361852646,0.95065838098526,-0.261288046836853,1],[7,0.5365033745765686,-0.0004299054853618145,0.8438981175422668,0,-0.814801812171936,0.2600596845149994,0.51813805103302,0,-0.2196866124868393,-0.9655925035476685,0.13917259871959686,0,-1.2727946043014526,2.0598793029785156,0.9937179684638977,1],[7,-0.021646739915013313,-0.3168071210384369,0.9482429027557373,0,-0.9997478127479553,0.0011721538612619042,-0.022430885583162308,0,0.005994778126478195,-0.9484893083572388,-0.316752552986145,0,-2.147172689437866,1.8236889839172363,0.7367182970046997,1],[7,-0.02177068032324314,-0.31724613904953003,0.9480932950973511,0,-0.999745786190033,0.0013363407924771309,-0.022509591653943062,0,0.00587410619482398,-0.9483422636985779,-0.3171945810317993,0,-2.1322848796844482,1.766709566116333,0.7300653457641602,1],[7,-0.6489195227622986,-0.3680840730667114,0.6658961772918701,0,-0.13385337591171265,-0.80631422996521,-0.5761430859565735,0,0.7489905953407288,-0.46300292015075684,0.4739636778831482,0,-2.192509651184082,-0.5692557692527771,-1.8947311639785767,1],[7,-8.960399213719938e-7,-0.00000214716897062317,1,0,0.903411328792572,-0.42877480387687683,-1.1115923825855134e-7,0,0.42877480387687683,0.903411328792572,0.0000023239763322635554,0,1.2565665245056152,-2.338369846343994,-0.000010862095223274082,1],[7,0.0000012052223610226065,-0.0000032313655538018793,1,0,-0.9067159295082092,0.42174211144447327,0.0000024555968138884054,0,-0.42174211144447327,-0.9067159295082092,-0.000002421637191218906,0,-1.2419465780258179,2.3341405391693115,0.0000025176511826430215,1],[7,0.9999998807907104,-0.00042166843195445836,-0.00012758553202729672,0,-0.00012787559535354376,-0.0006879446445964277,-0.9999997615814209,0,0.0004215805674903095,0.9999995827674866,-0.0006879985448904335,0,0.16088926792144775,-1.9572821855545044,-2.045490264892578,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[25,"VD289_Lion_Eye",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"albedoScale":1,"metallic":0,"roughness":0,"emissiveScale":1,"alphaSource":1},"mainColor",8,[4,4294967295],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[15,12],[117,5]],[[[28,".bin",3237067649,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":69216,"length":5202,"count":2601,"stride":2}},{"primitiveMode":7,"jointMapIndex":1,"vertexBundelIndices":[1],"indexView":{"offset":127890,"length":3732,"count":1866,"stride":2}},{"primitiveMode":7,"jointMapIndex":2,"vertexBundelIndices":[2],"indexView":{"offset":168582,"length":2430,"count":1215,"stride":2}},{"primitiveMode":7,"jointMapIndex":3,"vertexBundelIndices":[3],"indexView":{"offset":217764,"length":2718,"count":1359,"stride":2}},{"primitiveMode":7,"jointMapIndex":4,"vertexBundelIndices":[4],"indexView":{"offset":284514,"length":4962,"count":2481,"stride":2}},{"primitiveMode":7,"jointMapIndex":5,"vertexBundelIndices":[5],"indexView":{"offset":344676,"length":4020,"count":2010,"stride":2}},{"primitiveMode":7,"jointMapIndex":6,"vertexBundelIndices":[6],"indexView":{"offset":416952,"length":4446,"count":2223,"stride":2}},{"primitiveMode":7,"jointMapIndex":7,"vertexBundelIndices":[7],"indexView":{"offset":688182,"length":21576,"count":10788,"stride":2}},{"primitiveMode":7,"jointMapIndex":8,"vertexBundelIndices":[8],"indexView":{"offset":744414,"length":2646,"count":1323,"stride":2}},{"primitiveMode":7,"jointMapIndex":2,"vertexBundelIndices":[9],"indexView":{"offset":764532,"length":3840,"count":960,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":69216,"count":721,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":74418,"length":53472,"count":557,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":131622,"length":36960,"count":385,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":171012,"length":46752,"count":487,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":220482,"length":64032,"count":667,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":289476,"length":55200,"count":575,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":348696,"length":68256,"count":711,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":421398,"length":266784,"count":2779,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":709758,"length":34656,"count":361,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":747060,"length":17472,"count":182,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,30,36],[0,1,2,4,5,6,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,28,29,31,32,36],[0,1,2,4,5,6,7,8,9,10,11,12,14,15,16,17,18,19,21,22,24,25,26,27,33,50],[0,1,4,5,6,7,8,9,10,14,16,18,19,20,21,22,23,24,25,26,28,29,31,32,33,34,35],[0,1,2,3,4,5,6,7,8,9,10,11,12,14,15,16,17,21,23,30,37,38,39,40,41,42,43],[0,1,2,3,4,9,11,12,14,15,17,21,22,24,26,28,29,30,36,37,38,39,40,41,42,43,44,45,46],[0,1,2,3,4,7,8,9,11,12,14,17,21,24,26,29,30,35,36,37,38,39,40,41,42,43,44,45,46,47],[0,2,3,4,10,11,12,13,14,15,17,22,24,27,28,33,34,35,36,37,38,39,40,43,44,46,47,48],[0,4,10,11,12,13,14,15,22,26,28,29,33,36,38,47,49]]},"minPosition",8,[1,-0.5391759276390076,-2.413334369659424,-0.010016355663537979],"maxPosition",8,[1,0.5391759276390076,2.9394428730010986,2.5182552337646484]]],-1],0,0,[],[],[]],[[[64],[52,"VD289_Lion_Rig",[[-3,-4,[6,"Bn_FoodSpawn",-6,[1,"35i6tXF4pRNZMhldb3mDjL",-5,0],[1,-0.6544039845466614,0.0000014053456425244804,2.4855852127075195],[3,1.545431187269876e-8,-0.707106721581899,1.5454308319985022e-8,0.7071068407911907],[1,0.0000025044781562438738,-89.99999034065368,-7.67592264999771e-14]]],1,1,4],[[65,-2,[11,"bcbBLaSAhbuZMFUUZNLvRX"]]],[1,"35MaNWaVpaXITwGugCw+yp",-1,0]],[35,"Bip001 Head",[[-7,[6,"Bip001 R_Eye Ball",-8,[1,"c67HP74fZQareDO7QzeXWD",1,0],[1,0.4810067415237427,-0.13871192932128906,-0.16198280453681946],[3,0.7010897311661021,-0.09240155553280946,0.7010379347304301,0.09209210312210751],[1,165.00802974654647,-89.99911001265058,-0.02540769395075313]],[6,"Bip001 L_Eye Ball",-9,[1,"9bdMh8SI5VApTWliW7zitf",1,0],[1,0.4810067415237427,-0.13871288299560547,0.16198202967643738],[3,0.7010897551105225,-0.0923973938139687,-0.7010384951148962,-0.0920918305958545],[1,-165.00839214994963,89.99911191723139,-0.02508957840924875]],-10,-11,[6,"Bip001 R_Lip",-12,[1,"0c+/2xnDxak6fzczZpa12t",1,0],[1,0.6202429533004761,0.2222423553466797,-0.15485885739326477],[3,-0.00011103288813278455,-0.27937534352521404,0.000382185737645578,0.960181888516925],[1,0.000018506947193266856,-32.4458562590536,0.0456060329216003]],[6,"Bip001 L_Lip",-13,[1,"426MOEsD5fQ52qyRgpaw43",1,0],[1,0.6202429533004761,0.22224140167236328,0.15486010909080505],[3,0.00011102969392108471,0.2793753433583419,0.0003837463430075874,0.9601818879434041],[1,-0.00006881972605775448,32.44585627918052,0.04577764213007584]],[6,"Bip001 Upper_Teeth",-14,[1,"aaIJFC4GRcjrd2uk0jbYIV",1,0],[1,0.6855056285858154,0.140275239944458,6.420416411856422e-7],[3,1.9369720990394967e-12,-0.00000276018663500417,0.995163814734005,-0.09822923106919072],[1,179.99967904174824,179.99996831952706,-11.274421660696975]],[6,"Bip001 R_Upper_Lip",-15,[1,"8b3EQn0vVbXY+9L26wjUHK",1,0],[1,0.79768967628479,0.19597196578979492,-0.10700225830078125],[3,0.02535524931192882,0.17689026660986928,-0.006240054417799473,0.9838841428907584],[1,2.98652823969059,20.389324236101686,-0.1895799086119579]],[6,"Bip001 L_Upper_Lip",-16,[1,"78gcp2bbxVXLlxVrakCFv+",1,0],[1,0.79768967628479,0.19597125053405762,0.10700333118438721],[3,-0.02535525307963376,-0.1768902222022912,-0.006241038370526807,0.9838841445366163],[1,-2.986548629297991,-20.38932211967836,-0.1896908986222032]],[6,"Bip001 R_Upper_Eye",-17,[1,"b5e5H9odFf6al2+RZikwCR",1,0],[1,0.5582767724990845,-0.18035387992858887,-0.16731713712215424],[3,-0.1576385977327603,0.0320653176906361,-0.1303367939430467,0.9783323607296732],[1,-18.133109482336906,1.286535775580373,-15.374966949615768]],[6,"Bip001 L_Upper_Eye",-18,[1,"4fY6GcR1hSC5fYnbBbwcE3",1,0],[1,0.5582767724990845,-0.18035483360290527,0.16731615364551544],[3,0.1576385977307024,-0.032064591258594455,-0.13033697275528322,0.9783323607169017],[1,18.133121251843473,-1.2864479857142894,-15.374974130500112]],[6,"Bip001 R_Lower_Eye",-19,[1,"da5hRlZv9Yer2n/hky54Qh",1,0],[1,0.5588425397872925,-0.1220705509185791,-0.1781167834997177],[3,-0.15785925427404585,0.032146625907232565,-0.13026039580506293,0.9783042878202727],[1,-18.1579087033879,1.2938562673416478,-15.368015962628489]],[6,"Bip001 L_Lower_Eye",-20,[1,"f1rzkOtcJUoouALNH9EqMW",1,0],[1,0.5588425397872925,-0.12207150459289551,0.17811612784862518],[3,0.15785923973473004,-0.03214590327458423,-0.130260574917585,0.9783042900627464],[1,18.15791867460493,-1.29376914844599,-15.368023209192646]],[6,"Bn_Mouth",-21,[1,"74Wy3E+Ole54e8k1nw+aEG",1,0],[1,0.7551892995834351,0.18387889862060547,-0.0000018998973700945498],[3,0.6883263572440877,0.02517719747413124,0.7247287614703776,-0.018470434430343463],[1,-176.44982632392762,-92.96540327274604,0.4519622246662741]]],1,4,4,1,1,4,4,4,4,4,4,4,4,4,4],[1,"daokDkTqNZyptqI6QBb1I/",1,0],[1,0.3670990467071533,-0.09131133556365967,-4.3714862840715796e-9],[3,6.019624997662611e-7,-3.6520860217684395e-7,0.32350260898026595,0.9462272781855665],[1,0.00009967105166216462,-0.00007830430389595361,37.749761330843185]],[35,"Bip001 Neck",[[2,-22,-23,[6,"Bip001Neck Giggle",-24,[1,"42aDpB00ZY24pjtaMIy0pw",1,0],[1,0.02900838851928711,0.6082414388656616,0.0000020743948425661074],[3,3.86469865598165e-14,-9.406484298778304e-7,0.33914354814087,0.9407346351408227],[1,0.000047478123142189156,-0.00013169736139046916,39.64940598604298]]],1,1,1,4],[1,"c5EksbV85eBLHQJ5DOQ0Il",1,0],[1,0.8079414367675781,-0.3649176359176636,-7.356898095167708e-7],[3,3.231769190948456e-14,5.528266381495149e-7,-0.19931733748910155,0.9799349973217356],[1,0.000013716448421261177,0.00006743630189398614,-22.994083269461413]],[39,"Bip001 Jaw",2,[[[6,"Bip001 Lower_Teeth",-25,[1,"75WizrvY9f4bbuYTiAsdi4",1,0],[1,0.14788228273391724,-0.0014827251434326172,-3.79127413907554e-8],[3,3.780104082252863e-14,-0.00000277037657122206,0.9988377701388352,0.048198640399960066],[1,179.99968142703355,-179.99998462734527,5.525298067713643]],-26,[6,"Bip001 R_Lower_Lip",-27,[1,"09TAs1TbJfg5Fft1EAp/iz",1,0],[1,0.255571186542511,-0.025275230407714844,-0.08661354333162308],[3,0.02795634202226483,0.1496848596835241,-0.050703662830590454,0.9870369923654431],[1,4.052178660461967,17.43279123633301,-5.262766519849278]],[6,"Bip001 L_Lower_Lip",-28,[1,"9fCz99XCRUdpOH1TnEDrkD",1,0],[1,0.2555714249610901,-0.02527618408203125,0.08661340922117233],[3,-0.027956389263296563,-0.14968480369246534,-0.05070449851968066,0.9870369565891517],[1,-4.052198641800828,-17.432789752534553,-5.262860599178974]]],4,1,4,4],[1,"46yLe9/LNSU4wsF36Y4EdF",1,0],[1,0.5253777503967285,0.16764020919799805,5.410154244600562e-7],[3,-2.650718919003171e-8,-2.1287236392524712e-7,0.13813619241436384,0.9904132432198268],[1,3.7556031808144073e-7,-0.00002468187364767975,15.880020117071021]],[34,"Bip001 Spine",[-29,-30,-31],[1,"99aYTJuXxXjKlBCnMZKwSb",1,0],[1,0.2720732092857361,0.15390312671661377,0.0000011634572274488164],[3,-0.0000036112506739137594,-0.0000032734493259281867,0.0671425181802589,0.9977433949812232],[1,-0.00039122660298780275,-0.00034963070073605346,7.699758479455297]],[39,"Bip001 Spine1",5,[[3,[6,"Bip001 Chest Giggle",-32,[1,"bcLaJ+TvdQl78qlF+twDsy",1,0],[1,-0.030802786350250244,0.49484819173812866,0.0000036120202366873855],[3,3.7685426223774956e-13,-0.00000215524395919846,0.7770564103807688,0.6294309613305572],[1,179.99907571776728,-179.99925131317406,78.01630472356885]],[6,"Bip001 Xtra_Hair",-33,[1,"acBVRsOHRXTZXhAUP5FR5A",1,0],[1,0.6950159072875977,-0.6994706392288208,-0.000006818572273914469],[3,5.790522979187898e-7,-0.000003298516196602828,0.9883956670913969,0.1519013010600525],[1,179.99959776231205,-179.99987104867216,17.47425168677412]]],1,4,4],[1,"b0yaVeE+lf24sDuhbAjfnr",1,0],[1,0.7889416217803955,-0.0007495880126953125,-2.078195393551141e-9],[3,-3.5019260556543856e-13,1.5484620210818652e-7,-0.05582864471373433,0.9984403649840102],[1,9.968009184705453e-7,0.00001782752218102701,-6.400819429558583]],[110,"Bip001 Pelvis",[5,-34],[1,"05UVohVuNVcY7xAefdYL4R",1,0],[3,-0.7070778123743453,-0.006288996065458571,-0.006292967690640629,0.7070797793276539],[1,-89.99984349021217,-1.0195107027065413,-0.00032321993293957425]],[86,"Bip001 L Hand",[[6,"Bip001 L Finger0",-35,[1,"c1cWylJQtd6rol0y6sh+h7",1,0],[1,0.11026113480329514,-0.165815532207489,-0.007204532623291016],[3,-0.0002805439336568173,-0.00028253451927802003,-0.7096009373105814,0.7046036838090551],[1,-173.57108515257863,-173.5712464477026,-89.59251697193665]],[6,"Bn_Hand",-36,[1,"b4NkXDiC1Ugpi6y1EryYfH",1,0],[1,0.07876826077699661,0.0014336705207824707,0.008919715881347656],[3,-0.5285012611055592,0.45481123565417464,0.4609834753050134,0.5489329580452139],[1,-89.06222278112995,80.71567421214854,1.4532582727244376]]],[1,"b8A7ZBYvlbYJe+OTRAWqzr",1,0],[1,0.49073225259780884,0,-2.7755575615628914e-17],[3,0.006459115510774314,-0.0009703958597851153,-0.00967462636066002,0.999931867560723],[1,0.7391929267412117,-0.10405038509961596,-1.109342541708019]],[31,"VD289_Lion_Toy",1,[[44,-37,[11,"503Je38cFf+qiwMAkmKXtO"],[0,1,2,3,4,5,6,7,8,9],[24],1,10,11]],[1,"66SXxyl+ZSLIlCH9Xjfuro",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[7,"Bip001",1,[7],[1,"20FZ6FqZZT946EF29Au3vS",1,0],[1,1.1595849258583257e-7,1.5997356176376343,-0.6252281665802002],[3,-0.5000003576277408,-0.49999964237200345,-0.49999964237200345,0.5000003576277408],[1,-90,-89.99991803772996,0]],[14,"Bip001 Tongue_01",4,[[6,"Bip001 Tongue_02",-38,[1,"3evKiZvo5TaLUHoURAeo/X",1,0],[1,0.11488211154937744,0.004982948303222656,-1.5629666449967772e-9],[3,-2.323547235219641e-13,-2.9056776282183755e-7,0.1047619535833508,0.9944973268346755],[1,0.0000035664763741375045,-0.000033856545481151455,12.026903731116498]]],[1,"55LTavoExT56Qt1yhbvz/X",1,0],[1,0.003924190998077393,0.02710580825805664,-3.941545401175972e-7],[3,8.876830915891205e-8,2.861370347925786e-7,-0.1564121826931524,0.9876918695145132],[1,0.000015956211203273638,0.00003572433450440832,-17.997414807659634]],[14,"Bip001 R_Ear",2,[[6,"Bip001 Xtra_Rear1",-39,[1,"7dpmNx611fh4xXzZzkGAmI",1,0],[1,0.16526293754577637,-0.007695436477661133,-0.00586247444152832],[3,0.0002579941082421809,0.00014602117979031542,0.00013364067216513513,0.9999999471285115],[1,0.029561711706125145,0.01672884364813452,0.015318409307953114]]],[1,"11uo16DZlTM61GJXA7u+dI",1,0],[1,0.2222374677658081,-0.27237796783447266,-0.2623478174209595],[3,0.08784863973881617,0.39916932019638285,-0.6109285268413922,0.6780212425886106],[1,68.57755439683643,95.73479365574451,-49.3156191935996]],[14,"Bip001 Bip001 L_Ear",2,[[6,"Bip001 Xtra_Lear1",-40,[1,"07XOU8MOJdXYdeZTz15z4c",1,0],[1,0.16525864601135254,-0.007697701454162598,0.005858659744262695],[3,-0.00025739037835200524,-0.00014754108367486289,0.00013392347407347846,0.9999999470231611],[1,-0.029492501292864223,-0.0169030127135326,0.015350850744476724]]],[1,"16nrjCCw1awrIbbFmrrLkt",1,0],[1,0.2222374677658081,-0.27237915992736816,0.2623463571071625],[3,-0.08784849002020216,-0.3991657109029413,-0.6109308465057375,0.6780212967365428],[1,-68.57792556304484,-95.73482604637756,-49.31596771939435]],[7,"Bip001 L Clavicle",3,[-41],[1,"24wLW8b+9UI6wK3JzbMbUF",1,0],[1,-0.14779305458068848,0.10067105293273926,0.2215055376291275],[3,0.41547124778529304,0.4998455845503116,0.7451695656451454,0.14919903587327327],[1,-126.27871613268118,-142.39487477211952,39.62053467264401]],[7,"Bip001 L UpperArm",14,[-42],[1,"a8dpwKFOlaFJYRtwefRwED",1,0],[1,0.2296522855758667,-5.960464477539063e-8,5.960464477539063e-8],[3,-0.6379365357431955,0.1235952085584575,-0.26826861637233795,0.7111913598006048],[1,-87.13188492523258,-11.401635846222337,-32.63412457981295]],[7,"Bip001 L Forearm",15,[8],[1,"25rnbqlTNR1pQdN14WG5HL",1,0],[1,0.7293049097061157,1.7881393432617188e-7,-1.4901161193847656e-8],[3,-2.9085993091906674e-18,-6.926437497026995e-18,-0.04384888403144709,0.9990381751310593],[1,-3.6920345895733417e-16,-8.106801632792376e-16,-5.026323567077576]],[7,"Bip001 R Clavicle",3,[-43],[1,"8aDq0WbNRYM4NJvJ2o74Lv",1,0],[1,-0.14779317378997803,0.10067236423492432,-0.2215055376291275],[3,-0.41547080324707847,-0.4998476439141597,0.7451681992161449,0.14920019906038545],[1,126.27838935043187,142.39508748208752,39.62072751801381]],[7,"Bip001 R UpperArm",17,[-44],[1,"07NdQ2IsRR84s8cj1lRGj3",1,0],[1,0.2296525239944458,0,0],[3,0.6379367648406821,-0.1235963988454534,-0.2682694469176002,0.7111906341534349],[1,87.13198029502165,11.401633666939945,-32.63428564318466]],[7,"Bip001 R Forearm",18,[-45],[1,"30nvpNQ2tWc6LIPcuur2vi",1,0],[1,0.7293049097061157,1.1920928955078125e-7,1.4901161193847656e-8],[3,1.1303803744703823e-18,5.973501841164178e-18,-0.04384888774957473,0.9990381749678664],[1,1.6003800920948266e-16,6.921961491095201e-16,-5.026323993553814]],[14,"Bip001 R Hand",19,[[6,"Bip001 R Finger0",-46,[1,"008tQUqzhbV6wCEbIfA14v",1,0],[1,0.11026114970445633,-0.165815532207489,0.0072045475244522095],[3,0.0002805438754491646,0.0002825344610703674,-0.7096009373106047,0.7046036838090782],[1,173.57108647059945,173.5712477657234,-89.59251697299388]]],[1,"feQFOqHlxSwbMcaPmuycQQ",1,0],[1,0.49073225259780884,-5.960464477539063e-8,0],[3,-0.006459115510844551,0.0009703939389428657,-0.009674625429442654,0.9999318675715966],[1,-0.739192928963956,0.10405016564739006,-1.109342433575704]],[7,"Bip001 L Thigh",5,[-47],[1,"e7TXJyk2pTmZxxh/3c0m7+",1,0],[1,-0.29023897647857666,-0.11606419086456299,0.26128682494163513],[3,0.6547501037544102,0.7558454217821333,0.0000013154733451603865,-0.0000016875408036243292],[1,-0.0016868458150420427,-179.9982829288019,81.80140842503103]],[7,"Bip001 L Calf",21,[-48],[1,"90JC9J3EBcF59u1d/TDnac",1,0],[1,0.8090827465057373,0,5.551115123125783e-17],[3,0,0,-0.11404207427361232,0.9934759208432642],[1,0,0,-13.09675291010064]],[7,"Bip001 L HorseLink",22,[-49],[1,"9edFaLq9JUMqw4ukRK7eJe",1,0],[1,0.25800904631614685,1.1920928955078125e-7,-2.9802322387695312e-8],[3,9.57812866348905e-14,2.2470528871822908e-14,0.245942504133208,0.9692844188682117],[1,1.1382293537766347e-11,-2.3156963582984584e-13,28.47507924983398]],[14,"Bip001 L Foot",23,[[6,"Bip001 L Toe0",-50,[1,"40GD3ZPKlVUKfO5lep3+oO",1,0],[1,0.1358935534954071,0.22066044807434082,8.940696716308594e-8],[3,9.866342672720895e-7,2.5395416366009996e-7,0.7093888948710643,0.704817278330045],[1,179.99086762866585,-179.9907671051601,89.62956826340346]]],[1,"6ax1un7LxbuodvxEmJ7fy/",1,0],[1,0.4313865005970001,0,5.960464477539063e-8],[3,-0.0000010594730005037418,-0.00000132363403322884,-0.005650970194106799,0.9999840331390251],[1,-0.00012226965720855048,-0.00015237066251723541,-0.6475569308786362]],[7,"Bip001 R Thigh",5,[-51],[1,"4dRXphVyNfYYs4uOckZrgr",1,0],[1,-0.29024165868759155,-0.11606109142303467,-0.2612874209880829],[3,0.6547501037545858,0.755845421782336,0.0000012090864537826867,-0.000001606185025239139],[1,-0.001579425924664092,-179.9983883152573,81.80140842546759]],[7,"Bip001 R Calf",25,[-52],[1,"9166HB4c9fCpJ+ndmbNclR",1,0],[1,0.8090826869010925,-1.1920928955078125e-7,-2.9802322387695312e-8],[3,-2.2245138044444033e-22,-8.103900608651333e-23,-0.11404207427361232,0.9934759208432642],[1,-2.7088384694094717e-20,-1.2456871242652872e-20,-13.09675291010064]],[7,"Bip001 R HorseLink",26,[-53],[1,"21BAg+uiNcLJ1pMuhtF2u5",1,0],[1,0.25800904631614685,2.220446049250313e-16,2.9802322387695312e-8],[3,3.303694474986318e-14,8.382667523066969e-15,0.245942504133208,0.9692844188682117],[1,3.905721507034513e-12,1.2771531827069202e-20,28.47507924983398]],[14,"Bip001 R Foot",27,[[6,"Bip001 R Toe0",-54,[1,"5cJRpZcMxdlIdscpoxZ25t",1,0],[1,0.1358935534954071,0.22066044807434082,-8.940696716308594e-8],[3,-9.86634536094653e-7,-2.539541459071018e-7,0.7093889246727637,0.7048172483350432],[1,-179.99086774519165,179.9907672216655,89.62956341814296]]],[1,"bfPdLlgZtTPLDNzkErLei1",1,0],[1,0.4313865303993225,0,0],[3,0.000001059741074068888,0.0000014110564835805256,-0.005650970194106122,0.9999840331389052],[1,0.00012235699197597083,0.00016238919088752877,-0.6475569308678233]],[7,"Bip001 Tail_01",7,[-55],[1,"04ogjBxslRvqZNn/28a2mW",1,0],[1,-0.2915322780609131,-0.22355151176452637,-9.820198556553805e-7],[3,-0.0000027950730284391583,2.102613403261408e-8,0.9999568013565235,-0.009294913287234204],[1,179.999999432131,179.9996796891088,-1.0651339420896775]],[7,"Bip001 Tail_02",29,[-56],[1,"62SLmOvJVd65B7L2G1Y1bi",1,0],[1,0.5395174622535706,0.006091594696044922,-2.1810456019011326e-7],[3,-6.981501933704374e-7,6.656289363368778e-7,-0.003450571817125076,0.9999940467588817],[1,-0.0000797403477249723,0.00007600076020202552,-0.3954071887608722]],[14,"Bip001 Tail_03",30,[[6,"Bip001 Tail_04",-57,[1,"48il1/WABdRr0dL7mUyTUY",1,0],[1,0.5596358776092529,0.004202485084533691,1.507032720837742e-9],[3,0.0000011297749087033272,1.3514002976763587e-7,-0.001367071436931353,0.9999990655567593],[1,0.0001294842014842598,0.00001566293548740287,-0.1566548960355113]]],[1,"e4/QZ1rH1f3K65N7Vtf7PY",1,0],[1,0.4064565896987915,0.007515430450439453,3.950663085561246e-8],[3,6.873440722040352e-7,6.919706716734174e-7,0.008025330355133777,0.9999677965173377],[1,0.00007813499653582644,0.00007866947233888114,0.9196449890937232]]],0,[0,10,1,0,0,1,0,-1,9,0,-2,10,0,10,1,0,1,1,0,-1,4,0,1,2,0,1,2,0,-4,12,0,-5,13,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,-2,14,0,-3,17,0,1,3,0,1,4,0,-2,11,0,1,4,0,1,4,0,-1,6,0,-2,21,0,-3,25,0,1,6,0,1,6,0,-2,29,0,1,8,0,1,8,0,0,9,0,1,11,0,1,12,0,1,13,0,-1,15,0,-1,16,0,-1,18,0,-1,19,0,-1,20,0,1,20,0,-1,22,0,-1,23,0,-1,24,0,1,24,0,-1,26,0,-1,27,0,-1,28,0,1,28,0,-1,30,0,-1,31,0,1,31,0,16,1,2,1,3,3,1,6,5,1,7,7,1,10,8,1,16,57],[0,0,0,0,0,0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,14,19],[11,11,11,11,11,11,11,11,11,118,119,120]],[[{"name":"ingamepopup_bg","rect":{"x":1,"y":2,"width":504,"height":284},"offset":{"x":0,"y":-1},"originalSize":{"width":506,"height":286},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[121]],[[{"name":"icon_location","rect":{"x":53,"y":28,"width":151,"height":202},"offset":{"x":0.5,"y":-1},"originalSize":{"width":256,"height":256},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[122]],[[{"name":"default_btn_disabled","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"packable":true}],[0],0,[0],[3],[123]],[[{"name":"UI_Icon_Food_Twigs","rect":{"x":38,"y":43,"width":436,"height":427},"offset":{"x":0,"y":-0.5},"originalSize":{"width":512,"height":512},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[124]],[[{"name":"CN_Letgo","rect":{"x":0,"y":0,"width":450,"height":225},"offset":{"x":-8.5,"y":0},"originalSize":{"width":467,"height":225},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[125]],[[{"name":"UI_Icon_Natoons_Encyclopedia","rect":{"x":45,"y":32,"width":166,"height":200},"offset":{"x":0,"y":-4},"originalSize":{"width":256,"height":256},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[126]],[[{"name":"Flomingo-2","rect":{"x":1,"y":1,"width":392,"height":383},"offset":{"x":0,"y":0},"originalSize":{"width":394,"height":385},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[127]],[[{"name":"CN_Unlock","rect":{"x":0,"y":0,"width":430,"height":225},"offset":{"x":0,"y":0},"originalSize":{"width":430,"height":225},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[128]],[[[36,"Food_Steak"],[48,"Food_Steak",[-3],[[67,-2,[11,"dfbCZuS1pOLrASIyckfRGm"]]],[1,"39zeFwLgRcroMIxnUxSpHx",-1,0],[1,0.1,0.1,0.1]],[31,"Steak",1,[[62,-4,[11,"acdgmtdN9XEb4W3QOvDTxL"],[0],[24],1]],[1,"79epd6+MteDofHCEwJkR0f",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]]],0,[0,10,1,0,0,1,0,-1,2,0,0,2,0,16,1,4],[0,0],[-1,14],[129,130]],[[{"name":"UI_button_brown","rect":{"x":0,"y":0,"width":269,"height":269},"offset":{"x":0,"y":0},"originalSize":{"width":269,"height":269},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[131]],[[[66,"Skin-0",374540058,["Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 Tail_01","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 Tail_01/Bip001 Tail_02","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 Jaw","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Hair02","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Hair03","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2","Bip001/Bip001 Pelvis","Bip001/Bip001 Pelvis/Bip001 Spine","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L HorseLink/Bip001 L Foot/Bip001 L Toe0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L HorseLink/Bip001 L Foot","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L HorseLink","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 L_UpEyelid","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 L_DownEyelid","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 L_cheek","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 Tail_01/Bip001 Tail_02/Bip001 Tail_03/Bip001 Tail_04","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 Tail_01/Bip001 Tail_02/Bip001 Tail_03/Bip001 Tail_04/Bip001 Tail_05","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 Tail_01/Bip001 Tail_02/Bip001 Tail_03","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 nose","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 L_Up_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 L_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 Jaw/Bip001 L_Down_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 Jaw/Bip001 Down_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 L_Ear","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 L_Ear/Bip001 L_Ear02","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 UP_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 UpTeeth","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 Jaw/Bip001 Tongue01/Bip001 Tongue02","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 Jaw/Bip001 Tongue01/Bip001 Tongue02/Bip001 Tongue03","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 Jaw/Bip001 Tongue01","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 Jaw/Bip001 DownTeeth","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Hair01","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 L_EyeBall","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R HorseLink","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R HorseLink/Bip001 R Foot","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R HorseLink/Bip001 R Foot/Bip001 R Toe0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 R_UpEyelid","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 R_DownEyelid","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 R_cheek","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 R_Ear","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 R_Up_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 R_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 Jaw/Bip001 R_Down_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 R_Ear/Bip001 R_Ear02","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 R_EyeBall"],[[[7,-0.00000255021768680308,-0.000005215080363996094,1,0,0.9833522439002991,-0.18170975148677826,0.0000015601311815771624,0,0.18170975148677826,0.9833522439002991,0.000005591659828496631,0,-1.569665551185608,-2.41400408744812,-0.000016520543795195408,1],[7,-0.000001446136138838483,-0.000005819375019200379,1,0,0.9987928867340088,-0.04912137612700462,0.0000011585347010623082,0,0.04912137612700462,0.9987928867340088,0.000005883385711058509,0,-1.5078305006027222,-2.6396844387054443,-0.00001667447213549167,1],[7,5.291087177283771e-7,-0.000002661785856616916,1,0,-0.6623979210853577,0.7491523027420044,0.000002344562972211861,0,-0.7491523027420044,-0.6623979210853577,-0.0000013667780649484484,0,1.75612211227417,4.876213550567627,0.000012433055417204741,1],[7,5.010662111535481e-17,-0.0000027736000447475817,1,0,-0.5747995376586914,-0.8182942867279053,-0.0000022696210635331227,0,0.8182942867279053,-0.5747995376586914,-0.0000015942640629873495,0,-3.053658962249756,1.1519149541854858,0.0000029811449167027604,1],[7,5.215457141952585e-17,-0.0000027736004994949326,1,0,-0.523952841758728,-0.8517473340034485,-0.000002362406348765944,0,0.8517473340034485,-0.523952841758728,-0.0000014532356544805225,0,-3.8092100620269775,0.9223347902297974,0.000002344381300645182,1],[7,3.502345579276073e-17,-0.0000027736000447475817,1,0,0.8202616572380066,-0.5719896554946899,-0.0000015864683291511028,0,0.5719896554946899,0.8202616572380066,0.0000022750746211386286,0,-1.3556551933288574,-3.7203891277313232,-0.000010616566214594059,1],[7,3.5449976586372675e-17,-0.0000027736000447475817,1,0,0.8153745532035828,-0.5789345502853394,-0.0000016057314269346534,0,0.5789345502853394,0.8153745532035828,0.0000022615208763454575,0,-1.3966890573501587,-4.516148090362549,-0.000012120615792809986,1],[7,5.215457141952585e-17,-0.0000027736004994949326,1,0,-0.523952841758728,-0.8517473340034485,-0.000002362406348765944,0,0.8517473340034485,-0.523952841758728,-0.0000014532356544805225,0,-4.375222206115723,0.9227390885353088,0.000002345502707612468,1],[7,0.0000013868001360606286,0.0000013868001360606286,1,0,-1,1.923153476746098e-12,0.0000013868001360606286,0,6.123234262925839e-17,-1,0.0000013868001360606286,0,0.8954776525497437,2.3790533542633057,-0.000004536764208751265,1],[7,5.441503434922911e-17,-0.0000027736000447475817,1,0,-0.997197687625885,-0.07481105625629425,-2.0749594398239424e-7,0,0.07481105625629425,-0.997197687625885,-0.0000027658277303999057,0,0.31638628244400024,2.394348382949829,0.000006764943918824429,1],[7,0.00028080467018298805,-0.000032931722671492025,-0.9999999403953552,0,0.028058523312211037,-0.9996063113212585,0.00004079772043041885,0,-0.999606192111969,-0.02805853635072708,-0.0002797700872179121,0,2.3529014587402344,0.9618881940841675,0.31838467717170715,1],[7,0.05718785151839256,0.9961947202682495,-0.06576956808567047,0,-0.9788727164268494,0.042995937168598175,-0.19989937543869019,0,-0.1963108777999878,0.07581184059381485,0.9776065945625305,0,0.2000403255224228,-0.5133196711540222,-2.7213196754455566,1],[7,-0.047780394554138184,0.019250085577368736,0.998672366142273,0,0.31298768520355225,0.9497512578964233,-0.0033325429540127516,0,-0.948554515838623,0.31241291761398315,-0.05140453577041626,0,2.7679901123046875,-0.1258448213338852,-0.21116912364959717,1],[7,-0.05069974437355995,0.009114150889217854,0.998672366142273,0,0.11297041922807693,0.9935927391052246,-0.0033326072152704,0,-0.9923039674758911,0.11265147477388382,-0.05140452831983566,0,2.174321413040161,0.3238334059715271,-0.21116918325424194,1],[7,3.0165175901053035e-17,-0.0000027736000447475817,1,0,-0.8702383041381836,-0.49263113737106323,-0.0000013663616300618742,0,0.49263113737106323,-0.8702383041381836,-0.0000024136927549989196,0,-1.3100435733795166,2.030302047729492,0.000005755224265158176,1],[7,0.0002718777977861464,0.00007757788989692926,-0.9999999403953552,0,0.410282701253891,-0.9119583964347839,0.00004079895370523445,0,-0.9119583368301392,-0.410282701253891,-0.0002797700872179121,0,1.234162449836731,1.5561118125915527,0.31838467717170715,1],[7,0.0000020388738448673394,0.0000019824697119474877,-1,0,-6.123234262925839e-17,-1,-0.0000019824697119474877,0,-1,4.042066594628357e-12,-0.0000020388738448673394,0,0.1865268349647522,1.1759483814239502,0.3183649480342865,1],[7,-0.000001982469939321163,0.000002017392262132489,-1,0,-0.01745329424738884,-0.9998477101325989,-0.000001982484263862716,0,-0.9998477101325989,0.01745329424738884,0.000002017377937590936,0,0.2707692086696625,1.1643844842910767,0.31836414337158203,1],[7,0.03949568048119545,-0.9992038607597351,0.005626568105071783,0,0.027273131534457207,0.0067068589851260185,0.9996054172515869,0,-0.9988473653793335,-0.03932664915919304,0.027516311034560204,0,1.0981080532073975,0.3124203681945801,0.42092499136924744,1],[7,2.7372845323725414e-8,-1,8.940696005765858e-8,0,-6.123232939436859e-17,8.940696716308594e-8,0.9999998807907104,0,-0.9999998807907104,-2.7372848876439093e-8,2.38609075362418e-15,0,0.27252790331840515,0.29873359203338623,0.4468482732772827,1],[7,3.8463884854955666e-12,-0.000002773600272121257,1,0,-0.4485979974269867,-0.8937337398529053,-0.00000247885805038095,0,0.8937337398529053,-0.4485979974269867,-0.000001244234795194643,0,-4.980362415313721,0.4031815528869629,9.044772468769224e-7,1],[7,0.00027876306558027864,-0.000047192730562528595,-0.9999999403953552,0,-0.022885749116539955,-0.9997380971908569,0.00004080066719325259,0,-0.9997380375862122,0.02288573607802391,-0.0002797700872179121,0,1.1757022142410278,1.1629116535186768,0.31838467717170715,1],[7,0.9659981727600098,-0.24628859758377075,-0.07867289334535599,0,-0.2011970728635788,-0.9071778655052185,0.369524210691452,0,-0.1623798906803131,-0.34113094210624695,-0.9258847236633301,0,0.1136460080742836,-0.3415166437625885,5.318476676940918,1],[7,0.9659954905509949,-0.24626027047634125,-0.07879386097192764,0,-0.20109106600284576,-0.9071142673492432,0.3697379529476166,0,-0.16252680122852325,-0.3413205146789551,-0.9257889986038208,0,0.11636586487293243,-0.3404788672924042,5.244320869445801,1],[7,0.9904707670211792,-0.13762030005455017,-0.005315810441970825,0,-0.12237933278083801,-0.897172212600708,0.42438802123069763,0,-0.06317359954118729,-0.41969335079193115,-0.9054648280143738,0,-0.13142654299736023,-0.00309978099539876,5.034485816955566,1],[7,-0.000007277576969499933,-0.00001185160090244608,1,0,0.9998875260353088,-0.014998425729572773,0.000007099003141775029,0,0.014998425729572773,0.9998875260353088,0.000011959419680351857,0,-2.175171136856079,-2.6996700763702393,-0.000042854568164329976,1],[7,-0.000004437095412868075,-0.000014663933143310715,1,0,0.9998875260353088,-0.01499862875789404,0.000004216657544020563,0,0.01499862875789404,0.9998875260353088,0.000014728833775734529,0,-2.491150379180908,-2.699502944946289,-0.000042551488149911165,1],[7,-0.0000044326638999336865,-0.00000898532016435638,1,0,0.9998875856399536,-0.015000022947788239,0.000004297384748497279,0,0.015000022947788239,0.9998875856399536,0.000009050798325915821,0,-1.7911734580993652,-2.713163375854492,-0.00002995617251144722,1],[7,-3.6557432281369984e-7,0.0000031705701530881925,1,0,-0.5451578497886658,-0.8383334279060364,0.0000024586993276898284,0,0.8383334279060364,-0.5451578497886658,0.00000203493436856661,0,-5.3100996017456055,0.22121083736419678,0.000012819946277886629,1],[7,-0.9834277033805847,-0.07535165548324585,-0.16489998996257782,0,0.05511775240302086,0.7422297596931458,-0.6678750514984131,0,0.17271916568279266,-0.6658957004547119,-0.725776195526123,0,-0.5307903289794922,4.922797679901123,1.4283568859100342,1],[7,0.9837003350257874,-0.16731400787830353,-0.06587543338537216,0,0.152854323387146,0.5851213932037354,0.7964097261428833,0,-0.09470538049936295,-0.7934978008270264,0.601158857345581,0,0.7260411977767944,5.0750250816345215,-0.5937017798423767,1],[7,-0.16507425904273987,-0.0765521377325058,0.983305811882019,0,-0.6674317121505737,0.7426939606666565,-0.05422625690698624,0,-0.7261441349983215,-0.6652408242225647,-0.1736930012702942,0,1.431179404258728,4.907702922821045,0.5374665260314941,1],[7,-4.773568775817694e-7,-0.000002633868916745996,1,0,-0.7001278400421143,0.714017391204834,0.0000015464175930901547,0,-0.714017391204834,-0.7001278400421143,-0.0000021848863980267197,0,1.2298862934112549,4.991217136383057,0.00001701764813333284,1],[7,0.7196860313415527,0.28038498759269714,0.6351662874221802,0,0.6569914817810059,-0.5708681344985962,-0.4924141466617584,0,0.2245306372642517,0.7716824412345886,-0.5950564742088318,0,0.1065763607621193,-4.96716833114624,1.8200093507766724,1],[7,0.6838900446891785,-0.31116482615470886,0.6599020957946777,0,0.41482067108154297,-0.5782256722450256,-0.7025517225265503,0,0.6001816987991333,0.7542091012001038,-0.2663652300834656,0,-2.430375337600708,-4.696169376373291,-0.20293672382831573,1],[7,5.175351134312223e-7,-0.000005879069703951245,1,0,-0.7100159525871277,0.7041858434677124,0.000004507414359977702,0,-0.7041858434677124,-0.7100159525871277,-0.0000038097912238299614,0,1.1548869609832764,5.018223285675049,0.000015606367014697753,1],[7,0.000003184981778758811,-0.000006563875103893224,1,0,-0.6494793891906738,0.7603790760040283,0.000007059614745230647,0,-0.7603790760040283,-0.6494793891906738,-0.0000018413086309010396,0,1.5860849618911743,4.909286022186279,0.00005783742744824849,1],[7,0.00000227941018238198,-0.000002842612730091787,1,0,-0.7524473667144775,0.6586522459983826,0.000003587430228435551,0,-0.6586522459983826,-0.7524473667144775,-6.375778980327595e-7,0,0.9638833999633789,5.064806938171387,0.000012441931175999343,1],[7,0.0000022771666863263818,-0.000005659923317580251,1,0,-0.7524473071098328,0.6586522459983826,0.000005441370376502164,0,-0.6586522459983826,-0.7524473071098328,-0.000002758933760560467,0,0.9068463444709778,5.064574241638184,0.000026873483875533566,1],[7,0.0000022737335712008644,-0.000002598641913209576,1,0,-0.818522036075592,0.574475109577179,0.000003353956117280177,0,-0.574475109577179,-0.818522036075592,-8.208422173083818e-7,0,0.4804438650608063,5.139310359954834,0.00001264857201022096,1],[7,5.30944817001e-7,-0.0000026708573841460748,1,0,-0.6494793891906738,0.7603791952133179,0.000002375702024437487,0,-0.7603791952133179,-0.6494793891906738,-0.0000013309473843037267,0,1.5860859155654907,4.882230758666992,0.000043065094359917566,1],[7,0.047780394554138184,-0.019250085577368736,0.998672366142273,0,0.31298768520355225,0.9497512578964233,0.0033325429540127516,0,-0.948554515838623,0.31241291761398315,0.05140453577041626,0,2.7679901123046875,-0.1258448362350464,0.21116936206817627,1],[7,3.984083325753891e-17,-0.000002773600272121257,1,0,0.759378969669342,-0.6506486535072327,-0.00000180463905508077,0,0.6506486535072327,0.759378969669342,0.0000021062135147076333,0,-1.714515209197998,-2.841568946838379,-0.000009688893442216795,1],[7,-0.0002808095596265048,0.00003310589454486035,-0.9999999403953552,0,0.028058523312211037,-0.9996063113212585,-0.000040971961425384507,0,-0.999606192111969,-0.02805853635072708,0.0002797700872179121,0,2.3529014587402344,0.9618882536888123,-0.3183844983577728,1],[7,0.9758886694908142,0.21203115582466125,0.05180666968226433,0,-0.19028127193450928,0.9427250027656555,-0.2739751636981964,0,-0.10693071037530899,0.2575114071369171,0.9603404402732849,0,-0.045463964343070984,0.8317544460296631,-5.231501579284668,1],[7,-0.0002719495096243918,-0.00007741848821751773,-0.9999999403953552,0,0.410282701253891,-0.9119583964347839,-0.000040973740397021174,0,-0.9119583368301392,-0.410282701253891,0.0002797700872179121,0,1.234162449836731,1.5561119318008423,-0.3183844983577728,1],[7,-0.05718785151839256,-0.9961947202682495,-0.06576956808567047,0,-0.9788727164268494,0.042995937168598175,0.19989937543869019,0,-0.1963108777999878,0.07581184059381485,-0.9776065945625305,0,0.2000403106212616,-0.5133199095726013,2.7213196754455566,1],[7,0.05069974437355995,-0.009114150889217854,0.998672366142273,0,0.11297041922807693,0.9935927391052246,0.0033326072152704,0,-0.9923039674758911,0.11265147477388382,0.05140452831983566,0,2.174321413040161,0.3238334059715271,0.21116942167282104,1],[7,-0.0002787590492516756,0.00004736815390060656,-0.9999999403953552,0,-0.022885749116539955,-0.9997380971908569,-0.00004097613782505505,0,-0.9997380375862122,0.02288573607802391,0.0002797700872179121,0,1.1757022142410278,1.1629117727279663,-0.3183845281600952,1],[7,0.000001982469939321163,-0.000002017392262132489,-1,0,-0.01745329424738884,-0.9998477101325989,0.000001982484263862716,0,-0.9998477101325989,0.01745329424738884,-0.000002017377937590936,0,0.2707692086696625,1.1643844842910767,-0.3183642029762268,1],[7,0.000002039416358456947,-0.0000019824692572001368,-1,0,-6.123232277692369e-17,-0.9999997615814209,0.0000019824697119474877,0,-0.9999997615814209,-4.043019825178407e-12,-0.000002039416813204298,0,0.18652808666229248,1.1759480237960815,-0.3183642327785492,1],[7,-0.03949568048119545,0.9992038607597351,0.005626568105071783,0,0.027273131534457207,0.0067068589851260185,-0.9996054172515869,0,-0.9988473653793335,-0.03932664915919304,-0.027516311034560204,0,1.0981080532073975,0.3124206066131592,-0.42092499136924744,1],[7,2.7372845323725414e-8,1,8.940696005765858e-8,0,-6.123232939436859e-17,8.940696716308594e-8,-0.9999998807907104,0,-0.9999998807907104,2.7372848876439093e-8,2.508555412412917e-15,0,0.27252790331840515,0.29873380064964294,-0.4468482732772827,1],[7,-0.965998113155365,0.24628940224647522,-0.07867156714200974,0,-0.20119743049144745,-0.9071756601333618,-0.36952924728393555,0,-0.16238008439540863,-0.34113600850105286,0.9258828163146973,0,0.1136465072631836,-0.34148719906806946,-5.318478584289551,1],[7,-0.9659954309463501,0.2462611198425293,-0.07879266887903214,0,-0.20109142363071442,-0.9071121215820312,-0.3697430193424225,0,-0.16252711415290833,-0.3413255512714386,0.925787091255188,0,0.11636702716350555,-0.3404499888420105,-5.244322776794434,1],[7,-0.9904707670211792,0.13762052357196808,-0.005315055139362812,0,-0.12237950414419174,-0.8971698880195618,-0.424392968416214,0,-0.06317368894815445,-0.4196983575820923,0.9054625034332275,0,-0.13142608106136322,-0.003072005696594715,-5.034485816955566,1],[7,-0.719687819480896,-0.28038766980171204,0.6351631283760071,0,0.6569896936416626,-0.5708719491958618,0.49241209030151367,0,0.22453054785728455,0.7716785669326782,0.5950614809989929,0,0.10657331347465515,-4.96715784072876,-1.8200385570526123,1],[7,0.9834277033805847,0.07535257190465927,-0.1648995727300644,0,0.05511775240302086,0.7422260642051697,0.6678791642189026,0,0.17271916568279266,-0.6658997535705566,0.7257724404335022,0,-0.5307907462120056,4.9228057861328125,-1.428329348564148,1],[7,-0.9837005138397217,0.16731387376785278,-0.06587301939725876,0,0.1528528332710266,0.5851260423660278,-0.796406626701355,0,-0.09470585733652115,-0.793494462966919,-0.6011632680892944,0,0.7260398268699646,5.075022220611572,0.5937297344207764,1],[7,0.16507530212402344,0.07654688507318497,0.9833060503005981,0,-0.6674315929412842,0.7426937818527222,0.05423092097043991,0,-0.726144015789032,-0.6652417182922363,0.17369021475315094,0,1.431179404258728,4.907706260681152,-0.5374413132667542,1],[7,-0.6838915348052979,0.3111620247364044,0.6599019765853882,0,0.414818674325943,-0.5782292485237122,0.702549934387207,0,0.600181519985199,0.75420743227005,0.2663702964782715,0,-2.4303781986236572,-4.696168422698975,0.2029087245464325,1],[7,-0.9758886694908142,-0.21203139424324036,0.05180550366640091,0,-0.1902812421321869,0.9427235126495361,0.27398034930229187,0,-0.1069306954741478,0.25751668214797974,-0.9603390097618103,0,-0.045463528484106064,0.8317257761955261,5.23150634765625,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[28,".bin",3687695271,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":53152,"length":3372,"count":1686,"stride":2}},{"primitiveMode":7,"jointMapIndex":1,"vertexBundelIndices":[1],"indexView":{"offset":79316,"length":1332,"count":666,"stride":2}},{"primitiveMode":7,"jointMapIndex":2,"vertexBundelIndices":[2],"indexView":{"offset":126232,"length":3630,"count":1815,"stride":2}},{"primitiveMode":7,"jointMapIndex":3,"vertexBundelIndices":[3],"indexView":{"offset":167438,"length":2268,"count":1134,"stride":2}},{"primitiveMode":7,"jointMapIndex":4,"vertexBundelIndices":[4],"indexView":{"offset":218282,"length":3576,"count":1788,"stride":2}},{"primitiveMode":7,"jointMapIndex":5,"vertexBundelIndices":[5],"indexView":{"offset":256178,"length":1980,"count":990,"stride":2}},{"primitiveMode":7,"jointMapIndex":6,"vertexBundelIndices":[6],"indexView":{"offset":309198,"length":3102,"count":1551,"stride":2}},{"primitiveMode":7,"jointMapIndex":7,"vertexBundelIndices":[7],"indexView":{"offset":335092,"length":1332,"count":666,"stride":2}},{"primitiveMode":7,"jointMapIndex":8,"vertexBundelIndices":[8],"indexView":{"offset":376992,"length":3216,"count":1608,"stride":2}},{"primitiveMode":7,"jointMapIndex":9,"vertexBundelIndices":[9],"indexView":{"offset":417696,"length":2244,"count":1122,"stride":2}},{"primitiveMode":7,"jointMapIndex":10,"vertexBundelIndices":[10],"indexView":{"offset":475996,"length":4038,"count":2019,"stride":2}},{"primitiveMode":7,"jointMapIndex":6,"vertexBundelIndices":[11],"indexView":{"offset":506434,"length":1686,"count":843,"stride":2}},{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[12],"indexView":{"offset":536632,"length":7680,"count":1920,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":53152,"count":604,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":56524,"length":22792,"count":259,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":80648,"length":45584,"count":518,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":129862,"length":37576,"count":427,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":169706,"length":48576,"count":552,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":221858,"length":34320,"count":390,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":258158,"length":51040,"count":580,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":312300,"length":22792,"count":259,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":336424,"length":40568,"count":461,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":380208,"length":37488,"count":426,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":419940,"length":56056,"count":637,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":480034,"length":26400,"count":300,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":508120,"length":28512,"count":324,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}],"jointMaps":[[0,2,3,4,5,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,32,33,41,42,43,44,61],[0,1,2,3,4,5,6,7,8,10,14,15,16,18,19,20,21,22,25,26,27,28,29,30,32,35],[0,2,3,4,5,6,7,8,9,10,11,12,14,15,16,17,19,20,22,23,24,28,29,30,31,32,33,34,35,42],[0,1,2,3,4,5,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,32,33,41,42,43],[0,2,7,11,12,13,15,16,17,18,19,20,21,22,23,28,29,30,31,32,33,35,36,37,38,39,40],[0,3,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,24,28,41,42,43,45,46,47,48,49,50,51],[0,2,3,4,5,7,8,9,10,12,14,20,28,35,41,42,43,45,46,47,48,49,50,51,52,53,54,55,56],[0,1,2,3,4,5,6,7,8,14,20,25,26,27,28,35,43,45,48,50,51,52,53,57,58],[0,2,3,4,5,7,8,9,10,14,20,28,32,35,41,42,43,45,46,49,50,52,53,54,55,56,57,58,59,60],[0,1,2,3,4,5,6,7,8,9,10,14,20,25,26,27,41,42,43,45,46,47,48,49,51,52,53,54,55,56],[0,2,7,12,14,20,28,32,35,36,37,38,39,40,41,45,46,47,48,49,50,51,52,53,54,56,57,58,59]]},"minPosition",8,[1,-0.56879723072052,-2.8188118934631348,0],"maxPosition",8,[1,0.56879723072052,2.8188118934631348,5.288472652435303]]],-1],0,0,[],[],[]],[[[25,"VD297_Giraffe_Toy",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"albedoScale":1,"metallic":0,"roughness":1,"emissiveScale":1,"alphaSource":1},"mainColor",8,[4,4294704123],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[15,12],[132,5]],[[[25,"VD297_Giraffe_Eye",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"albedoScale":1,"metallic":0,"roughness":0,"emissiveScale":1,"alphaSource":1},"mainColor",8,[4,4294967295],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[15,12],[133,5]],[[[64],[52,"VD297_Giraffe_Rig",[[-3,-4,[47,"Bn_FoodSpawn",-6,[1,"edXyveHQlamqk5Klmem7yW",-5,0],[1,2.6372758199499913e-8,0,2.4216866493225098]]],1,1,4],[[171,-2,[11,"a5Ur2McGJUfKEIm/lueZtm"],[15],16]],[1,"49pWBJK15R+45zZnNOgfJN",-1,0]],[35,"Bip001 Head",[[-7,[6,"Bip001 R_UpEyelid",-8,[1,"35776kuEBeLZHUS0fLbjDm",1,0],[1,0.34337615966796875,0.2510550022125244,-0.2245255559682846],[3,0.12247283914442461,0.7241107318662566,0.05565574464344822,0.6764366117798485],[1,5.045205968772248,93.25085851212803,14.63514863313527]],[6,"Bip001 L_UpEyelid",-9,[1,"99+llp6yNf0pX1/DQ9+tgW",1,0],[1,0.34337615966796875,0.2510535717010498,0.22452694177627563],[3,-0.12247256348552801,-0.7241110299639162,0.055651747412626976,0.6764366714540253],[1,-5.045519010090419,-93.25085191470198,14.634809479074342]],[6,"Bip001 R_DownEyelid",-10,[1,"2eX9kiozNTCYTR1C6h7sEi",1,0],[1,0.2697715759277344,0.25691771507263184,-0.21696408092975616],[3,0.1223849945588972,0.7241674026347854,0.05572241887057009,0.6763863526884764],[1,5.031255141657216,93.26145031601891,14.633446357809548]],[6,"Bip001 L_DownEyelid",-11,[1,"72SZVCrg1a2LbK96LcowhX",1,0],[1,0.2697715759277344,0.25691652297973633,0.21696552634239197],[3,-0.12238473441172545,-0.7241676447406158,0.055718354862578263,0.6763864753417299],[1,-5.031576404901483,-93.26143307554283,14.633102810797125]],[6,"Bip001 UP_Lip",-12,[1,"35HbIUuotdQaMkFrCYzRIQ",1,0],[1,0.1482524871826172,0.8653846979141235,0.00001548483851365745],[3,-7.019732607805063e-7,-0.0000036544161645705422,0.8095809949645157,0.5870081878291113],[1,179.99906124463647,-179.99941869080754,71.88997265189033]],[6,"Bip001 R_Up_Lip",-13,[1,"17RB3ykLBUm6je9HRIuOn/",1,0],[1,0.1558370590209961,0.813302755355835,-0.08448056876659393],[3,0.6440443531968911,-0.40946052339214933,0.5172257532139795,0.3873325071703341],[1,111.56741681299894,-82.49034886429834,-7.281525826520712]],[6,"Bip001 L_Up_Lip",-14,[1,"df+haHFsFdPpoeUvr0OVYf",1,0],[1,0.1558370590209961,0.8133022785186768,0.08448508381843567],[3,0.6440443378808218,-0.4094576824341174,-0.5172280058902883,-0.3873325277614716],[1,-111.56768796709501,82.49035459539483,-7.281211700610275]],[6,"Bip001 R_Lip",-15,[1,"dexMSBu/Vc6oaq6wAV+avX",1,0],[1,0.1689472198486328,0.7362625598907471,-0.09580332785844803],[3,-0.5195301736970601,0.5128582682233938,0.5599839650491572,0.3917687509501342],[1,-99.65597338896119,98.85268539858689,-5.400802261110559]],[6,"Bip001 L_Lip",-16,[1,"51H6UXMFxVxreAZ4YjFABg",1,0],[1,0.1689472198486328,0.7362620830535889,0.09580741077661514],[3,0.5195300528317897,-0.5128618428673297,0.5599808042180879,0.39176874970138664],[1,99.65555102296493,-98.85270528484511,-5.4011515009998945]],[6,"Bip001 R_EyeBall",-17,[1,"2evjecQFZRbpov5tGjlFBH",1,0],[1,0.31261539459228516,0.23719239234924316,-0.1390356719493866],[3,-0.6884858534158385,-0.009179707517785443,0.7106473369420088,0.14451064013900036],[1,-169.01665158428787,90.5992931168743,12.593492657351312]],[6,"Bip001 L_EyeBall",-18,[1,"07HB7bVs5fSK0GCLwvrUvV",1,0],[1,0.31261539459228516,0.23719167709350586,0.13903698325157166],[3,0.6884858477219524,0.009175758634226603,0.7106473906694875,0.1445106538450356],[1,169.01632871573827,-90.59929283117292,12.593175480769082]],-19,[6,"Bip001 nose",-20,[1,"04PkZ8dHRVzZYNqb8TRcv7",1,0],[1,0.32142162322998047,0.7735657691955566,-0.00001353079187538242],[3,0.0000029573027132187497,1.9355367263776715e-7,0.055661912494588996,0.9984496739889605],[1,0.000339223991494756,0.000003302881515195641,6.381683568818498]],-21,[6,"Bip001 R_cheek",-22,[1,"e7FwbyyURWBqR0qzpv6MFQ",1,0],[1,0.05211019515991211,0.2889235019683838,-0.1565088927745819],[3,0.05841113290049033,0.7065731926138281,0.039178192854431165,0.7041360182787445],[1,1.555941669856946,90.09031156983801,7.915762344815528]],[6,"Bip001 L_cheek",-23,[1,"7ft6QxtctagqdyecDLAhlN",1,0],[1,0.05211019515991211,0.2889225482940674,0.15651053190231323],[3,-0.05841107281476088,-0.7065734252129403,0.039174191569980386,0.7041360124793511],[1,-1.556261645997518,-90.09031325464657,7.9154330170357]],-24,[6,"Bip001 UpTeeth",-25,[1,"bcMI6QptlSGKEmSrWoPjmO",1,0],[1,0.1596221923828125,0.847388744354248,-0.00002852861871360801],[3,2.7861110174443624e-7,-0.000004770442341778068,0.8331330139697966,0.5530726724498041],[1,179.99878138597225,-179.99915270600772,67.15613517320901]],[6,"Bn_Mouth",-26,[1,"89CoNx03Fe95p6c3PgddFh",1,0],[1,0.1322927474975586,0.8844605684280396,0.0000019073486328125],[3,-0.06744714874232752,0.6958798219497017,0.7094951918431234,-0.08842357310848374],[1,-90.93173238028068,-178.39319594896983,-12.670413083369786]]],1,4,4,4,4,4,4,4,4,4,4,4,1,4,1,4,4,1,4,4],[1,"a84YD19Gdc1L3jl37FEJEs",1,0],[1,0.5518631935119629,0.09183895587921143,2.547251369833248e-7],[3,-1.1069167078265287e-13,1.1962683563867385e-7,-0.043131225804261084,0.9990694156867217],[1,5.934478864202835e-7,0.000013746614115451107,-4.944008108247556]],[39,"Bip001 Jaw",2,[[[6,"Bip001 R_Down_Lip",-27,[1,"c6PyF6E9Fejpf+FhJZKAVH",1,0],[1,0.22414958477020264,-0.02978229522705078,-0.08345255255699158],[3,0.0379035511010869,-0.08312863876031353,-0.006381982952408379,0.9957972788300739],[1,4.269098997992235,-9.503310182423972,-1.0893766456782763]],[6,"Bip001 L_Down_Lip",-28,[1,"57n9xYdK5ZWIvmtHeYAceX",1,0],[1,0.22414958477020264,-0.029782772064208984,0.08345238864421844],[3,-0.037903543695988244,0.08312866121180473,-0.006381548032422486,0.9957972800249704],[1,-4.269102224069318,9.503314555275125,-1.0893270358589797]],[6,"Bip001 Down_Lip",-29,[1,"1cIIaKZ1pcGLS4H52SXjPZ",1,0],[1,0.2706289291381836,-0.04498434066772461,-0.0000031644667615182698],[3,1.3287119702936462e-8,5.713210890487879e-7,-0.0257779617757464,0.9996676931292525],[1,0.000003214003631930435,0.00006557321519133576,-2.954264076398538]],-30,[6,"Bip001 DownTeeth",-31,[1,"d42HOx4B5W6oKyikGCD94J",1,0],[1,0.2538257837295532,-0.03244733810424805,-0.000030705345125170425],[3,1.7297688071575725e-14,-2.3735439809270516e-8,0.008557617494658156,0.999963382921002],[1,2.3281093649878275e-8,-0.000002720179887652147,0.9806426997154128]]],4,4,4,1,4],[1,"5bcRdelBNcnqSCWgDkZn2m",1,0],[1,0.1990981101989746,0.5892319679260254,0.000001037686160998419],[3,2.504685350165249e-7,-0.000002399451695679412,0.8283695703185308,0.5601819837914038],[1,179.99934519577238,-179.99952254268467,68.1367681348831]],[35,"Bip001 Neck",[[-32,-33,-34,[6,"Bip001 Hair01",-35,[1,"05vzGOWtNStKzQvyWde+Ao",1,0],[1,-0.06071972846984863,-0.2820974588394165,8.112858722597593e-7],[3,1.6516783028762314e-14,0.0000018647883395428245,-0.6723349568022915,0.7402470573113974],[1,0.0014976386299721703,0.0016489140950808594,-84.49506936731329]]],1,1,1,4],[1,"cf54cUQTFQdaEFKgi0tXhy",1,0],[1,0.9543073177337646,-0.3201141357421875,-5.500842235051095e-7],[3,1.1810981550389486e-14,6.097828807722803e-7,-0.2198525345649096,0.9755331173491822],[1,0.000017006426557973736,0.00007546117671314657,-25.40074358145492]],[34,"Bip001 Spine",[-36,-37,-38],[1,"f2uk/fraBW44RrsLTmM1qH",1,0],[1,0.400854229927063,0.015083789825439453,4.153639565629419e-7],[3,-0.000002052787330614699,-6.669589654747255e-7,-0.037431762275221075,0.9992991860140349],[1,-0.0002385966896096073,-0.0000854188249321574,-4.290366292445109]],[39,"Bip001 Neck1",4,[[-39,[81,"Bip001 Hair02",-40,[1,"14Ad035ANcloqi0mJImlLj",1,0],[1,-0.017128705978393555,-0.21748805046081543,-5.193219294596929e-7],[3,-7.012453917385995e-13,0.0000019041008676043273,-0.6865084912899153,0.7271217857987882],[1,0.9999989867210388,0.9999989867210388,1],[1,0.002609061184881379,0.0027634112797080704,-86.70871443960806]]],1,4],[1,"56D6KHIFhfjJguAA9oJ5nd",1,0],[1,0.6923840045928955,-0.00044989585876464844,-1.2480541045079008e-9],[3,5.735766379024929e-14,8.440700028776635e-8,-0.03043228257955449,0.9995368308256535],[1,2.949038769998187e-7,0.000009685790513410704,-3.487821205901098]],[117,"Bip001 Neck2",6,[[2,[6,"Bip001 Hair03",-41,[1,"14c21KloFeW4TnZpqdpSeQ",1,0],[1,0.22313594818115234,-0.1733543872833252,-0.0000010999831374647329],[3,-5.501903323788317e-13,0.0000018955203604483748,-0.683414953116773,0.7300301376332389],[1,0.0022529890159768756,0.00240666367779299,-86.22215868172809]]],1,4],[1,"4eUfYIsfZUlrwpmZtd7TvP",1,0],[1,0.5660121440887451,-0.0004042387008666992,-1.1214069672860205e-9]],[111,"VD297_Giraffe_Toy",1,[[44,-42,[11,"a8ImwwjX5VlpOBY5oz0MC1"],[0,1,2,3,4,5,6,7,8,9,10,11,12],[24],1,13,14]],[1,"e3FAH3cZhSZLsUbfJUC80S",1,0],[1,0,-0.00011903722770512104,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[7,"Bip001",1,[-43],[1,"27goImrUhSiLj/q8l+pR3q",1,0],[1,-4.356060401278228e-9,2.378934383392334,-0.8954776525497437],[3,0,4.329780375814312e-17,-0.7071067811865476,0.7071067811865476],[1,0,0,-90]],[69,"Bip001 Pelvis",9,[5],[1,"0bz+t64LpWRoPHsBCKwTl/",1,0],[3,-0.49999999254917427,-0.49999999254917427,-0.49999930709576956,0.5000007078049009],[1,-89.99991974527727,-89.99991974527727,-0.0000017074910602964197]],[7,"Bip001 Spine1",5,[4],[1,"76JitRG4Bb6IWeWws2pnXN",1,0],[1,0.6363147497177124,-0.0006434917449951172,-1.7844286048784852e-9],[3,-5.001003109185003e-14,6.055923869577305e-7,-0.21834164731705358,0.9758723917841453],[1,0.000016748928224149575,0.00007485893130099625,-25.2232972333355]],[14,"Bip001 R_Ear",2,[[6,"Bip001 R_Ear02",-44,[1,"7c7vkHe8taurwV9/b63dyq",1,0],[1,0.24279451370239258,-0.00015926361083984375,-0.00006985664367675781],[3,0.1943117099157505,-0.021092375925360597,0.2231939752599514,0.9549777591520656],[1,24.76597094901678,-8.038122542265535,24.71428519601091]]],[1,"d2RYeAmwZVVbYhAqdc4wDo",1,0],[1,0.29334402084350586,0.004457592964172363,-0.16000939905643463],[3,0.16336328288055393,0.39462871559616325,-0.6255358051764845,0.6529054840293637],[1,76.93816074345585,97.44558932195352,-43.46377554217515]],[7,"Bip001 Tongue01",3,[-45],[1,"5fP7MY0KRScq+eqbAl68XC",1,0],[1,0.09311747550964355,-0.010273933410644531,-7.956077752169222e-8],[3,-1.3280751676258093e-7,-5.582045435328034e-7,-0.11713972903232928,0.9931154433810317],[1,-0.000023244665055349306,-0.00006715070549894516,-13.454113569998423]],[14,"Bip001 Tongue02",13,[[6,"Bip001 Tongue03",-46,[1,"14ITHPHChYjbDoBqTnlyOE",1,0],[1,0.057037353515625,0.000232696533203125,-1.6103513189591467e-7],[3,-0.0000014086552937428342,1.1217554662923372e-9,1.490116297018971e-8,0.9999999999990077],[1,-0.0001614200062424202,1.2854611307425332e-7,0.0000017075473149815245]]],[1,"d4iQC7nKxUyoITQdTj5HN0",1,0],[1,0.06330013275146484,0.0005035400390625,1.3969838619232178e-9],[3,2.34142972213993e-13,-1.4840483635151933e-7,0.05350618418461001,0.9985675181248289],[1,9.151900506504044e-7,-0.00001707937578821318,6.134286427783285]],[7,"Bip001 Tail_01",2,[-47],[1,"fd1KRbHfVdb5Q/fJ5w91SW",1,0],[1,-3.099538564682007,-1.777132272720337,-0.0000052145178415230475],[3,2.8648892559348733e-7,0.000003959627048611977,-0.7996029223990082,0.6005290721315704],[1,179.99862760717215,179.9989282292747,-73.81559809876565]],[7,"Bip001 Tail_02",15,[-48],[1,"4bY2R+ZuhfRbqPseCyF6kY",1,0],[1,0.276302695274353,0.0013399124145507812,-8.407732821069658e-8],[3,-1.6811053228192466e-7,-1.8257904405254525e-7,-0.06674220435377931,0.9977702531935582],[1,-0.000020802808719429435,-0.000022360300422630196,-7.653782761696829]],[7,"Bip001 Tail_03",16,[-49],[1,"55lY+R+5VfcL3MRr4OPaf/",1,0],[1,0.3749101161956787,0.010757684707641602,-8.89989678398706e-7],[3,-0.0000015325682318977173,0.0000016193943924228711,-0.017069453032498388,0.9998543062707688],[1,-0.00017252677321186527,0.00018265060150047768,-1.9561102335835894]],[14,"Bip001 Tail_04",17,[[6,"Bip001 Tail_05",-50,[1,"d9Du9LEYtYd6fEY+RDtLSd",1,0],[1,0.3159787654876709,-0.00016641616821289062,-8.189126674551517e-7],[3,-0.0000014061682804794182,-0.0000014202421425551375,1.0151216400779641e-7,0.9999999999979976],[1,-0.00016113499899229333,-0.0001627477449527858,0.000011632665984489571]]],[1,"37bpu2CtdYWYgYXX1+Fi7a",1,0],[1,0.3840022087097168,-0.013496160507202148,-0.0000010278017725795507],[3,-0.0000014331359352548016,0.0000014222537174612764,-7.976756251063611e-7,0.9999999999976437],[1,-0.00016422515111352108,0.00016297813981618533,-0.00009140712704794832]],[14,"Bip001 L_Ear",2,[[6,"Bip001 L_Ear02",-51,[1,"16zFfly2pUNYXtnr5x4XBX",1,0],[1,0.24279439449310303,-0.00015878677368164062,0.0000699758529663086],[3,-0.19431173719916414,0.02109113885556124,0.22319412137824649,0.9549777467724632],[1,-24.765946391686672,8.037979485146726,24.714332699889397]]],[1,"754t+mjF9VIpOTs7KdhAPA",1,0],[1,0.29334354400634766,0.0044564008712768555,0.16000941395759583],[3,-0.16336253074214327,-0.3946245857720451,-0.6255386986925687,0.6529053961270129],[1,-76.93861022551313,-97.44570159305196,-43.46421850753999]],[7,"Bip001 L Clavicle",4,[-52],[1,"e8IZExt/9Zj4U6ZKChzAp8",1,0],[1,-0.6252610683441162,-0.15536224842071533,0.3209458291530609],[3,0.6218016091848645,0.3824239934956703,0.39082494027587333,0.5606875369332697],[1,101.18437273864923,-8.096527187598403,66.04223841119425]],[7,"Bip001 L UpperArm",20,[-53],[1,"d4y+2xk59a2r6WSeI/vdA+",1,0],[1,0.4305196702480316,5.960464477539063e-8,0],[3,-0.4766226478125026,0.5748613557875564,0.4806062944999592,0.45976392083471496],[1,-85.17161138936022,97.09950957592135,-6.087838604977945]],[7,"Bip001 L Forearm",21,[-54],[1,"feam7ruXVQvZy90w4OSN1y",1,0],[1,0.5732908248901367,0,1.4901161193847656e-8],[3,1.8073457900254473e-18,-3.619298562452549e-18,-0.10238340452658577,0.9947450117882197],[1,1.6705795063605852e-16,-3.99737720120276e-16,-11.752868225791161]],[14,"Bip001 L Hand",22,[[6,"Bip001 L Finger0",-55,[1,"3byxQ4HQJX6rqKO+WPtPaP",1,0],[1,0.825505793094635,0.00021010637283325195,-0.016567260026931763],[3,-0.003084158369715048,0.013701365674395385,0.019711368282363303,0.9997070683486458],[1,-0.38456341678652844,1.5779873400313138,2.253833657637567]]],[1,"1arjDVWixWE6C/bv+TdkwO",1,0],[1,1.0205600261688232,-5.960464477539063e-8,0],[3,-0.706795399661755,-0.0019021578041327138,-0.062264722302334395,0.7046699576179485],[1,-90.39524475854142,-5.222724049499616,-4.879664052241934]],[7,"Bip001 R Clavicle",4,[-56],[1,"7c+r1SaXFbJIz1+lTaGNL8",1,0],[1,-0.6252610683441162,-0.15536046028137207,-0.3209473192691803],[3,-0.621800054529036,-0.3824250931463723,0.3908238642904015,0.5606892610178962],[1,-101.18359469678377,8.095814037152945,66.04228349204378]],[7,"Bip001 R UpperArm",24,[-57],[1,"27MQcNugdU3YnRBSyPx/OP",1,0],[1,0.4305196702480316,5.960464477539063e-8,-4.440892098500626e-16],[3,-0.4766226478125026,0.5748613557875564,-0.4806062944999592,-0.45976392083471496],[1,85.17161138936022,-97.09950957592135,-6.087838604977945]],[7,"Bip001 R Forearm",25,[-58],[1,"1aix5QZVtffaZlYVrLXuzk",1,0],[1,0.5732908248901367,1.1102230246251565e-16,-1.4901161193847656e-8],[3,1.1160960807208764e-18,4.490079861320526e-18,-0.10238340452658577,0.9947450117882197],[1,1.8375430731814063e-16,5.361561372211306e-16,-11.752868225791161]],[14,"Bip001 R Hand",26,[[6,"Bip001 R Finger0",-59,[1,"528DScHiFfopPcfjRBeca+",1,0],[1,0.825505793094635,0.00021010637283325195,0.016567260026931763],[3,0.003084158369715048,-0.013701365674395385,0.019711368282363303,0.9997070683486458],[1,0.38456341678652844,-1.5779873400313138,2.253833657637567]]],[1,"65Hr4qA4tY9J8Jvd+K0x5F",1,0],[1,1.0205599069595337,-5.960464477539063e-8,-5.551115123125783e-17],[3,0.706795399661755,0.0019021578041327138,-0.062264722302334395,0.7046699576179485],[1,90.39524475854142,5.222724049499616,-4.879664052241934]],[7,"Bip001 L Thigh",5,[-60],[1,"11BAfAQWVSDq0Huwsgvaqy",1,0],[1,-0.39860236644744873,-0.045030832290649414,0.31775563955307007],[3,0.6697904583392761,0.7425501474978701,0.0000828426578436208,-0.00011621380163828846],[1,-0.15539599845470578,-179.84189640298345,84.10176769549689]],[7,"Bip001 L Calf",28,[-61],[1,"dayS5tevFSZqR9L49DlLE1",1,0],[1,0.6152560710906982,-5.960464477539063e-8,0],[3,2.3134668868276776e-24,-5.182844774448237e-20,-0.19607236564834585,0.9805894285729687],[1,-1.2612065319290729e-18,-6.308848736250139e-18,-22.614750028058115]],[7,"Bip001 L HorseLink",29,[-62],[1,"4eZ9lbh79WQ7KnvB+7+zxC",1,0],[1,0.6745597720146179,4.440892098500626e-16,-2.9802322387695312e-8],[3,1.1641626586293666e-11,1.7558664120709856e-11,0.22098652425649812,0.9752768612537837],[1,9.4910882731769e-10,1.8480233733852806e-9,25.53396581578114]],[14,"Bip001 L Foot",30,[[6,"Bip001 L Toe0",-63,[1,"9eXV3vCA5TaIZGzjUDTB7g",1,0],[1,0.06374531984329224,-0.008129239082336426,-2.9802322387695312e-8],[3,7.147154967240356e-14,1.130674135800072e-13,-0.008726830662804639,0.9999619204882667],[1,8.304059067177777e-12,1.3029535472831268e-11,-1.0000338246402656]]],[1,"27d7tBW79d3Krcc+XS9kjS",1,0],[1,0.8986997008323669,1.1920928955078125e-7,0],[3,-0.000024228231144416933,-0.00014043359188703749,-0.0027167782979811692,0.9999962993966922],[1,-0.0028201019021005386,-0.016100225290632233,-0.31131985060473577]],[7,"Bip001 R Thigh",5,[-64],[1,"80xBgp43xZAaNnhTprLbP3",1,0],[1,-0.39860236644744873,-0.0450291633605957,-0.31775563955307007],[3,0.6697904585943798,0.7425501477806858,-0.00008071986082393435,0.00011441641456539929],[1,0.15229580824553335,179.84497019075718,84.1017685548488]],[7,"Bip001 R Calf",32,[-65],[1,"35suY1tUlZY6a8OdTLav2m",1,0],[1,0.6152560710906982,-5.960464477539063e-8,-5.551115123125783e-17],[3,-9.964784720143505e-22,-4.9835490194608505e-21,-0.19607236564834585,0.9805894285729687],[1,-2.4259603755906904e-19,-6.308848663652707e-19,-22.614750028058115]],[7,"Bip001 R HorseLink",33,[-66],[1,"a8Hm0zESxYv6gYOiTo0hxR",1,0],[1,0.6745598316192627,1.1920928955078125e-7,2.9802322387695312e-8],[3,-2.12874833573142e-11,-3.4665110129492556e-11,0.22098652425649812,0.9752768612537837],[1,-1.6637217959020381e-9,-3.6960467942528948e-9,25.53396581578114]],[14,"Bip001 R Foot",34,[[6,"Bip001 R Toe0",-67,[1,"49XHXwZQJSX7a3Ea2snvla",1,0],[1,0.06374531984329224,-0.008129239082336426,2.9802322387695312e-8],[3,-7.423691575647812e-14,6.478770305492795e-16,-0.00872682880030133,0.999961920504521],[1,-8.507247866030362e-12,-5.670285097220125e-20,-1.0000336112049801]]],[1,"c4UT6iM6ZavIrWG+TU0Tk4",1,0],[1,0.8986997008323669,1.1920928955078125e-7,5.551115123125783e-17],[3,0.000024315635403754084,0.00014043181655312579,-0.0027167782979760826,0.9999962993948199],[1,0.0028301172505327196,0.01610004906114549,-0.3113198492019426]]],0,[0,10,1,0,0,1,0,-1,8,0,-2,9,0,10,1,0,1,1,0,-1,12,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,-13,3,0,1,2,0,-15,15,0,1,2,0,1,2,0,-18,19,0,1,2,0,1,2,0,1,3,0,1,3,0,1,3,0,-4,13,0,1,3,0,-1,6,0,-2,20,0,-3,24,0,1,4,0,-1,11,0,-2,28,0,-3,32,0,-1,7,0,1,6,0,1,7,0,0,8,0,-1,10,0,1,12,0,-1,14,0,1,14,0,-1,16,0,-1,17,0,-1,18,0,1,18,0,1,19,0,-1,21,0,-1,22,0,-1,23,0,1,23,0,-1,25,0,-1,26,0,-1,27,0,1,27,0,-1,29,0,-1,30,0,-1,31,0,1,31,0,-1,33,0,-1,34,0,-1,35,0,1,35,0,16,1,2,1,7,4,1,11,5,1,10,67],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,14,19,-1,36],[6,6,6,6,6,6,6,6,6,6,6,6,134,135,136,42,42]],[[[36,"Food_Twigs"],[48,"Food_Twigs",[-3],[[67,-2,[11,"94ZfriNQhLXaEC2D1SGaXc"]]],[1,"49wxs6a3tWJropely20Bt5",-1,0],[1,0.1,0.1,0.1]],[31,"Food_Twigs",1,[[62,-4,[11,"f6yv6mirNfcItnc7fIxuaT"],[0],[24],1]],[1,"28F/PZnHBVwL5SMk0egZYR",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]]],0,[0,10,1,0,0,1,0,-1,2,0,0,2,0,16,1,4],[0,0],[-1,14],[137,138]],[[{"name":"VD302_Kangaroo_Toy_Icon","rect":{"x":60,"y":29,"width":144,"height":212},"offset":{"x":4,"y":-7},"originalSize":{"width":256,"height":256},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[139]],[[{"name":"UI_Icon_Toy_Selection","rect":{"x":24,"y":45,"width":207,"height":165},"offset":{"x":-0.5,"y":0.5},"originalSize":{"width":256,"height":256},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[140]],[[{"name":"UI_MM_Item_Selected","rect":{"x":2,"y":10,"width":254,"height":242},"offset":{"x":1,"y":-3},"originalSize":{"width":256,"height":256},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[141]],[[{"name":"board_encyclopedia","rect":{"x":0,"y":1,"width":1424,"height":1123},"offset":{"x":0,"y":-0.5},"originalSize":{"width":1424,"height":1124},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[142]],[[{"name":"CN_Skip","rect":{"x":0,"y":0,"width":450,"height":225},"offset":{"x":0,"y":0},"originalSize":{"width":450,"height":225},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[143]],[[{"name":"UI_Sound Button","rect":{"x":0,"y":0,"width":145,"height":150},"offset":{"x":0,"y":0},"originalSize":{"width":145,"height":150},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[144]],[[{"name":"UI_btn_close","rect":{"x":0,"y":0,"width":197,"height":202},"offset":{"x":0,"y":0},"originalSize":{"width":197,"height":202},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[145]],[[{"name":"Kangaroo-2","rect":{"x":1,"y":1,"width":280,"height":398},"offset":{"x":0,"y":0},"originalSize":{"width":282,"height":400},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[146]],[[{"name":"UI_Customization_tab","rect":{"x":0,"y":0,"width":275,"height":199},"offset":{"x":0,"y":0},"originalSize":{"width":275,"height":199},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[147]],[[[173,[{}],[{}]]],0,0,[0],[12],[41]],[[{"name":"UI_Icon_Food_Algea","rect":{"x":46,"y":21,"width":419,"height":470},"offset":{"x":-0.5,"y":0},"originalSize":{"width":512,"height":512},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[148]],[[{"name":"VD289_Lion_Toy_Icon","rect":{"x":43,"y":20,"width":197,"height":221},"offset":{"x":13.5,"y":-2.5},"originalSize":{"width":256,"height":256},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[149]],[[[25,"Food_AssetsA",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"albedoScale":0.5,"metallic":0,"roughness":0.5,"emissiveScale":1,"alphaSource":1},"mainColor",8,[4,4286545791],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[15,12],[150,5]],[[[28,".bin",773436362,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":6720,"length":2304,"count":576,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":6720,"count":140,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-2.4059858322143555,-2.1569759845733643,-0.4776197671890259],"maxPosition",8,[1,2.4059858322143555,2.1569759845733643,0.4776197671890259]]],-1],0,0,[],[],[]],[[[36,"KagarooRoot"],[118,"KagarooRoot",[[-5,[47,"FeedPosition",-7,[1,"b1ejwKP8BBD6UH4x6Zi3XS",-6,0],[1,0,0,-2.5]]],1,4],[[170,null,null,null,-4,[11,"f0+X1ZhodFgJJg4GPQVMFV"],-3]],[122,"53vKouf8tIqrJE9sorGNMt",-2,0,[-1]],[1,0,0,0.696],[3,0,1,0,6.123233995736766e-17],[1,0,180,0]],[0,["08p3MFuydXL4oM9CbjboO3"]],[30,0,null,1,[23,"8fJHyWPHhT77T0qzBIqM/Z",-19,[88,"1dRKqITCJJR6zNWur3+Cgc",1,[[22,[0,["8fJHyWPHhT77T0qzBIqM/Z"]],[[73,-18,[11,"71SN8zFoFC/5gBHzxRLc1H"],1]]]],[[2,["_lpos"],-8,[1,0,0,0]],[4,"VD302_Kangaroo_Rig",["_name"],-9],[2,["_lrot"],-10,[3,0,1,0,6.123233995736766e-17]],[2,["_euler"],-11,[1,0,180,0]],[4,2,["_clips","length"],2],[19,["_clips","0"],2,2],[19,["_defaultClip"],2,3],[4,false,["playOnLoad"],2],[19,["_clips","1"],2,4],[4,false,["_useBakedAnimation"],2],[2,["_lrot"],-12,[3,0,0,0,1]],[2,["_euler"],-13,[1,0,0,0]],[2,["_lrot"],-14,[3,-0.5,-0.5,-0.4999999999999999,0.5000000000000001]],[2,["_euler"],-15,[1,-90,-90,0]],[2,["_lrot"],-16,[3,0,0,-6.698506168543417e-16,1]],[2,["_euler"],-17,[1,0,0,-7.67592264999771e-14]],[4,true,["_enabled"],2]]],0]],[0,["8fJHyWPHhT77T0qzBIqM/Z"]],[0,["5fl0cfxJ5Rs5ovU2QsXaQ9"]],[0,["61SpoqJn9XKIWNc6m3Gvr3"]],[0,["f3CmudYmJTjK7M6nViAmg5"]]],0,[0,-1,3,0,10,1,0,37,3,0,0,1,0,-1,3,0,10,1,0,1,1,0,5,4,0,5,4,0,5,4,0,5,4,0,5,5,0,5,5,0,5,6,0,5,6,0,5,7,0,5,7,0,0,3,0,10,3,0,16,1,19],[0,0,0,0,0],[13,21,11,11,11],[24,25,9,9,22]],[[{"name":"Giraffe-2","rect":{"x":1,"y":1,"width":351,"height":586},"offset":{"x":0,"y":0},"originalSize":{"width":353,"height":588},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[151]],[[{"name":"UI_Rotate_Right","rect":{"x":45,"y":29,"width":167,"height":198},"offset":{"x":0.5,"y":0},"originalSize":{"width":256,"height":256},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[152]],[[{"name":"title_green","rect":{"x":0,"y":1,"width":1023,"height":253},"offset":{"x":-0.5,"y":0.5},"originalSize":{"width":1024,"height":256},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[153]],[[[28,".bin",3715973771,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":10704,"length":3096,"count":774,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":10704,"count":223,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-2.483253240585327,-3.0616281032562256,-0.5437402129173279],"maxPosition",8,[1,2.483253240585327,3.0616281032562256,0.5437402129173279]]],-1],0,0,[],[],[]],[[[25,"Food_AssetsB",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"albedoScale":1,"metallic":0,"roughness":0,"emissiveScale":1,"alphaSource":1},"mainColor",8,[4,4286545791],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[15,12],[154,5]]]]
